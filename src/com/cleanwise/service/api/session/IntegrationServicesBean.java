package com.cleanwise.service.api.session;

import java.io.File;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.rmi.RemoteException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeMap;

import javax.ejb.CreateException;
import javax.naming.NamingException;

import oracle.sql.BLOB;

import org.apache.log4j.Logger;

import com.avalara.avatax.services.tax.ArrayOfMessage;
import com.avalara.avatax.services.tax.Message;
import com.cleanwise.service.api.APIAccess;
import com.cleanwise.service.api.APIServiceAccessException;
import com.cleanwise.service.api.dao.AddressDataAccess;
import com.cleanwise.service.api.dao.BackorderDataAccess;
import com.cleanwise.service.api.dao.BudgetDAO;
import com.cleanwise.service.api.dao.BusEntityAssocDataAccess;
import com.cleanwise.service.api.dao.BusEntityDAO;
import com.cleanwise.service.api.dao.BusEntityDataAccess;
import com.cleanwise.service.api.dao.CatalogAssocDataAccess;
import com.cleanwise.service.api.dao.CatalogDataAccess;
import com.cleanwise.service.api.dao.CatalogStructureDataAccess;
import com.cleanwise.service.api.dao.ContractDataAccess;
import com.cleanwise.service.api.dao.ContractItemDataAccess;
import com.cleanwise.service.api.dao.ContractItemSubstDataAccess;
import com.cleanwise.service.api.dao.CostCenterAssocDataAccess;
import com.cleanwise.service.api.dao.CostCenterDataAccess;
import com.cleanwise.service.api.dao.Edi997DataAccess;
import com.cleanwise.service.api.dao.ElectronicTransactionDataAccess;
import com.cleanwise.service.api.dao.EmailDataAccess;
import com.cleanwise.service.api.dao.FiscalCalenderDataAccess;
import com.cleanwise.service.api.dao.FreightTableCriteriaDataAccess;
import com.cleanwise.service.api.dao.InterchangeDataAccess;
import com.cleanwise.service.api.dao.InventoryLevelDAO;
import com.cleanwise.service.api.dao.InvoiceCustDataAccess;
import com.cleanwise.service.api.dao.InvoiceCustDetailDataAccess;
import com.cleanwise.service.api.dao.InvoiceCustReengDataAccess;
import com.cleanwise.service.api.dao.InvoiceDistDataAccess;
import com.cleanwise.service.api.dao.InvoiceDistDetailDataAccess;
import com.cleanwise.service.api.dao.ItemAssocDataAccess;
import com.cleanwise.service.api.dao.ItemDataAccess;
import com.cleanwise.service.api.dao.ItemMappingDataAccess;
import com.cleanwise.service.api.dao.ItemMetaDataAccess;
import com.cleanwise.service.api.dao.JanitorClosetDataAccess;
import com.cleanwise.service.api.dao.JoinDataAccess;
import com.cleanwise.service.api.dao.ManifestItemDataAccess;
import com.cleanwise.service.api.dao.OrderAddressDataAccess;
import com.cleanwise.service.api.dao.OrderCreditCardDataAccess;
import com.cleanwise.service.api.dao.OrderDAO;
import com.cleanwise.service.api.dao.OrderDataAccess;
import com.cleanwise.service.api.dao.OrderFreightDataAccess;
import com.cleanwise.service.api.dao.OrderGuideDataAccess;
import com.cleanwise.service.api.dao.OrderGuideStructureDataAccess;
import com.cleanwise.service.api.dao.OrderItemActionDataAccess;
import com.cleanwise.service.api.dao.OrderItemDataAccess;
import com.cleanwise.service.api.dao.OrderMetaDataAccess;
import com.cleanwise.service.api.dao.OrderPropertyDataAccess;
import com.cleanwise.service.api.dao.OrderScheduleDataAccess;
import com.cleanwise.service.api.dao.PdManifestDataAccess;
import com.cleanwise.service.api.dao.PhoneDataAccess;
import com.cleanwise.service.api.dao.PipelineDataAccess;
import com.cleanwise.service.api.dao.PreOrderDataAccess;
import com.cleanwise.service.api.dao.PriceListAssocDataAccess;
import com.cleanwise.service.api.dao.PriceListDataAccess;
import com.cleanwise.service.api.dao.PriceListDetailDataAccess;
import com.cleanwise.service.api.dao.ProductDAO;
import com.cleanwise.service.api.dao.PropertyDataAccess;
import com.cleanwise.service.api.dao.PurchaseOrderDataAccess;
import com.cleanwise.service.api.dao.RemittanceDataAccess;
import com.cleanwise.service.api.dao.RemittancePropertyDataAccess;
import com.cleanwise.service.api.dao.SequenceUtilDAO;
import com.cleanwise.service.api.dao.ShoppingDAO;
import com.cleanwise.service.api.dao.SiteDeliveryDataAccess;
import com.cleanwise.service.api.dao.TradingPartnerAssocDataAccess;
import com.cleanwise.service.api.dao.TradingPartnerDataAccess;
import com.cleanwise.service.api.dao.TradingProfileConfigDataAccess;
import com.cleanwise.service.api.dao.TradingProfileDataAccess;
import com.cleanwise.service.api.dao.TradingPropertyMapDataAccess;
import com.cleanwise.service.api.dao.UserAssocDataAccess;
import com.cleanwise.service.api.dao.UserDAO;
import com.cleanwise.service.api.dao.UserDataAccess;
import com.cleanwise.service.api.dto.template.AccountDto;
import com.cleanwise.service.api.dto.template.AddressDto;
import com.cleanwise.service.api.dto.template.DistributorDto;
import com.cleanwise.service.api.dto.template.OrderDto;
import com.cleanwise.service.api.dto.template.OrderItemDto;
import com.cleanwise.service.api.eventsys.FileAttach;
import com.cleanwise.service.api.framework.BusEntityServicesAPI;
import com.cleanwise.service.api.framework.IntegrationServicesAPI;
import com.cleanwise.service.api.framework.ValueObject;
import com.cleanwise.service.api.pipeline.MakeLedgerEntry;
import com.cleanwise.service.api.pipeline.OrderPipelineActor;
import com.cleanwise.service.api.pipeline.OrderPipelineBaton;
import com.cleanwise.service.api.process.operations.EasternBagSiteLoader;
import com.cleanwise.service.api.util.BudgetRuleException;
import com.cleanwise.service.api.util.BudgetUtil;
import com.cleanwise.service.api.util.BudgetYTDRuleException;
import com.cleanwise.service.api.util.CacheManager;
import com.cleanwise.service.api.util.DBAccess;
import com.cleanwise.service.api.util.DBCriteria;
import com.cleanwise.service.api.util.DataNotFoundException;
import com.cleanwise.service.api.util.DistributorInvoiceNumTool;
import com.cleanwise.service.api.util.InvalidLoginException;
import com.cleanwise.service.api.util.ItemSkuMapping;
import com.cleanwise.service.api.util.OrderTotalException;
import com.cleanwise.service.api.util.OrderWorkflowException;
import com.cleanwise.service.api.util.PasswordUtil;
import com.cleanwise.service.api.util.PipelineCalculationOperations;
import com.cleanwise.service.api.util.PropertyFieldUtil;
import com.cleanwise.service.api.util.PropertyUtil;
import com.cleanwise.service.api.util.RefCodeNames;
import com.cleanwise.service.api.util.TaxCalculationException;
import com.cleanwise.service.api.util.TaxUtilAvalara;
import com.cleanwise.service.api.util.TaxUtilAvalara.AvalaraTaxEntry;
import com.cleanwise.service.api.util.TaxUtilAvalara.AvalaraTaxItem;
import com.cleanwise.service.api.util.TemplateUtilities;
import com.cleanwise.service.api.util.UserRightsTool;
import com.cleanwise.service.api.util.Utility;
import com.cleanwise.service.api.value.*;
import com.cleanwise.service.api.wrapper.BudgetViewWrapper;
import com.cleanwise.service.api.wrapper.InventoryLevelViewWrapper;
import com.cleanwise.service.apps.ApplicationsEmailTool;
import com.cleanwise.service.apps.dataexchange.VerifyCustInvoices;
import com.cleanwise.view.utils.Constants;

/**
 *  class <code>IntegrationServicesBean</code>, provides the
 *  methods to process an order through its full processing
 *  cycle.
 *
 * @author <a href="mailto:dvieira@DVIEIRA"></a>
 */
public class IntegrationServicesBean extends IntegrationServicesAPI {
	private static final long serialVersionUID = -8463899741410056479L;

	private static final Logger log = Logger.getLogger(IntegrationServicesBean.class);

    private final static String className = "IntegrationServicesBean";

    private static final BigDecimal ONE = new BigDecimal(1);
    private static final BigDecimal ZERO = new BigDecimal(0);
    private static final double ADMISSIBLE_TAX_ERROR = 0.05;
    /**
     * Creates a new <code>IntegrationServicesBean</code> instance.
     *
     */
    public IntegrationServicesBean() {
    }

    /**
     * Standard <code>ejbCreate</code> method.
     *
     * @exception CreateException if an error occurs
     * @exception RemoteException if an error occurs
     */
    public void ejbCreate()
                   throws CreateException, RemoteException {
    }



    static final Comparator ORDER_ACCOUNT_COMPARE = new Comparator() {
        public int compare(Object o1, Object o2)
        {
            String account1 =
                ((OrderData)o1).getAccountErpNum();
            String account2 =
                ((OrderData)o2).getAccountErpNum();
            return account1.compareTo(account2);
        }
    };

    private synchronized int getNextStoreNumber(Connection pConn, int pStoreId)
                                         throws RemoteException, SQLException {

        int nextnum = 0;
        int numStoreId = pStoreId;
        //Get numbering store
        DBCriteria dbc = new DBCriteria();
        dbc.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,pStoreId);
        dbc.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,
                      RefCodeNames.PROPERTY_TYPE_CD.ORDER_NUMBERING_STORE_ID);
        PropertyDataVector propDV = PropertyDataAccess.select(pConn,dbc);
        for(int ii=0; ii<propDV.size(); ii++) {
            PropertyData pD = (PropertyData) propDV.get(ii);
            String val = pD.getValue();
            int nsId = 0;
            try{
              nsId = Integer.parseInt(val);
            } catch(Exception exc) {
              String mess = "Wrong store property format. Property name = "+
                  RefCodeNames.PROPERTY_TYPE_CD.ORDER_NUMBERING_STORE_ID +
                  " Property value = "+val+ " Store Id = "+pStoreId;
              throw new RemoteException(mess);
            }
            if(ii==0) {
              numStoreId = nsId;
            } else if (numStoreId != nsId) {
              String mess = "More than one store property value. Property name = "+
                  RefCodeNames.PROPERTY_TYPE_CD.ORDER_NUMBERING_STORE_ID +
                  " Store Id = "+pStoreId;
              log.info(mess);
            }
        }
        ////////////////////////////////////
        //Lock store order number by increasing it by one
        String sql = "UPDATE CLW_PROPERTY SET CLW_VALUE = TO_CHAR(TO_NUMBER(CLW_VALUE)+1), MOD_DATE=?, MOD_BY=? WHERE BUS_ENTITY_ID = ? AND PROPERTY_TYPE_CD=?";
        int ii = 1;
        java.util.Date current = new java.util.Date(System.currentTimeMillis());
        PreparedStatement pstmt = pConn.prepareStatement(sql);
        pstmt.setDate(ii++, DBAccess.toSQLDate(current));
        pstmt.setString(ii++, "UNKNOWN");
        pstmt.setInt(ii++, numStoreId);
        pstmt.setString(ii++, RefCodeNames.PROPERTY_TYPE_CD.STORE_ORDER_NUM);
        log.debug("SQL:   MOD_DATE=" + current);
        log.debug("SQL:   MOD_BY=" + "UNKNOWN");
        log.debug("SQL:   BUS_ENTITY_ID=" + numStoreId);
        log.debug("SQL:   PROPERTY_TYPE_CD=" + RefCodeNames.PROPERTY_TYPE_CD.STORE_ORDER_NUM);
        log.debug("SQL: " + sql);
        pstmt.executeUpdate();
        pstmt.close();

        //Now pick up value
        dbc = new DBCriteria();
        dbc.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,
                       RefCodeNames.PROPERTY_TYPE_CD.STORE_ORDER_NUM);
        dbc.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID, numStoreId);

        PropertyDataVector propertyDV = PropertyDataAccess.select(pConn, dbc);

        if (propertyDV.size() > 1) {
            throw new RemoteException("Error. OrderBean.placeOrder(). More than one order number record for the store. Store id = " +
                                      numStoreId);
        }

        PropertyData property = (PropertyData)propertyDV.get(0);
        String nextnumS = property.getValue();

        try {
            nextnum = Integer.parseInt(nextnumS);
        } catch (Exception exs) {
            throw new RemoteException("Next order number property doesn't have number format: " +
                                      nextnumS);
        }

        log.debug(" Store id: " + numStoreId + " is now at order number " +nextnum);

        return nextnum;
    }

    private WorkflowRuleResult checkOrderWorkflow(Connection pCon,
                                                  int pSiteId,
                                                  int pAccountId,
                                                  OrderData pOrder,
                                                  OrderItemDataVector pOrderItems,
                                                  String pBypassWkflRuleActionCd) throws Exception {

        // Run the order, as constructed through the
        // workflow  defined for the site.
        WorkflowRuleResult wkflrr = null;

        try {
            WorkflowBean wkfl = new WorkflowBean();
            wkflrr = wkfl.applySiteWorkflow1(pCon, pSiteId, pAccountId, pOrder, pOrderItems, pBypassWkflRuleActionCd);
        } catch (Exception e) {
            // The fact that a site may exist without a workflow is
            // OK.  Allow the purchase.
            wkflrr.setStatus(WorkflowRuleResult.OK);
            log.info("Workflow logic error reported on handling order: " + pOrder);
            e.printStackTrace();
        }

        return wkflrr;
    }

    private void saveToJanitorCloset(Connection pConn,
                                     OrderItemData pOrderItemData, int pUserId,
                                     int pSiteId)
                              throws SQLException {

        if (pSiteId <= 0 ||
            pOrderItemData.getOrderId() <= 0 ||
            pOrderItemData.getItemId() <= 0) {

            // These are the requirements to make an entry
            // in the table.
            return;
        }

        JanitorClosetData jcd = JanitorClosetData.createValue();
        jcd.setBusEntityId(pSiteId);
        jcd.setUserId(pUserId);
        jcd.setItemId(pOrderItemData.getItemId());
        jcd.setOrderId(pOrderItemData.getOrderId());
        jcd.setAddBy(pOrderItemData.getAddBy());
        JanitorClosetDataAccess.insert(pConn, jcd);
    }

    private int makeLedgerEntry(Connection pCon, OrderData pOrder, int pSiteId)
	throws Exception {

        if (pSiteId <= 0) {
	    log.debug(" makeLedgerEntry,  pSiteId=" + pSiteId + "\n\t pOrder=" + pOrder);
            return 1;
        }

        try {
            APIAccess factory = new APIAccess();
            Account accountEjb = factory.getAccountAPI();
            if (!(accountEjb.ledgerSwitchOff(pOrder.getAccountId())
                    && Utility.isInventoryOrder(pOrder.getOrderSourceCd()))){
                MakeLedgerEntry ledgerPlugin = new MakeLedgerEntry();
                ledgerPlugin.ledgerUpdate(pCon, pOrder, factory, pOrder.getAddBy());
            }
        }
        catch (Exception e) {
            log.error("  makeLedgerEntry, error: " + e);
        }
        return 0;
    }

     // A order is decided to be duplciated account id, customer po number
        private boolean duplicateOrder(String pAccountNum,
                                       String pCustomerPONumber,
                                       String pSiteName, Connection con,
                                       boolean pReprocessingOrder)
                                throws RemoteException {

            DBCriteria dbc;

            try {
                dbc = new DBCriteria();
                dbc.addEqualTo(OrderDataAccess.ACCOUNT_ERP_NUM, pAccountNum);
                dbc.addEqualTo(OrderDataAccess.REQUEST_PO_NUM,
                               pCustomerPONumber);
                dbc.addEqualTo(OrderDataAccess.ORDER_SITE_NAME, pSiteName);

                log.debug("Duplicate order sql "+dbc.getWhereClause());
                OrderDataVector orderDV = OrderDataAccess.select(con, dbc);

		logDebug
		    ("== duplicateOrder check, " +
		     "found " + orderDV.size() + " orders." +
		     "\n ==   pSiteName=" + pSiteName +
		     "\n ==   pCustomerPONumber=" + pCustomerPONumber +
		     "\n ==   pAccountNum=" + pAccountNum );
		if(pReprocessingOrder){
                    return (orderDV.size() > 1);
                }else{
                    return (orderDV.size() >= 1);
                }
            } catch (SQLException exc) {
                log.error("exc.getMessage");
                exc.printStackTrace();
                throw new RemoteException
		    ("Error. duplicateOrder) SQL Exception happened. " +
		     exc.getMessage());
            }
        }

    private boolean isPipelineActive(Connection pCon, String pPipelineTypeCd)
    throws SQLException
    {
      DBCriteria dbc = new DBCriteria();
      dbc.addEqualTo(PipelineDataAccess.PIPELINE_TYPE_CD,pPipelineTypeCd);
      dbc.addEqualTo(PipelineDataAccess.PIPELINE_STATUS_CD,
                                RefCodeNames.PIPELINE_STATUS_CD.ACTIVE);
      dbc.addEqualTo(PipelineDataAccess.OPTIONAL,0);
      IdVector pipelineIds = PipelineDataAccess.selectIdOnly(pCon,dbc);
      if(pipelineIds.size()>0) return true;
      return false;
    }

    private void printOrderRefusedMesssage(OrderPipelineBaton pBaton) {
      OrderData oD = pBaton.getOrderData();
      String mess = "Order was not placed due to errors. ";
      if(oD!=null) {
        mess += "Account id: "+oD.getAccountId()+
        " Site id: "+oD.getSiteId()+ " User name: "+pBaton.getUserName()+
        " Order date: "+pBaton.getCurrentDate();
      }
      log.error("IntegrationServicesBean. "+mess);
      log.error("Order request: "+pBaton.getOrderRequestData());
      log.error("Order data: "+oD);
      log.error("Order items: "+pBaton.getOrderItemDataVector());
      log.error("Error properties: "+pBaton.getErrorsAsProperties());
    }



    class OrderRequestActor {

        OrderRequestData mOrderReq;
        CustomerOrderChangeRequestData mOrderChangeRequestData;
        OrderData mNewDbOrder;
        ProcessOrderResultData mOrderRes;
        int mExceptionsCount = 0, mDistInfoMissing = 0;
        String finalOrderStatusCd = RefCodeNames.ORDER_STATUS_CD.REJECTED;
        WorkflowRuleResult wres = null;
        LinkedList orderNotesToLog = new LinkedList();
        String acctLocale = "en_US";
        AccountData accountData = null;
        String actnum = "";

        SiteData siteData = null;
        boolean siteFound = true;
        StoreData storeData = null;
        int storeId = 0;
        String sitenum = "";
        int siteid = 0;
        String storeDir = "";
        public OrderRequestActor(OrderRequestData pOrderReq)
        throws Exception
        {
            mOrderReq = pOrderReq;
            mOrderRes = ProcessOrderResultData.createValue();
            mNewDbOrder = OrderData.createValue();
            storeDir = Utility.getStoreDir();
        }

        public OrderRequestActor(CustomerOrderChangeRequestData pOrderChangeReq)
        throws Exception{
        	mOrderChangeRequestData = pOrderChangeReq;
        	storeDir = Utility.getStoreDir();
        }







    boolean mIsAnEDIOrder = false;

    public void processOrderChangeRequest(Connection conn)
				throws RemoteException, BudgetRuleException,
				OrderTotalException, OrderWorkflowException {
			log.debug("1000a: process order: " + mOrderReq);

			try {
				// ///////////////////////////////////////////////////////////////////////////////
				APIAccess factory = getAPIAccess();
				String pipelineType = "";
				if(Utility.isSet(mOrderChangeRequestData.getOrderSource())){
					if(mOrderChangeRequestData.getOrderSource().equals("InboundCXML")){
						pipelineType = RefCodeNames.PIPELINE_CD.UPDATE_ORDER;
					}
				}else{
					pipelineType = RefCodeNames.PIPELINE_CD.SYNCH_CHANGE_ORDER;
				}

				if (isPipelineActive(conn, pipelineType)) {

					boolean uiOrder = false;
					if(!pipelineType.equals(RefCodeNames.PIPELINE_CD.UPDATE_ORDER)){
						uiOrder = true;
					}
					OrderPipelineBaton baton = new OrderPipelineBaton();
					log.info("processOrderChangeRequest processing. UiOrder: "+ uiOrder);
					baton.setCustomerOrderChangeRequestData(mOrderChangeRequestData);

					baton.setBatonNumber(0);
					OrderPipelineActor pipelineActor = new OrderPipelineActor();
					OrderPipelineBaton[] pipelineResult = pipelineActor.processPipeline(baton, pipelineType, conn, factory);

					// throw exception if budget workflow alarm
					if (uiOrder) {
						for (int ii = 0; ii < pipelineResult.length; ii++) {
							ArrayList errorAL = pipelineResult[ii].getError(OrderPipelineBaton.WORKFLOW_RULE_ALARM);
							if (errorAL == null){
								continue;
							}
							Iterator it = errorAL.iterator();
							while (it.hasNext()) {
								OrderPipelineBaton.OrderError oe = (OrderPipelineBaton.OrderError) it.next();
								if (oe != null) {
									String shortDesc = oe.shortDesc;
									if (RefCodeNames.WORKFLOW_RULE_TYPE_CD.BUDGET_REMAINING_PER_CC.equals(shortDesc)) {
										throw new BudgetRuleException(oe.text);
									}
									if (RefCodeNames.WORKFLOW_RULE_TYPE_CD.ORDER_TOTAL.equals(shortDesc)) {
										throw new OrderTotalException(oe.text);
									} else {
										throw new OrderWorkflowException(oe.text);
									}
								}
							}
						}
					}

				} else {
					throw new Exception("No order pipeline found");
				}
			} catch (Exception e) {
				throw processException(e);
			}
		}

        public ProcessOrderResultData process(Connection conn)
                                       throws RemoteException,
                                              BudgetRuleException,
                                              OrderTotalException,
                                              OrderWorkflowException {
            log.debug("1000: process order: " + mOrderReq);

            try {
/////////////////////////////////////////////////////////////////////////////////
              APIAccess factory = getAPIAccess();
              boolean ediFl =
                (mOrderReq instanceof CustomerOrderRequestData)?false:true;
              String pipelineType = (ediFl)?
                 RefCodeNames.PIPELINE_CD.SYNCH_EDI:
                 RefCodeNames.PIPELINE_CD.SYNCH_WEB;

              if(isPipelineActive(conn,pipelineType)) {
                boolean uiOrder = (mOrderReq instanceof CustomerOrderRequestData)? true:false;
                OrderPipelineBaton baton = new OrderPipelineBaton();
                baton.setOrderRequestData(mOrderReq);
                if(mOrderReq.isBypassPreCapturePipeline()) {
                  baton.setBypassOptional(true);
                } else {
                  baton.setBypassOptional(false);
                }
                baton.setBatonNumber(0);
                OrderPipelineActor pipelineActor = new OrderPipelineActor();
                OrderPipelineBaton[] pipelineResult =
                   pipelineActor.processPipeline(
                     baton,
                     pipelineType,
                     conn,
                     factory);
                ProcessOrderResultData result = ProcessOrderResultData.createValue();
                if(pipelineResult.length>0) {
                  //throw exception if budget workflow alarm
                  if(uiOrder) {
                    for(int ii=0; ii<pipelineResult.length; ii++) {
                      ArrayList errorAL =
                         pipelineResult[ii].getError(OrderPipelineBaton.WORKFLOW_RULE_ALARM);
                      if(errorAL==null) continue;
                      Iterator it = errorAL.iterator();
                      while(it.hasNext()) {
                        OrderPipelineBaton.OrderError oe =
                           (OrderPipelineBaton.OrderError) it.next();
                        if(oe!=null) {
                          String shortDesc = oe.shortDesc;
                          if(RefCodeNames.WORKFLOW_RULE_TYPE_CD.BUDGET_REMAINING_PER_CC.
                            equals(shortDesc)) {
                            throw new BudgetRuleException(oe.text);
                          }
                          if(RefCodeNames.WORKFLOW_RULE_TYPE_CD.ORDER_TOTAL.
                            equals(shortDesc)) {
                            throw new OrderTotalException(oe.text);
                          }
                          if (RefCodeNames.WORKFLOW_RULE_TYPE_CD.BUDGET_YTD.
                            equals(shortDesc)) {
                            throw new BudgetYTDRuleException("BudgetYTDRuleException:" + oe.text);
                          }
                          if (RefCodeNames.WORKFLOW_RULE_TYPE_CD.NON_ORDER_GUIDE_ITEM.equals(shortDesc)) {
                        	  	  StringBuffer errMess = new StringBuffer();
                        	  	  if  (errorAL.size() > 1){
                        	  		  ArrayList allErrors = pipelineResult[ii].getError(OrderPipelineBaton.WORKFLOW_RULE_ALARM);
                        
                        	  		  for  (int k= 0 ; k<allErrors.size(); k++ ){
                        	  			  OrderPipelineBaton.OrderError orderErr = (OrderPipelineBaton.OrderError) allErrors.get(k);
                        	  			  errMess.append("<br>");
                        	  			  errMess.append(orderErr.text);
                        	  		  }
                        	  	  } else {
                        	  		  errMess.append(oe.text);
                        	  	  }
                                  throw new OrderWorkflowException(errMess.toString());
                                }
                          else {
                            throw new OrderWorkflowException(oe.text);
                          }
                        }
                      }
                    }
                  }
                  //Process reqular result
                   OrderData orderD = baton.getOrderData();
                   log.debug( "POST PIPELINE order result:\n" + orderD);
                   if(orderD!=null) {
                     result.setSiteId(orderD.getSiteId());
                     result.setAccountId(orderD.getAccountId());
                     result.setOrderId(orderD.getOrderId());
                     result.setOrderNum(orderD.getOrderNum());
                     result.setOrderDate(orderD.getOriginalOrderDate());
                     result.setOrderStatusCd(orderD.getOrderStatusCd());
                     result.setOrderSourceCd(orderD.getOrderSourceCd());
                   }
                   if(orderD==null || orderD.getOrderId()<=0) {
                     HashMap errorHM = baton.getErrors();
                     Set keys = errorHM.keySet();
                     for(Iterator iter=keys.iterator(); iter.hasNext();) {
                         List errorMessL = (List) errorHM.get(iter.next());
                         for(Iterator iter1=errorMessL.iterator(); iter1.hasNext();) {
                            OrderPipelineBaton.OrderError errorMessOE =
                               (OrderPipelineBaton.OrderError) iter1.next();
                            result.addResponseMsg(errorMessOE.text);
                         }
                     }
                     if(keys==null || keys.isEmpty()) {
                         throw new Exception("^clw^Order Refused^clw^");
                     }
                     printOrderRefusedMesssage(baton);
                   }
                   if(orderD!=null &&
                       RefCodeNames.ORDER_STATUS_CD.PENDING_ORDER_REVIEW.
                                           equals(orderD.getOrderStatusCd())){
                       mOrderRes.addResponseMsg("The order is on hold.");
                   }
                   result.setNext(mOrderReq.getProcessOrderResultDataChain());
                }
                if(pipelineResult.length>1) {
                    //Special sumners case
                	for (int i = 1; i < pipelineResult.length; i++) {
                		OrderData orderD1 = pipelineResult[i].getOrderData();
                        String nextOrderNum = orderD1.getOrderNum();
                        result.setOrderNum(result.getOrderNum()+", "+nextOrderNum);
					}
                }
                /*if(pipelineResult.length>2) {
                  //Do not have such processing so far
                  String mess = "Something wrong with order processing. "+
                  "Order request generated  "+
                    pipelineResult.length +" orders";
                  throw new RemoteException(mess);
                }*/
                return result;
              }
              throw new Exception("No order pipeline found");

            } catch (BudgetRuleException e){
                log.error(" 5101 BudgetRuleException: " + e);
                throw e;
            } catch (OrderTotalException e){
                log.error(" 6101 OrderTotalException: " + e);
                throw e;
            } catch (BudgetYTDRuleException e) {
                log.error(" 9101 BudgetYTDRuleException: " + e);
                throw e;
            } catch (OrderWorkflowException e)            {
                log.error(" 7101 OrderWorkflowException: " + e);
                throw e;
            } catch (SQLException e) {
                e.printStackTrace();
                log.error(" 8102 queueOrderForProcessing: " + e);
                throw new RemoteException("Database error", e);
            } catch (Exception e) {
                e.printStackTrace();
                log.error(" 8101 queueOrderForProcessing: " + e);
                throw new RemoteException(e.getMessage(), e);
            }

            // mOrderRes.setNext(mOrderReq.getProcessOrderResultDataChain());
            // return mOrderRes;

        }

//***************END OrderRequestActor Class******************
    }



    /**
     * <code>processOrderRequest</code>
     *
     * @param pOrderReq a <code>CustomerOrderRequestData</code> value
     * @return a <code>ProcessOrderResultData</code> value
     * @exception RemoteException if an error occurs
     * @exception BudgetRuleException if an error occurs
     */
    public ProcessOrderResultData processOrderRequest
        (CustomerOrderRequestData pOrderReq)
        throws RemoteException,
               BudgetRuleException,
               OrderTotalException,
               OrderWorkflowException
    {

    	log.info("processOrderRequest.");
        Connection conn = null;

        try {
            conn = getConnection();
            OrderRequestActor reqact = new OrderRequestActor(pOrderReq);
            return reqact.process(conn);
        }
        catch (BudgetRuleException exc)
        {
            String m = "BudgetRuleException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderTotalException exc)
        {
            String m = "OrderTotalException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderWorkflowException exc)
        {
            String m = "OrderWorkflowException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (Exception exc)
        {
            log.error(exc);
            throw new RemoteException(exc.getMessage());
        } finally {
            closeConnection(conn);
        }
    }


    /**
     * Processes a change order request.  This will invoke the
     * pipeline processing logic that is defined for the change order
     * pipeline.
     */
    public void webProcessOrderChangeRequest
        (CustomerOrderChangeRequestData pOrderReq)
        throws RemoteException,
               BudgetRuleException,
               OrderTotalException,
               OrderWorkflowException
    {

        Connection conn = null;
        log.info("webProcessOrderChangeRequest.");
        try {
            conn = getConnection();
            OrderRequestActor reqact = new OrderRequestActor(pOrderReq);
            reqact.processOrderChangeRequest(conn);
        }
        catch (BudgetRuleException exc)
        {
            String m = "BudgetRuleException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderTotalException exc)
        {
            String m = "OrderTotalException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderWorkflowException exc)
        {
            String m = "OrderWorkflowException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (Exception exc)
        {
            log.error(exc);
            exc.printStackTrace();
            throw new RemoteException(exc.getMessage());
        } finally {
            closeConnection(conn);
        }
    }

    /**
     * Processes a change order request. NOT WEB This will invoke the
     * pipeline processing logic that is defined for the change order
     * pipeline.
     */
    private void processOrderChangeReq
        (CustomerOrderChangeRequestData pOrderReq)
        throws RemoteException,
               BudgetRuleException,
               OrderTotalException,
               OrderWorkflowException
    {

        Connection conn = null;
        log.info("processOrderChangeReq.");
        try {
            conn = getConnection();
            OrderRequestActor reqact = new OrderRequestActor(pOrderReq);
            reqact.processOrderChangeRequest(conn);


			//cancel order if all items are cancelled
			OrderData oData = OrderDataAccess.select(conn, pOrderReq.getOrderData().getOrderId());

			DBCriteria crit = new DBCriteria();
			crit.addEqualTo(OrderItemDataAccess.ORDER_ID, oData.getOrderId());
			crit.addNotEqualTo(OrderItemDataAccess.ORDER_ITEM_STATUS_CD, RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED);
			OrderItemDataVector oiDV = OrderItemDataAccess.select(conn, crit);
			if(oiDV==null || oiDV.size()==0){
				oData.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.CANCELLED);
				oData.setModBy(pOrderReq.getUserName());
				OrderDataAccess.update(conn, oData);
			}else{
				oData.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED);
				oData.setModBy(pOrderReq.getUserName());
				OrderDataAccess.update(conn, oData);
			}

        }
        catch (BudgetRuleException exc)
        {
            String m = "BudgetRuleException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderTotalException exc)
        {
            String m = "OrderTotalException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (OrderWorkflowException exc)
        {
            String m = "OrderWorkflowException: " + exc.getMessage();
            log.info(m);
            throw new RemoteException(m);
        }
        catch (Exception exc)
        {
            log.error(exc);
            exc.printStackTrace();
            throw processException(exc);
        } finally {
            closeConnection(conn);
        }
    }

    /**
     * <code>processInterchangeRequest</code>
     *
     * @param pInterchangeReqD a <code>InterchangeRequestDataVector</code> value
     * @exception RemoteException if an error occurs
     */
    private void processInterchangeRequest(InterchangeRequestData pInterchangeReqD,
                                           Connection con)
                                    throws RemoteException {

    	log.info("processInterchangeRequest.");
        try {
            // insert interchange records
            InterchangeData interchangeD = pInterchangeReqD.getInterchangeData();
            interchangeD = InterchangeDataAccess.insert(con, interchangeD);

            // insert transaction records
            ElectronicTransactionDataVector etDV =
                                      pInterchangeReqD.getTransactionDataVector();
            for (int j = 0; j<etDV.size();j++) {
                ElectronicTransactionData transactionD =
                    (ElectronicTransactionData) etDV.get(j);
                transactionD.setInterchangeId(interchangeD.getInterchangeId());
                String t = transactionD.getSetData();
                if ( t == null ) t = "";

                try {
                   // Escape non-ascii characters.
                     t = java.net.URLEncoder.encode(t, "US-ASCII");
               } catch (Exception e ) {
                   e.printStackTrace();
               }

		if (t.length() > 4000) {
		    t = t.substring(0, 3999);
		    log.info( " EDI Set data too long.  orig=" + transactionD.getSetData()+" new=" + t );
		}

		transactionD.setSetData(t);
		transactionD.setSetData("no log 1");

		// Now check the Exception string
		String t2 = transactionD.getException();
		if ( null == t2 ) t2 = "";
		if ( t2.length() > 4000 ) {
		    t2 = t2.substring(0, 3999);
		    log.info( " Exception string too long. orig=" + transactionD.getException() +"new=" + t2 );
		}
		transactionD.setException(t2);
		//transactionD.setException("no log 2");

                log.debug("transactionD=" + transactionD+ "set data length=" + t.length()+ "exception string length=" + t2.length());

                try {
                    transactionD = ElectronicTransactionDataAccess.insert(con, transactionD);
                } catch (Exception exc ) {
                    exc.printStackTrace();
                    String msg = new String("ERROR inserting transactionD=" + transactionD);
                    log.error(msg);
                }

                int transactionId = transactionD.getElectronicTransactionId();

                //details
                ArrayList details = pInterchangeReqD.getTransactionDetails(j);
                if(details!=null) {
                  for(int ii=0; ii<details.size(); ii++) {
                    Object det = details.get(ii);
                    if(det instanceof Edi997Data) {
                      Edi997Data edi997D = (Edi997Data) det;
                      edi997D.setElectronicTransactionId(transactionId);
		      log.debug( "  Edi997DataAccess.insert, edi997D=" + edi997D );
                      edi997D = Edi997DataAccess.insert(con,edi997D);
                    }
                  }
                }
            }
        } catch (Exception exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationService.processInterchangeRequest() Exception happened. " + exc.getMessage());
        }
    }

    /**
     * <code>processDataUpdate</code>
     *
     * @param pData a <code>ValueObject</code> value
     * @exception RemoteException if an error occurs
     */
    private void processDataUpdate(ValueObject pData, String pErpNum,
                                   Connection con, Map paramMap,
                                   IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds)
                            throws RemoteException {

        try {

            // update record
	    // handles all data types send to this bean
            if (pData instanceof OrderData) {
                ((OrderData)pData).setModBy("system 2");
                OrderDataAccess.update(con, (OrderData)pData);
            } else if (pData instanceof PurchaseOrderData) {
                ((PurchaseOrderData)pData).setModBy("system 3");
                PurchaseOrderDataAccess.update(con, (PurchaseOrderData)pData);
            } else if (pData instanceof OrderItemData) {
                ((OrderItemData)pData).setModBy("system 4");
                OrderItemDataAccess.update(con, (OrderItemData)pData);
            } else if (pData instanceof OrderItemActionData) {
                ((OrderItemActionData)pData).setModBy("system");
                OrderItemActionDataAccess.update(con, (OrderItemActionData)pData);
            } else if (pData instanceof InvoiceCustData || pData instanceof InvoiceAbstractionView ) {
                InvoiceCustData icd;
		if ( pData instanceof InvoiceAbstractionView ) {
		    icd = ((InvoiceAbstractionView)pData).getInvoiceCustData();
		} else {
		    icd = (InvoiceCustData)pData;
		}
                if(icd != null){
                    icd.setModBy("system 5");
                    InvoiceCustDataAccess.update(con, icd);
                }
                InvoiceDistData idd;
                if ( pData instanceof InvoiceAbstractionView ) {
		    idd = ((InvoiceAbstractionView)pData).getInvoiceDistData();
		} else {
		    idd = (InvoiceDistData)pData;
		}
                if(idd != null){
                    idd.setModBy("system 5.1");
                    InvoiceDistDataAccess.update(con, idd);
                }
            } else if ( pData instanceof InvoiceAbstractionDetailView ) {
			    if(((InvoiceAbstractionDetailView)pData).getInvoiceCustDetailData() != null){
			    	processInvoiceCustDetailData(con,((InvoiceAbstractionDetailView)pData).getInvoiceCustDetailData());
			    }else{
			    	processInvoiceDistDetailData(con,((InvoiceAbstractionDetailView)pData).getInvoiceDistDetailData());
			    }
			} else if(pData instanceof InvoiceCustDetailData){
			    processInvoiceCustDetailData(con,(InvoiceCustDetailData)pData);
			} else if(pData instanceof InvoiceDistDetailData){
				processInvoiceDistDetailData(con,(InvoiceDistDetailData) pData);

            } else if (pData instanceof RemittancePropertyData) {
                try {
                    RemittancePropertyDataAccess.insert(con,(RemittancePropertyData)pData);
                } catch (Exception e) {
                    log.debug(e.getMessage());
                    log.debug(" RemittancePropertyData: " + (RemittancePropertyData)pData);
                }
            } else if (pData instanceof RemittanceDetailData) {
                //there is a fair amount of logic that is invloved in adding
                //remittanceDetail records, so we will leave it all in one place
                getAPIAccess().getRemittanceAPI().addRemittanceDetail((RemittanceDetailData)pData,"remittance loader");
            } else if (pData instanceof RemittanceData) {
                RemittanceDataAccess.update(con, (RemittanceData)pData);
            } else if (pData instanceof OrderPropertyData) {
                OrderPropertyData opD = (OrderPropertyData) pData;
                if(opD.getOrderPropertyId()==0) {
                  OrderPropertyDataAccess.insert(con, opD);
                } else {
                  if(RefCodeNames.ORDER_PROPERTY_TYPE_CD.QUANTITY_UPDATE.
                     equals(opD.getOrderPropertyTypeCd())) {
                    OrderPropertyDataAccess.update(con, opD);
                  }
                }
            } else if (pData instanceof OrderViewData) {
                loadOrderViewData(con,(OrderViewData) pData, paramMap);
            }else if(pData instanceof ManifestItemView){
                ManifestItemView miv = (ManifestItemView) pData;
                loadManifestItemData(con, miv.getManifestItem());
            }else if(pData instanceof ManifestItemData){
                loadManifestItemData(con, (ManifestItemData) pData);
            } else if(pData instanceof PdManifestData){
                processPdManifestData((PdManifestData) pData, con, paramMap);
            } else if (pData instanceof EBagIn101View) {
                proccessEBagIn101View((EBagIn101View)pData,pStoreIds);
            } else {
                log.error("X1: requests not process for - " + pData.getClass().getName());
                log.error("X2: " + pData.toString());
		throw new RemoteException("processDataUpdate, unknown object type" + pData.getClass().getName() );

            }
        } catch (Exception exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationService.processDataUpdate() Exception happened. " +
                                      exc.getMessage());
        }
    }

    /**
     * Updates the invoice cust detail data.  Will also add order item actions if the status code is invoiced or shipped.
     * This method is most likly not used with the end of the MLA store type (Cleanwise.com).
     * @param con database connection
     * @param invoiceItemD the invoice cust detail data to be updated
     */
    private void processInvoiceCustDetailData(Connection con, InvoiceCustDetailData invoiceItemD) throws RemoteException, SQLException{
    	if (invoiceItemD.isDirty()) {
            invoiceItemD.setModBy("system 6");
            InvoiceCustDetailDataAccess.update(con, invoiceItemD);
        }
        // add the CUST_SHIPPED or CUST_INVOICED or CIT_INVOICED action
        OrderItemActionData actionD = OrderItemActionData.createValue();
        actionD.setOrderId(getOrderIdByOrderItemId(invoiceItemD.getOrderItemId(),
                                                   con));
        actionD.setOrderItemId(invoiceItemD.getOrderItemId());
        actionD.setAffectedSku("" + invoiceItemD.getItemSkuNum());

        if (RefCodeNames.INVOICE_DETAIL_STATUS_CD.CUST_INVOICED.equals(invoiceItemD.getInvoiceDetailStatusCd())) {
            actionD.setActionCd(
                    RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.CUST_INVOICED);
        } else {
            actionD.setActionCd(
                    RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.CUST_SHIPPED);
        }

        actionD.setQuantity(invoiceItemD.getItemQuantity());

        Date currentDate = new Date();
        actionD.setActionDate(currentDate);
        actionD.setActionTime(currentDate);
        actionD.setAddBy("system 7");
        OrderItemActionDataAccess.insert(con, actionD);
    }

    /**
     * Updates the invoice dist detail data.  Not complicated method just calls the data access update method right now
     * @param con database connection
     * @param invoiceItemD the invoice dist detail data to be updated
     */
    private void processInvoiceDistDetailData(Connection con, InvoiceDistDetailData invoiceItemD) throws RemoteException, SQLException{
    	if (invoiceItemD.isDirty()) {
            invoiceItemD.setModBy("system 6");
            InvoiceDistDetailDataAccess.update(con, invoiceItemD);
        }
    }

    private void proccessEBagIn101View(EBagIn101View pData, IdVector pStoreIds) throws Exception {
    	log.info("proccessEBagIn101View");
        if (pStoreIds != null && !pStoreIds.isEmpty() && pStoreIds.size() == 1) {
            EasternBagSiteLoader loader = new EasternBagSiteLoader();
            loader.process(pData, ((Integer) pStoreIds.get(0)).intValue());
        }
    }

    /**
     * Process an order guide request.  Most of the behavior is controlled with the inbound request.
     * type codes are read in directly for the object etc.
     * Originally written for the cXML punch out request, but later adapted to be more of
     * a generic way of loading order guides.
     *
     */
    private void processOrderGuideRequest(Connection con, OrderGuideLoadRequestData req,Map paramMap, IdVector pStoreIds, IdVector pAccountIds, int pTradingPartnerId)
    throws Exception{
    	int userId = req.getOrderGuide().getUserId() ;
    	log.info("processOrderGuideRequest");
    	IdVector sites = null;
    	if(Utility.isSet(req.getEntityKey())){
    		BusEntityDataVector scratchSites = getSitesFromEntityKey(req.getEntityKey(),pStoreIds,pAccountIds,pTradingPartnerId,con);
    		if(scratchSites != null){
    			sites = Utility.toIdVector(scratchSites);
    		}
    	}
    	if(sites == null){
    		sites = new IdVector();
    	}
    	if(req.getOrderGuide().getBusEntityId() != 0){
    		sites.add(new Integer(req.getOrderGuide().getBusEntityId()));
    	}

    	//do some validation
    	if(RefCodeNames.ORDER_GUIDE_TYPE_CD.SHOPPING_CART.equals(req.getOrderGuide().getOrderGuideTypeCd())){
    		if(userId == 0 || sites.size() == 0){
    			throw new RemoteException("Userid or site Id was 0 for shopping cart order guide load request");
    		}
    	}
        if(sites.isEmpty()){
        	//Error?
        	log.info("Could not find site, entity key was: " + req.getEntityKey());
        }
    	Iterator it = sites.iterator();
    	while(it.hasNext()){
    		int busEntId = ((Integer) it.next()).intValue();
    		log.info("processOrderGuideRequest.Processing site: "+busEntId);
    		//get catalog id
    		if(req.getOrderGuide().getCatalogId() == 0){
	            CatalogData catalogD = getAPIAccess().getCatalogInformationAPI().getSiteCatalog(busEntId);
	            if(catalogD == null){
	                //throw new Exception("Site is not set up for shopping, no catalog configured, or not set in orderguide loaded data");
	            	log.error("Site is not set up for shopping, no catalog configured, or not set in orderguide loaded data: "+busEntId);
	            	continue;
	            }
	            req.getOrderGuide().setCatalogId(catalogD.getCatalogId());
	        }

    		HashMap orderGuideStructureMap = new HashMap();
	        //remove old cart
	        if(RefCodeNames.ORDER_GUIDE_TYPE_CD.SHOPPING_CART.equals(req.getOrderGuide().getOrderGuideTypeCd())){
	        	ShoppingDAO.clearCart(con, req.getSite(), req.getOrderGuide().getUserId(), req.getOrderGuide().getAddBy());
	        }else{
	        	//clear, or just additive??
	        	DBCriteria crit = new DBCriteria();
	        	String type = req.getOrderGuide().getOrderGuideTypeCd();
	        	crit.addEqualTo(OrderGuideDataAccess.BUS_ENTITY_ID,busEntId);
	        	crit.addEqualTo(OrderGuideDataAccess.BUS_ENTITY_ID,busEntId);
	        	if(userId == 0){
	        		crit.addIsNull(OrderGuideDataAccess.USER_ID);
	        	}else{
	        		crit.addEqualTo(OrderGuideDataAccess.USER_ID,userId);
	        	}
	        	crit.addEqualTo(OrderGuideDataAccess.ORDER_GUIDE_TYPE_CD,type);
	        	if(Utility.isSet(req.getOrderGuide().getShortDesc())){
	        		crit.addEqualTo(OrderGuideDataAccess.SHORT_DESC,req.getOrderGuide().getShortDesc());
	        	}
	        	crit.addEqualTo(OrderGuideDataAccess.ORDER_GUIDE_TYPE_CD,type);
	        	crit.addEqualTo(OrderGuideDataAccess.CATALOG_ID,req.getOrderGuide().getCatalogId());
	        	IdVector existingOgIds = OrderGuideDataAccess.selectIdOnly(con,crit);
	        	if(existingOgIds.size() > 1){
	        		String sql = OrderGuideDataAccess.getSqlSelectIdOnly("*",crit);
	        		throw new RemoteException("multiple order guides found: "+sql);
	        	}else if(!existingOgIds.isEmpty()){
	        		//remove, or diff????
	        		//currently doing a diff
	        		int existingOgId = ((Integer)existingOgIds.get(0)).intValue();
	        		req.setOrderGuide(OrderGuideDataAccess.select(con,existingOgId));
	        		crit = new DBCriteria();
	        		crit.addEqualTo(OrderGuideStructureDataAccess.ORDER_GUIDE_ID,existingOgId);
	        		OrderGuideStructureDataVector ogsdv = OrderGuideStructureDataAccess.select(con,crit);
	        		Iterator ogsdvIt = ogsdv.iterator();
	        		while(ogsdvIt.hasNext()){
	        			OrderGuideStructureData ogsd = (OrderGuideStructureData) ogsdvIt.next();
	        			orderGuideStructureMap.put(new Integer(ogsd.getItemId()),ogsd);
	        		}
	        	}
	        }


	        OrderGuideData og = req.getOrderGuide();
	        if(og.getOrderGuideId() == 0){
	        	if(
                RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE.equals(og.getOrderGuideTypeCd())
                ||
                RefCodeNames.ORDER_GUIDE_TYPE_CD.BUYER_ORDER_GUIDE.equals(og.getOrderGuideTypeCd())
                ){
	        		og.setBusEntityId(busEntId);
	        	}
	        	og = OrderGuideDataAccess.insert(con,og);
	        	req.setOrderGuide(og);
	        }

	        Iterator itmIt = req.getItems().iterator();
	        while(itmIt.hasNext()){
	            OrderGuideLoadRequestData.OrderGuideItemLoadRequestData itm =
	                (OrderGuideLoadRequestData.OrderGuideItemLoadRequestData) itmIt.next();
	            int itemId = ItemSkuMapping.mapToItemId(con, itm.getSku(), null, req.getSkuTypeCd(), og.getCatalogId(), true,null,true);
	            if(itemId == 0){
	            	//for now just log an error!
	            	log.error("Could not find item mapping for sku: "+itm.getSku()+" and sku type: "+req.getSkuTypeCd());
	            	continue;
	            }
	            OrderGuideStructureData ogs = (OrderGuideStructureData) orderGuideStructureMap.get(new Integer(itemId));
	            if(ogs == null){
	            	//nothing existing, so do an insert
	            	ogs = OrderGuideStructureData.createValue();
	            	ogs.setAddBy("System");
	            	ogs.setItemId(itemId);
	            	ogs.setOrderGuideId(og.getOrderGuideId());
	            	ogs.setQuantity(itm.getQty());
	            	OrderGuideStructureDataAccess.insert(con, ogs);
	            }else if(ogs.getQuantity() != itm.getQty()){
	            	//for updates only need to worry about quantity
	            	ogs.setModBy("System");
	            	ogs.setQuantity(itm.getQty());
	            	OrderGuideStructureDataAccess.update(con, ogs);
	            }
	        }
    	}
    }

    /**
     *Loads a manifest item data object.  If the object has a manifest item id it is simply updated,
     *otherwise an attempt is made to find the manifest item in the db based off the package id and then
     *package confirmation id, if found an update will be made, if not it will be added to the database.
     */
    private void loadManifestItemData(Connection pCon,ManifestItemData pManifestItemData)
    throws Exception{
        if(pManifestItemData.getManifestItemId() > 0){
            ManifestItemDataAccess.update(pCon,pManifestItemData);
            return;
        }
        DBCriteria crit = new DBCriteria();
        crit.addEqualTo(ManifestItemDataAccess.PACKAGE_ID,pManifestItemData.getPackageId());
        ManifestItemDataVector midv = ManifestItemDataAccess.select(pCon,crit);
        if(midv.size() == 0){
            crit = new DBCriteria();
            crit.addEqualTo(ManifestItemDataAccess.PACKAGE_CONFIRM_ID,pManifestItemData.getPackageConfirmId());
            midv = ManifestItemDataAccess.select(pCon,crit);
        }

        if(midv.size() == 0){
            //insert it
            if(pManifestItemData.getManifestItemStatusCd().equals(RefCodeNames.MANIFEST_ITEM_STATUS_CD.RECONCILED_FREIGHT_HANDLER)){
                pManifestItemData.setManifestItemStatusCd(RefCodeNames.MANIFEST_ITEM_STATUS_CD.RECONCILED_FREIGHT_HANDLER_ERR);
            }
            //find the po number to associate it with
            int packLen = pManifestItemData.getPackageId().length();
            String lPo;
            if(packLen <= 6){
                lPo = pManifestItemData.getPackageId();
            }else{
                lPo = pManifestItemData.getPackageId().substring(0,6);
            }
            crit = new DBCriteria();
            crit.addEqualTo(PurchaseOrderDataAccess.ERP_PO_NUM,lPo);
            PurchaseOrderDataVector podv = PurchaseOrderDataAccess.select(pCon,crit);
            if(podv.size() > 0){
                pManifestItemData.setPurchaseOrderId(((PurchaseOrderData)podv.get(0)).getPurchaseOrderId());
            }
            if(pManifestItemData.getAddBy() == null){
                pManifestItemData.setAddBy("System");
            }
            log.debug(pManifestItemData);
            ManifestItemDataAccess.insert(pCon, pManifestItemData);
        }else if(midv.size() == 1){
            //update it
            ManifestItemData existing = (ManifestItemData) midv.get(0);
            pManifestItemData.setManifestItemId(existing.getManifestItemId());
            pManifestItemData.setModBy("System");
            ManifestItemDataAccess.update(pCon, pManifestItemData);
        }else{
            //update to error state
            Iterator it = midv.iterator();
            while(it.hasNext()){
                ManifestItemData existing = (ManifestItemData) it.next();
                existing.setManifestItemStatusCd(RefCodeNames.MANIFEST_ITEM_STATUS_CD.RECONCILED_FREIGHT_HANDLER_ERR);
                existing.setModBy("System");
                ManifestItemDataAccess.update(pCon, existing);
            }
        }
    }

    //finds an order based off joining the property data to the order number
    //This is used if an order number itself is not sufficient to determine a
    //unique order as in the case of JWP
    //@returns the orderId if it is found, returns 0 if none could be found
    private int findUniqueOrder(Connection pCon,Map paramMap, String pOrderNumber,OrderPropertyDataVector uniqueKeys)
    throws SQLException
    {
        //maintain a key for each unique set of criteria
        StringBuffer key = new StringBuffer("findUniqueOrder");
        for(int i=0,len=uniqueKeys.size();i<len;i++){
            OrderPropertyData opd = (OrderPropertyData) uniqueKeys.get(i);
            key.append(opd.getOrderPropertyTypeCd());
        }
        PreparedStatement selectStatment = (PreparedStatement) paramMap.get(key.toString());
        if(selectStatment==null){
            log.debug("Creating new statment");
            StringBuffer sql = new StringBuffer();
            sql.append("SELECT DISTINCT " + OrderDataAccess.CLW_ORDER+"."+OrderDataAccess.ORDER_ID + " FROM ");
            for(int i=0,len=uniqueKeys.size();i<len;i++){
                sql.append(OrderPropertyDataAccess.CLW_ORDER_PROPERTY + " prop"+i+",");
            }
            sql.append(OrderDataAccess.CLW_ORDER);
            sql.append(" WHERE ");
            for(int i=0,len=uniqueKeys.size();i<len;i++){
                sql.append(OrderDataAccess.CLW_ORDER + "." + OrderDataAccess.ORDER_ID+"=prop"+i+ "." + OrderPropertyDataAccess.ORDER_ID + " AND ");
            }
            sql.append(OrderDataAccess.CLW_ORDER + "." + OrderDataAccess.ORDER_NUM+"=?");
            for(int i=0,len=uniqueKeys.size();i<len;i++){
                sql.append(" AND " + "prop"+i+"."+OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD+"=?");
                sql.append(" AND " + "prop"+i+"."+OrderPropertyDataAccess.CLW_VALUE+"=?");
                sql.append(" AND " + "prop"+i+"."+OrderPropertyDataAccess.ORDER_PROPERTY_STATUS_CD+"=?");
            }
            log.debug("findUniqueOrder SQL::"+sql);
            selectStatment = pCon.prepareStatement(sql.toString());
            paramMap.put(key.toString(),selectStatment);
        }
        //Statement s = pCon.createStatement();
        ArrayList params = new ArrayList();
        key.append(pOrderNumber);
        params.add(pOrderNumber);
        for(int i=0,len=uniqueKeys.size();i<len;i++){
            OrderPropertyData opd = (OrderPropertyData) uniqueKeys.get(i);
            key.append(opd.getOrderPropertyTypeCd());
            params.add(opd.getOrderPropertyTypeCd());
            key.append(opd.getValue());
            params.add(opd.getValue());
            params.add(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
        }

        Integer cachedOrderId = (Integer) paramMap.get(key.toString());
        if(cachedOrderId == null){
            for(int i=0,len=params.size();i<len;i++){
                log.debug("Setting param: " + i + 1 + " to: " + params.get(i));
                selectStatment.setString(i + 1,(String) params.get(i));
            }
            ResultSet rs = selectStatment.executeQuery();
            if(rs.next()){
                cachedOrderId = new Integer(rs.getInt(1));
                paramMap.put(key.toString(), cachedOrderId);
            }else{
                cachedOrderId = new Integer(0);
            }
        }
        return cachedOrderId.intValue();
    }

    /**
     *Loads an order view data object.  Note that the uniqueKey gets added to the
     *database so it should not be added to the orderPropertyDataVector
     */
    private void loadOrderViewData(Connection pCon, OrderViewData pOrderViewData,Map params)
    throws SQLException{

        if(pOrderViewData.getOrderPropertyDataVector() == null){
            pOrderViewData.setOrderPropertyDataVector(new OrderPropertyDataVector());
        }
        if(pOrderViewData.getUniqueKeyOrderPropertyData() == null){
            pOrderViewData.setUniqueKeyOrderPropertyData(new OrderPropertyDataVector());
        }
        if(pOrderViewData.getOrderItems() == null){
            pOrderViewData.setOrderItems(new OrderItemDataVector());
        }
        int orderId = findUniqueOrder(pCon,params,pOrderViewData.getOrderNumber(),pOrderViewData.getUniqueKeyOrderPropertyData());
        boolean doingUpdate = false;
        if(orderId > 0){
            doingUpdate = true;
        }

        //load the order
        if (pOrderViewData.getOrder() != null){
            OrderData orderData = pOrderViewData.getOrder();
            orderData.setModBy("System 7");
            if(doingUpdate){
                OrderData origOrder;
                try{
                    origOrder = OrderDataAccess.select(pCon,orderId);
                }catch(DataNotFoundException e){
                    //this should really really never happen
                    orderData.setAddBy("System 7");
                    origOrder = OrderDataAccess.insert(pCon,orderData);
                }
                orderData.setAddBy(origOrder.getAddBy());
                orderData.setOrderId(origOrder.getOrderId());

                OrderDataAccess.update(pCon, orderData);
            }else{
                orderData.setAddBy("System 7");

                orderData = OrderDataAccess.insert(pCon, orderData);
            }
            pOrderViewData.setOrder(orderData);
            orderId = orderData.getOrderId();
        }

        //now load the order property data
        if(orderId > 0){
            OrderPropertyDataVector existingProps = null;
            if(pOrderViewData.getOrderPropertyDataVector().addAll(pOrderViewData.getUniqueKeyOrderPropertyData()));
            if(doingUpdate && pOrderViewData.getOrderPropertyDataVector().size() > 0){
                DBCriteria crit = new DBCriteria();
                crit.addEqualTo(OrderPropertyDataAccess.ORDER_ID,orderId);
                crit.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_STATUS_CD,RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                crit.addIsNull(OrderPropertyDataAccess.ORDER_ITEM_ID);
                crit.addIsNull(OrderPropertyDataAccess.INVOICE_CUST_DETAIL_ID);
                crit.addIsNull(OrderPropertyDataAccess.INVOICE_CUST_ID);
                crit.addIsNull(OrderPropertyDataAccess.INVOICE_DIST_DETAIL_ID);
                crit.addIsNull(OrderPropertyDataAccess.INVOICE_DIST_ID);
                existingProps = OrderPropertyDataAccess.select(pCon,crit);
            }
            for(int i=0;i<pOrderViewData.getOrderPropertyDataVector().size();i++){
                OrderPropertyData opd = (OrderPropertyData) pOrderViewData.getOrderPropertyDataVector().get(i);
                opd.setOrderId(orderId);
                opd.setModBy("System 7");
                if(!doingUpdate){
                    opd.setAddBy("System 7");
                    OrderPropertyDataAccess.insert(pCon, opd);
                }else{
                    for(int j=0;j<existingProps.size();j++){
                        OrderPropertyData origOpd = (OrderPropertyData) existingProps.get(j);
                        if (origOpd.getOrderPropertyTypeCd().equals(opd.getOrderPropertyTypeCd())){
                            opd.setAddBy(origOpd.getAddBy());
                            opd.setOrderPropertyId(origOpd.getOrderPropertyId());
                        }
                    }
                }
            }

            //load the singleton orderItemData (just add it to the vector of order items
            //as it makes things simpler)
            if(pOrderViewData.getOrderItem() != null){
                pOrderViewData.getOrderItems().add(pOrderViewData.getOrderItem());
            }

            //now load the order items
            for(int i=0,len=pOrderViewData.getOrderItems().size();i<len;i++){
                OrderItemData oid = (OrderItemData)pOrderViewData.getOrderItems().get(i);
                oid.setOrderId(orderId);
                oid.setModBy("System7");
                populateOrderItemForLoad(pCon,oid);
                DBCriteria crit = new DBCriteria();
                crit.addEqualTo(OrderItemDataAccess.ORDER_ID,orderId);
                crit.addEqualTo(OrderItemDataAccess.ITEM_SKU_NUM,oid.getItemSkuNum());
                OrderItemDataVector oidv = OrderItemDataAccess.select(pCon,crit);
                if (oidv.size() > 0){
                    if (oidv.size() > 1){
                        //log an error, but continue
                        log.error("Multiple records found for sku: " + oid.getItemSkuNum() + " and orderId " + orderId);
                    }
                    OrderItemData dbOi = (OrderItemData) oidv.get(0);
                    oid.setAddBy(dbOi.getAddBy());
                    oid.setOrderItemId(dbOi.getOrderItemId());
                    OrderItemDataAccess.update(pCon, oid);
                }else{
                    oid.setAddBy("System7");
                    oid = OrderItemDataAccess.insert(pCon, oid);
                }
            }
        }else{//end orderId > 0
            //log an error, not much we can do if we can't find the order.
            log.error("Could not determine order id!");
        }
    }

    private CacheManager mCacheManager = new CacheManager(this.getClass().getName());


    // This function is called for each item in an
    // order.  The function makes use of the mCacheManager
    // to speed up distributor lookups.
    //
    private void populateOrderItemForLoad(Connection pCon, OrderItemData pOrderItemData)
    throws SQLException{
        DBCriteria crit = new DBCriteria();
        crit.addEqualTo(ItemDataAccess.SKU_NUM,pOrderItemData.getItemSkuNum());
        crit.addEqualTo(ItemDataAccess.ITEM_TYPE_CD,RefCodeNames.ITEM_TYPE_CD.PRODUCT);
        ItemDataVector idv = ItemDataAccess.select(pCon,crit);
        if (idv.size() != 0){
            //find items
            ItemData itm = null;
            if (idv.size() > 1){
                for(int i=0,len=idv.size();i<len;i++){
                    ItemData tmpItm = (ItemData) idv.get(i);
                    if(tmpItm.getItemStatusCd().equals(RefCodeNames.ITEM_STATUS_CD.ACTIVE)){
                        itm = tmpItm;
                        break;
                    }
                }
                if(itm==null){
                    itm = (ItemData) idv.get(0);
                    log.error("Multiple Unavaliable items found, using itm=" + itm);
                }
            }else{
                itm = (ItemData) idv.get(0);
            }

	    ProductDAO pdao = mCacheManager.getProductDAO();
	    pdao.lookupItem(pCon,itm.getItemId());
            ProductDataVector pdv = pdao.getResultVector();
            ProductData prod = null;
            if(pdv == null || pdv.size() != 0){
                prod = (ProductData) pdv.get(0);
            }else{
                prod = new ProductData();
            }
            //skipping customer info, we could set this if necessary
            pOrderItemData.setExceptionInd("N");
            pOrderItemData.setItemId(itm.getItemId());
            pOrderItemData.setItemShortDesc(itm.getShortDesc());
            pOrderItemData.setItemPack(prod.getPack());
            pOrderItemData.setItemSize(prod.getSize());
            pOrderItemData.setItemUom(prod.getUom());
            pOrderItemData.setManuItemMsrp(new BigDecimal(prod.getListPrice()));
            pOrderItemData.setManuItemShortDesc(prod.getManuMapping().getShortDesc());
            pOrderItemData.setManuItemSkuNum(prod.getManuMapping().getItemNum());
            pOrderItemData.setManuPackUpcNum(prod.getPkgUpc());
        }else{
            //leave everything null
        }
    }

     /**
     *Does the work of actually processing the integration request.
     *Delegates most of the loading to helper methods
     */
    private boolean processIntegrationRequest(Object pRequestD,
                                           Connection conn, Map paramMap, String pErpNum,
                                           IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds,
                                           int pTradingPartnerId,
                                           Map<String, List<EdiInp856View>> pDistEdi856ByErrorMessage)
    throws Exception{
        boolean result = true;
        if (pRequestD instanceof InterchangeRequestData) {
            processInterchangeRequest(
                    (InterchangeRequestData)pRequestD, conn);
        } else if (pRequestD instanceof OrderRequestData) {
        	OrderRequestData orderReq = (OrderRequestData) pRequestD;
            createOrder850Event(orderReq);
        } else if (pRequestD instanceof InboundEventData) {
        	InboundEventData inEventData = (InboundEventData)pRequestD;

//        	EventData eventData = new EventData(0, inEventData.getStatus(),
//                  Event.TYPE_PROCESS, null, null, 1);
        	Event eventEjb = APIAccess.getAPIAccess().getEventAPI();
//        	eventData = eventEjb.addEventToDB(eventData);
        	ProcessData process = APIAccess.getAPIAccess().getProcessAPI()
                  .getProcessByName(RefCodeNames.PROCESS_NAMES.PROCESS_INBOUND_TRANSACTION);
//        	eventEjb.addProperty(eventData.getEventId(), "process_id",
//                  Event.PROPERTY_PROCESS_TEMPLATE_ID, new Integer(process.getProcessId()), 1);
//        	eventEjb.addProperty(eventData.getEventId(), "dataContents",
//					Event.PROCESS_VARIABLE, inEventData.getByteArray(), 2);
//			eventEjb.addProperty(eventData.getEventId(), "fileName",
//					Event.PROCESS_VARIABLE, inEventData.getFileName(), 3);
//			eventEjb.addProperty(eventData.getEventId(), "partnerKey",
//					Event.PROCESS_VARIABLE, inEventData.getPartnerKey(), 4);
            EventData eventData = Utility.createEventDataForProcess();
            eventData.setStatus(inEventData.getStatus());
            EventProcessView epv = new EventProcessView(eventData, new EventPropertyDataVector(), inEventData.getParentEventId());
            epv.getProperties().add(Utility.createEventPropertyData("process_id",
                    Event.PROPERTY_PROCESS_TEMPLATE_ID, new Integer(process.getProcessId()), 1));
            epv.getProperties().add(Utility.createEventPropertyData("dataContents",
                    Event.PROCESS_VARIABLE, inEventData.getByteArray(), 2));
            epv.getProperties().add(Utility.createEventPropertyData("fileName",
                    Event.PROCESS_VARIABLE, inEventData.getFileName(), 3));
            epv.getProperties().add(Utility.createEventPropertyData("partnerKey",
                    Event.PROCESS_VARIABLE, inEventData.getPartnerKey(), 4));
            eventEjb.addEventProcess(epv, "IntegrationServicesBean");
        } else if (pRequestD instanceof OutboundEventData) {
        	OutboundEventData outEventData = (OutboundEventData)pRequestD;
        	String mode = (String) outEventData.getSendParameterMap().get("ftpmode");
        	int parentEventId = outEventData.getParentEventId();
        	
        	if(mode != null && (mode.equals("email-attachment") || mode.equals("email-inline"))){
        		Event eventEjb = APIAccess.getAPIAccess().getEventAPI();
        		EventEmailDataView em = new EventEmailDataView();
        		em.setEmailStatusCd(Event.STATUS_READY);
        		if(mode.equals("email-attachment")){
        			String type = (String) outEventData.getSendParameterMap().get("email-attachment-type");
        			if(!Utility.isSet(type)){
        				type="application/octet-stream";
        			}
	        		FileAttach at = new FileAttach(outEventData.getFileName(),outEventData.getByteArray(),
	        				type,outEventData.getByteArray().length);
	        		FileAttach[] ats = new FileAttach[1];
	        		ats[0] = at;
	        		em.setAttachments(ats);
	        		String text = (String) outEventData.getSendParameterMap().get("emailtext");
	        		em.setText(text);
        		}else if(mode.equals("email-inline")){
        			em.setText(new String(outEventData.getByteArray()));
        		}else{
        			//this is an error
        			throw new RemoteException("Mode specified ("+mode+") unknown");
        		}
        		String from = (String) outEventData.getSendParameterMap().get("emailfrom");
        		em.setFromAddress(from);
        		String subject = (String) outEventData.getSendParameterMap().get("emailsubject");
        		em.setSubject(subject);

        		String to = (String) outEventData.getSendParameterMap().get("emailto");
        		if(to == null){
        			to = (String) outEventData.getSendParameterMap().get("tohost");
        		}
        		em.setToAddress(to);

        		eventEjb.addEventEmail(em, parentEventId);
        	}else{
	        	Event eventEjb = APIAccess.getAPIAccess().getEventAPI();
	        	ProcessData process = APIAccess.getAPIAccess().getProcessAPI()
	                  .getProcessByName(RefCodeNames.PROCESS_NAMES.PROCESS_OUTBOUND_TRANSACTION);
	        	EventProcessView epv = null;
	        	if (parentEventId > 0){
	        		EventData eventData = Utility.createEventDataForProcess();
	        		epv = new EventProcessView(eventData, new EventPropertyDataVector(), parentEventId);
	        		epv.getProperties().add(Utility.createEventPropertyData("process_id",
	                        Event.PROPERTY_PROCESS_TEMPLATE_ID, new Integer(process.getProcessId()), 1));
	                
	        	}else{
	        		int priorityOverride = 0;
	                int subProcessPriority = 0;
	                String priorityOverrideStr = (String) outEventData.getSendParameterMap().get(Event.PRIORITY_OVERRIDE);
	                if (Utility.isSet(priorityOverrideStr)){
	                	priorityOverride = new Integer(priorityOverrideStr).intValue();
	                }
	                priorityOverrideStr = (String) outEventData.getSendParameterMap().get(Event.SUBPROCESS_PRIORITY);
	                if (Utility.isSet(priorityOverrideStr)){
	              	  subProcessPriority = new Integer(priorityOverrideStr).intValue();
	                }
	                epv = Utility.createEventProcessView(process.getProcessId(), priorityOverride, subProcessPriority);
	        	}
                
                epv.getProperties().add(Utility.createEventPropertyData("fileName",
                        Event.PROCESS_VARIABLE, outEventData.getFileName(), 2));
                epv.getProperties().add(Utility.createEventPropertyData("partnerKey",
                        Event.PROCESS_VARIABLE, outEventData.getPartnerKey(), 3));
                epv.getProperties().add(Utility.createEventPropertyData("setType",
                        Event.PROCESS_VARIABLE, outEventData.getSetType(), 4));
                epv.getProperties().add(Utility.createEventPropertyData("dataContents",
                        Event.PROCESS_VARIABLE, outEventData.getByteArray(), 5));
                epv.getProperties().add(Utility.createEventPropertyData("sendParameterMap",
                        Event.PROCESS_VARIABLE, outEventData.getSendParameterMap(), 6));
                eventEjb.addEventProcess(epv, "IntegrationServicesBean");

                if (outEventData.getSetType().equals(RefCodeNames.EDI_TYPE_CD.T850)){
                	for (ValueObject object : outEventData.getEventRelatedData()){
                		OutboundEDIRequestData reqData = (OutboundEDIRequestData) object;
                		if (reqData.getOrderD() != null){
                			OrderPropertyData prop = OrderPropertyData.createValue();
                	        prop.setOrderId(reqData.getOrderD().getOrderId());
                	        prop.setAddBy("IntegrationServicesBean");
                	        prop.setModBy("IntegrationServicesBean");
                	        prop.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                	        prop.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.EVENT_ID_OF_SEND_PROCESS);
                	        prop.setShortDesc(RefCodeNames.ORDER_PROPERTY_TYPE_CD.EVENT_ID_OF_SEND_PROCESS);
                	        prop.setValue(epv.getEventData().getEventId()+"");
                			processDataUpdate(prop, pErpNum, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds);
                		}
                	}
                }
        	}
      } else if (pRequestD instanceof Ack997Data) {
            process997Acknowledge((Ack997Data)pRequestD, conn);
        } else if (pRequestD instanceof InvoiceRequestData) {
        	InvoiceRequestData invoiceRD = (InvoiceRequestData)pRequestD;
            Event eventEjb=APIAccess.getAPIAccess().getEventAPI();
            ProcessData process = APIAccess.getAPIAccess().getProcessAPI()
            .getProcessByName(RefCodeNames.PROCESS_NAMES.INVOICE_PROCESS);

            EventData eventData = Utility.createEventDataForProcess();
            EventProcessView epv = new EventProcessView(eventData, new EventPropertyDataVector(), invoiceRD.getParentEventId());
            epv.getProperties().add(Utility.createEventPropertyData("process_id",
                  Event.PROPERTY_PROCESS_TEMPLATE_ID, new Integer(process.getProcessId()), 1));
            epv.getProperties().add(Utility.createEventPropertyData("process_id",Event.PROPERTY_PROCESS_TEMPLATE_ID,new Integer(process
                    .getProcessId()),1));
            epv.getProperties().add(Utility.createEventPropertyData("partner",Event.PROCESS_VARIABLE,new Integer(pTradingPartnerId),2));
            epv.getProperties().add(Utility.createEventPropertyData("processName",Event.PROCESS_VARIABLE,"InvoiceRequest",3));
            epv.getProperties().add(Utility.createEventPropertyData("invoice",Event.PROCESS_VARIABLE,pRequestD,1));
            eventEjb.addEventProcess(epv, "IntegrationServicesBean");
        } else if (pRequestD instanceof AcknowledgeRequestData) {
            processAcknowledgeRequest(
                    (AcknowledgeRequestData)pRequestD, conn, paramMap, pTradingPartnerId,pStoreIds, pAccountIds, pDistributorIds);
        } else if (pRequestD instanceof UserInfoData) {
            processUserRequest((UserInfoData)pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds);
        }else if (pRequestD instanceof UserAssocRequestData){
            processUserAssocRequest((UserAssocRequestData) pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds);
        }else if (pRequestD instanceof SiteDataUpdateRequest){
            processSiteDataUpdateRequest((SiteDataUpdateRequest) pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds, pTradingPartnerId);
        }else if (pRequestD instanceof BudgetDefinitionRequest){
            processBudgetDefinitionRequest((BudgetDefinitionRequest)pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds, pTradingPartnerId);
        }else if (pRequestD instanceof BackorderLoaderRequest){
            processBackorderLoaderRequest((BackorderLoaderRequest)pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds, pTradingPartnerId);
        }else if (pRequestD instanceof ParLoaderRequest){
            processParLoaderRequest((ParLoaderRequest)pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds, pTradingPartnerId);
        }else if (pRequestD instanceof ParDefinitionRequest){
            processParDefinitionRequest((ParDefinitionRequest)pRequestD, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds, pTradingPartnerId);
        }else if (pRequestD instanceof EdiInp856View) {
            EdiInp856View inp856Req = (EdiInp856View) pRequestD;
            result = processInboundDistributorEdi856(inp856Req, conn, pStoreIds,pDistributorIds, pTradingPartnerId, paramMap,
                    pDistEdi856ByErrorMessage);
        } else if (pRequestD instanceof JDChinaFileLoaderView) {
            processJDChinaFileLoadRequest((JDChinaFileLoaderView)pRequestD, conn);
        } else if (pRequestD instanceof TransRebateApprovedView) {
            processTransRebateApprovedRequest((TransRebateApprovedView)pRequestD);
        } else if (pRequestD instanceof TransRebateProcessedView) {
            processTransRebateProcessedRequest((TransRebateProcessedView)pRequestD);
        }else if(pRequestD instanceof OrderGuideLoadRequestData){
            processOrderGuideRequest(conn,(OrderGuideLoadRequestData) pRequestD,paramMap,pStoreIds, pAccountIds, pTradingPartnerId);
        }else if(pRequestD instanceof CustomerOrderChangeRequestData){
        	processOrderChangeReq((CustomerOrderChangeRequestData)pRequestD);
        } else {
            processDataUpdate((ValueObject)pRequestD, pErpNum, conn, paramMap, pStoreIds, pAccountIds, pDistributorIds);
        }
        return result;
    }

	private void createOrder850Event(OrderRequestData orderReq) throws Exception {
		Event eventEjb = APIAccess.getAPIAccess().getEventAPI();
		ProcessData process = APIAccess.getAPIAccess().getProcessAPI()
		        .getProcessByName(RefCodeNames.PROCESS_NAMES.PROCESS_ORDER_850);
		EventData eventData = Utility.createEventDataForProcess();
		EventProcessView epv = new EventProcessView(eventData, new EventPropertyDataVector(), orderReq.getParentEventId());
		epv.getProperties().add(Utility.createEventPropertyData("process_id",
		        Event.PROPERTY_PROCESS_TEMPLATE_ID, new Integer(process.getProcessId()), 1));
		epv.getProperties().add(Utility.createEventPropertyData("invoice",
		        Event.PROCESS_VARIABLE, orderReq, 1));
		eventEjb.addEventProcess(epv, "IntegrationServicesBean");
	}
	
	public void createOrder850Events(OrderRequestDataVector orderReqs) throws Exception {
		for (int i = 0; i <  orderReqs.size(); i++){
			OrderRequestData orderReq = (OrderRequestData) orderReqs.get(i);
			createOrder850Event(orderReq);
		}		
	}

    private void processTransRebateApprovedRequest(
			TransRebateApprovedView requestD) throws RemoteException {
    	Connection conn = null;
    	try {
    		conn = getJDIntegrationConnection();
			Statement stmt = conn.createStatement();
			stmt.executeUpdate("UPDATE PRI_TRANS_REBATE_APPROVED SET  CONNECTION_STATUS = '" + requestD.getConnectionStatus() + "', MODIFIED_DATE = SYSDATE WHERE TRANS_REBATE_APPROVED_ID = " + requestD.getTransRebateApprovedId());
            stmt.close();
		}catch (Exception e){
            throw new RemoteException(e.getMessage());
        }finally{
        	closeConnection(conn);
        }
	}

    private void processTransRebateProcessedRequest(
    		TransRebateProcessedView requestD) throws RemoteException {
    	Connection conn = null;
    	String selectSql = "SELECT TRANS_REBATE_PROCESSED_ID FROM PRI_TRANS_REBATE_PROCESSED WHERE REBATE_NUMBER=? " +
    			"AND CONTRACT_NUMBER=? AND PRODUCT_SKU=?";
    	String insertSql = "Insert into PRI_TRANS_REBATE_PROCESSED (REBATE_NUMBER,CONTRACT_NUMBER,CONTRACT_DESC," +
    			"PRODUCT_SKU,PRODUCT_DESC,QUANTITY,UOM,REBATE_PAID,PAYMENT_METHOD,CONNECTION_STATUS,CUSTOMER_REF_NUMBER," +
    			"INVOICE_NUMBER,CREATED_DATE,MODIFIED_DATE) " +
    			"values (?,?,?,?,?,?,?,?,?,?,?,?,sysdate,sysdate)";
    	try {
    		conn = getJDIntegrationConnection();
    		PreparedStatement pstmt = conn.prepareStatement(selectSql);
    		pstmt.setString(1, requestD.getRebateNumber());
			pstmt.setString(2, requestD.getContractNumber());
			pstmt.setString(3, requestD.getProductSku());
			ResultSet rs = pstmt.executeQuery();
			boolean duplicated = false;
			if (rs.next()){
				duplicated = true;
				log.error("Rebate item already processed for RebateNum="+requestD.getRebateNumber()
						+ ", ContractNum=" + requestD.getContractNumber()
						+ ", SkuNum=" + requestD.getProductSku());
			}

			pstmt = conn.prepareStatement(insertSql);
			pstmt.setString(1, requestD.getRebateNumber());
			pstmt.setString(2, requestD.getContractNumber());
			pstmt.setString(3, requestD.getContractDesc());
			pstmt.setString(4, requestD.getProductSku());
			pstmt.setString(5, requestD.getProductDesc());
			pstmt.setString(6, requestD.getQuantity());
			pstmt.setString(7, requestD.getUom());
			pstmt.setBigDecimal(8, requestD.getRebatePaid());
			pstmt.setString(9, requestD.getPaymentMethod());
			if (duplicated)
				pstmt.setString(10, "DUPLICATE");
			else
				pstmt.setString(10, "PENDING");
			pstmt.setString(11, requestD.getCustomerRefNumber());
			pstmt.setString(12, requestD.getInvoiceNumber());
			pstmt.executeUpdate();
            pstmt.close();
		}catch (Exception e){
            throw new RemoteException(e.getMessage());
        }finally{
        	closeConnection(conn);
        }
	}

	private static void processJDChinaFileLoadRequest(JDChinaFileLoaderView requestD, Connection conn) throws Exception {
    	Connection connection = null;
    	boolean differentConn = false;
    	boolean priceData = requestD.getFileName().toUpperCase().indexOf("PRICE") >= 0;
    	boolean itemData = requestD.getFileName().toUpperCase().indexOf("PRODUCT") >= 0;
    	boolean customerData = requestD.getFileName().toUpperCase().indexOf("CUSTOMER") >= 0;
    	boolean contractData = requestD.getFileName().toUpperCase().indexOf("CONTRACT") >= 0;

		if (Utility.isSet(requestD.getDbUrl())){
			differentConn = true;
			try{
	            Class.forName("oracle.jdbc.driver.OracleDriver");
	        }catch (ClassNotFoundException e){
	            throw new SQLException("Could not load oracle driver! (class oracle.jdbc.driver.OracleDriver not found) " + e.getMessage());
	        }
	        connection = DriverManager.getConnection(requestD.getDbUrl(), requestD.getDbUser(), requestD.getDbPassword());
	        connection.setAutoCommit(false);

		}else{
			connection = conn;
		}

		try {
			Statement stmt = connection.createStatement();
	        ResultSet rs = stmt.executeQuery("SELECT PRI_DATA_RECEIVED_SEQ.NEXTVAL FROM DUAL");
	        rs.next();
	        int keyId = rs.getInt(1);
	        rs.close();
	        stmt.close();

	        String insertSql = "INSERT INTO PRI_DATA_RECEIVED (DATA_RECEIVED_ID, PRICE_LOADER_FILE, STATUS_CODE, CREATED_DATE, MODIFIED_DATE, FILE_NAME, FILE_TYPE) " +
			"VALUES (?, ?, 'unprocessed', SYSDATE, SYSDATE, ?, ?)";

			PreparedStatement pstmt = connection.prepareStatement(insertSql);
		    pstmt.setInt(1, keyId);
		    pstmt.setBlob(2, BLOB.empty_lob());
		    pstmt.setString(3, requestD.getFileName());
		    if (priceData){
		    	pstmt.setString(4, "Price");
		    }else if (itemData){
		    	pstmt.setString(4, "ItemXML");
		    }else if (customerData){
		    	pstmt.setString(4, "CustomerXML");
		    }else if (contractData){
		    	pstmt.setString(4, "Contract");
		    }else{
		    	pstmt.setString(4, "UNKNOWN");
		    }
	        pstmt.executeUpdate();
	        pstmt.close();

			String selectBlobSql = "select PRICE_LOADER_FILE from PRI_DATA_RECEIVED " +
	                " where DATA_RECEIVED_ID = ? for update ";

	        pstmt = connection.prepareStatement(selectBlobSql);
	        pstmt.setInt(1, keyId);

	        rs = pstmt.executeQuery();
	        rs.next();
	        BLOB blob = (BLOB) rs.getBlob(1);
	        rs.close();
	        pstmt.close();

	        OutputStream out = blob.setBinaryStream(0);
	        out.write(requestD.getFileContent());
	        out.flush();
	        out.close();

	        String updateBlobSql =
	                "update PRI_DATA_RECEIVED set PRICE_LOADER_FILE=? where DATA_RECEIVED_ID = " + keyId;

	        pstmt = connection.prepareStatement(updateBlobSql);
	        pstmt.setBlob(1, blob);
	        pstmt.executeUpdate();
	        pstmt.close();

	        if (differentConn){
	        	connection.commit();
	        	connection.close();
	        }
		}catch (Exception e){
			if (differentConn){
	        	connection.rollback();
	        	connection.close();
	        }
            throw new RemoteException(e.getMessage());
        }
	}

	/**
    *Retrieves the action code for a shiped action based off the source dat and the ship date.
    *The source date is ideally the transaction  date, but otherwise the system date can be user (new Date()).
    *If the action date is in the future and more then 1 date out then the action date that is returned is
    *@see RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.SCHEDULED, otherwise @see RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.DIST_SHIPPED is returned
    */
    private String getOrderItemActionCodeForShipped(Date sourceDate, Date shipDate){
    	sourceDate = Utility.truncateDateByDay(sourceDate);
    	shipDate = Utility.truncateDateByDay(shipDate);
    	String action;
    	sourceDate = Utility.addWeekdays(sourceDate,+1); //becomes tommorw
        if(shipDate.compareTo(sourceDate) <= 0){
     	   action = RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.DIST_SHIPPED;
        }else{
     	   action = RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.SCHEDULED;
        }
        return action;
    }


    /**
     *Processes a ship notce aka EDI 856 document request that has been sent from a distribuor
     */
    private boolean processInboundDistributorEdi856(EdiInp856View pDistEdi856,
                                           Connection conn, IdVector pStoreIds,
                                            IdVector pDistributorIds,
                                            int pTradingPartnerId, Map pParamMap,
                                            Map<String, List<EdiInp856View>> pDistEdi856ByErrorMessage)
    throws Exception
    {
    	log.info("processInboundDistributorEdi856.");
    	log.debug("ediInp856Vw : "+pDistEdi856);

        TradingPartnerInfo partnerInfo = null;
        partnerInfo = getTradingPartnerInfo(pTradingPartnerId, pParamMap);

        EdiInp856View ediInp856Vw = pDistEdi856;
        //***********************************************************
        ArrayList errorMsgs = new ArrayList();
        //finish up processing of the 856, find order data etc.

        boolean matchByVendorOrderNum = ediInp856Vw.getMatchPoNumType().equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.VENDOR_ORDER_NUM);
        String poNum = matchByVendorOrderNum ? ediInp856Vw.getDistOrderNum() : ediInp856Vw.getPurchOrderNum();
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIII carrier: "+ediInp856Vw.getCarrierCode()+" ("+ediInp856Vw.getCarrierName());
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIII pStoreIds: "+pStoreIds);
        if(!Utility.isSet(poNum)){
        	poNum = ediInp856Vw.getDistOrderNum();
        }
        if (!Utility.isSet(poNum)) {
        	String msg =" processInboundDistributorEdi856, NO PO NUM pDistEdi856=" + pDistEdi856 ;
        	log.debug(">>>>>>>>>>>>IN " + msg );
        	log.error(msg);
        	return true;
        }

        PurchaseOrderData thePo = getOrderByPoNum(pStoreIds, pDistributorIds,poNum,0,0, conn, ediInp856Vw.getMatchPoNumType());
        if(thePo==null) {
          thePo = getOrderByPoNum(pStoreIds, pDistributorIds, ediInp856Vw.getDistOrderNum(),0,0, conn, ediInp856Vw.getMatchPoNumType());
          if(thePo!=null) {
              poNum = ediInp856Vw.getDistOrderNum();
          }
        }
        if(thePo==null) {
            String errMessage = "Order not found for the purchase order number:";
          log.error(errMessage);
          if (partnerInfo.isAllow856()) {
            // sendNotify
//            send856ErrorNotification(ediInp856Vw,errMessage,partnerInfo, conn);
              List<EdiInp856View> list = pDistEdi856ByErrorMessage.get(errMessage);
              if (list == null) {
                  list = new ArrayList<EdiInp856View>();
                  pDistEdi856ByErrorMessage.put(errMessage, list);
              }
              list.add(ediInp856Vw);
            return false;
          } else {
            throw new RemoteException(errMessage);
          }
        }
        ediInp856Vw.setPurchOrderNum(poNum); //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        int orderId = 0;
        int purchaseOrderId = 0;
        if(thePo!=null) {
          orderId = thePo.getOrderId();
          purchaseOrderId = thePo.getPurchaseOrderId();
        }
        ediInp856Vw.setOrderId(orderId);

        OrderItemDescDataVector orderItemDescDV =
                OrderDAO.getOrderItemDescCollection(conn, orderId, null, purchaseOrderId);
        if(orderItemDescDV==null || orderItemDescDV.size()==0) {
            String errMessage = "Order items not found for the purchase order number(s):";
            if (partnerInfo.isAllow856()) {
              // sendNotify
//              send856ErrorNotification(ediInp856Vw,errMessage,partnerInfo, conn);
                List<EdiInp856View> list = pDistEdi856ByErrorMessage.get(errMessage);
                if (list == null) {
                    list = new ArrayList<EdiInp856View>();
                    pDistEdi856ByErrorMessage.put(errMessage, list);
                }
                list.add(ediInp856Vw);
              return false;
            } else {
                throw new RemoteException(errMessage);
            }
        }


        if(pDistributorIds==null || pDistributorIds.size()==0) {
          log.error("Trading dist id not found.");
          //return;
        }

      log.debug("Inbound856 IIIIIIIIIIIIIII888888888888888 busEntId: "+IdVector.toCommaString(pDistributorIds));

        EdiInp856ItemViewVector ediInp856ItemVwV = ediInp856Vw.getItems();

        for(Iterator iter=ediInp856ItemVwV.iterator(); iter.hasNext();) {
          EdiInp856ItemView ediItem = (EdiInp856ItemView) iter.next();
          int lineNum = ediItem.getPurchOrderLineNum();
          String distSkuNum = ediItem.getDistSkuNum();
          if(null == distSkuNum) {
            throw new RemoteException("Error. IntegrationService.processInboundDistributorEdi856() edi file distributor sku is missing.  ediItem = " + ediItem);
          }
          boolean foundFl = false;
          for(Iterator iter1= orderItemDescDV.iterator(); iter1.hasNext(); ) {
            OrderItemDescData oidD = (OrderItemDescData) iter1.next();
            int distId = oidD.getDistId();
            OrderItemData oiD = oidD.getOrderItem();
            if(lineNum==oiD.getErpPoLineNum()) {
              foundFl = true;
              if(!(pDistributorIds == null || pDistributorIds.isEmpty()) && !pDistributorIds.contains(new Integer(distId))) {
            	  continue;
                //String errorMsg = "Distributor doesn't match. Purchase order line number: "+
                //        lineNum+ " Edi distr. id: "+  IdVector.toCommaString(pDistributorIds)+
                //        " Order distr. id: "+distId;
                //errorMsgs.add(errorMsg);
              }
              if(!distSkuNum.equals(oiD.getDistItemSkuNum())) {
                String errorMsg = "Distributor sku doesn't match. Purchase order line number: "+
                        lineNum+ " Edi sku: "+  distSkuNum+
                        " Order sku: "+oiD.getDistItemSkuNum();
                errorMsgs.add(errorMsg);
              }
              ediItem.setOrderItemId(oiD.getOrderItemId());
              ediItem.setSkuNum(""+oiD.getItemSkuNum());
              //break;
            }
          }

          //now match on dist sku
		  log.debug("looking for dist item number");
          if(!foundFl) {
			log.debug("Yes as it was not found");
        	  for(Iterator iter1= orderItemDescDV.iterator(); iter1.hasNext(); ) {
	              OrderItemDescData oidD = (OrderItemDescData) iter1.next();
	              int distId = oidD.getDistId();
	              OrderItemData oiD = oidD.getOrderItem();
				  log.debug("Comparing: "+distSkuNum+" to " +oiD.getDistItemSkuNum());
	              if(distSkuNum.equals(oiD.getDistItemSkuNum())) {
	                foundFl = true;
	                if(pDistributorIds != null && pDistributorIds.contains(new Integer(distId))) {
					  ediItem.setOrderItemId(oiD.getOrderItemId());
	                  ediItem.setSkuNum(""+oiD.getItemSkuNum());
	                }else{
					  log.debug("Found sku, but not authorized dist: "+distId);
					}
	              }

	            }
          }

          if(!foundFl) {
            String errorMsg = "Edi purchase order line number doesn't match to " +
               "the system purchase order line number. Edi purchase order line number: "+
               lineNum;
            errorMsgs.add(errorMsg);
            iter.remove();
          }
        }
        if(errorMsgs.size()>0) {
          Iterator it = errorMsgs.iterator();
          while(it.hasNext()){
              log.error(it.next().toString());
          }
          //return;  //process the file anyways
        }


        //***********************************************************
        //do the work of inserting the records and making sure that hey do not already exist
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII pDistEdi856: "+pDistEdi856);
       orderId = pDistEdi856.getOrderId();
       EdiInp856ItemViewVector ediItems = pDistEdi856.getItems();
       IdVector orderItemIdV = new IdVector();
       for(Iterator iter=ediItems.iterator(); iter.hasNext();) {
         EdiInp856ItemView ediItem = (EdiInp856ItemView) iter.next();
         orderItemIdV.add(new Integer(ediItem.getOrderItemId()));
       }


       //figure out if this is a scheduled by our definition or a shipped
       Date asn856Date = pDistEdi856.getShipDate();
       if(asn856Date == null){
           asn856Date = pDistEdi856.getTransactionDate();
       }
       Date actDate = Utility.truncateDateByDay(asn856Date);

       Date now = Utility.truncateDateByDay(pDistEdi856.getTransactionDate());
       String action=getOrderItemActionCodeForShipped(now,actDate);

       String carrier = pDistEdi856.getCarrierName();
       if(Utility.isSet(carrier)) {
           DBCriteria dbc = new DBCriteria();
           dbc.addEqualTo(OrderPropertyDataAccess.PURCHASE_ORDER_ID,purchaseOrderId);
           dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC,"Carrier 856");
           OrderPropertyDataVector opDV = OrderPropertyDataAccess.select(conn,dbc);
           if(opDV.size()>0) {
               OrderPropertyData opD = (OrderPropertyData) opDV.get(0);
               opD.setValue(carrier);
               opD.setModBy("IntegrationServicesBean");
           } else {
               OrderPropertyData opD = OrderPropertyData.createValue();
               opD.setOrderId(orderId);
               opD.setPurchaseOrderId(purchaseOrderId);
               opD.setShortDesc("Carrier 856");
               opD.setValue(carrier);
               opD.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.EVENT);
               opD.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
               opD.setAddBy("IntegrationServicesBean");
               opD.setModBy("IntegrationServicesBean");
               OrderPropertyDataAccess.insert(conn,opD);
           }
       }
       DBCriteria dbc = new DBCriteria();
       dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID,orderId);
       dbc.addEqualTo(OrderPropertyDataAccess.PURCHASE_ORDER_ID, purchaseOrderId);
       dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC,"Tracking Number 856");

       dbc = new DBCriteria();
       dbc.addEqualTo(OrderItemActionDataAccess.ORDER_ID, orderId);
       dbc.addOneOf(OrderItemActionDataAccess.ORDER_ITEM_ID, orderItemIdV);
       dbc.addEqualTo(OrderItemActionDataAccess.ACTION_CD,action);
       OrderItemActionDataVector orderItemActionDV = OrderItemActionDataAccess.select(conn,dbc);

       if(ediItems.size()==0){
    	   log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII Error no items to process");
       }
       for(Iterator iter=ediItems.iterator(); iter.hasNext();) {
         EdiInp856ItemView ediItem = (EdiInp856ItemView) iter.next();
         int orderItemId = ediItem.getOrderItemId();
         int shippedQty = ediItem.getShippedQty();
         boolean foundFl = false;
         boolean updateOrderItemActions = true;
         //this property is currently used only for xpedx
         if(pDistEdi856.getUpdateOrderItemActions()!=null &&
        		 pDistEdi856.getUpdateOrderItemActions().equalsIgnoreCase("false")){
        	 updateOrderItemActions = false;
         }

         for(Iterator iter1=orderItemActionDV.iterator(); iter1.hasNext();) {
           OrderItemActionData oiaD = (OrderItemActionData) iter1.next();
           if(oiaD.getOrderItemId()!=orderItemId || oiaD.getActionDate() == null || oiaD.getActionTime() == null) {
             continue;
           }
           Date actionDate = oiaD.getActionDate();
           Date actionTime = oiaD.getActionTime();
           Calendar cal = Calendar.getInstance();
           Calendar calTime = Calendar.getInstance();
           cal.setTime(actionDate);
           calTime.setTime(actionTime);
           cal.set(Calendar.HOUR_OF_DAY,calTime.get(Calendar.HOUR_OF_DAY));
           cal.set(Calendar.MINUTE,calTime.get(Calendar.MINUTE));
           Date actionDateTime = cal.getTime();
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII actionDate: "+actionDateTime);
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII transaDate: "+asn856Date);

           if(actionDateTime.compareTo(asn856Date) ==0) {
            log.debug("IntegrationServicesBean BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB found match");
            foundFl = true;

             if(updateOrderItemActions && oiaD.getQuantity()!= shippedQty) {
            	 oiaD.setQuantity(shippedQty);
            	 oiaD.setModBy("Edi Batch");
            	 OrderItemActionDataAccess.update(conn,oiaD);
             }
             break;
           }else{
            log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII NOT A match");
           }
         }
         if(!foundFl && orderItemId >0 || !updateOrderItemActions) {
           OrderItemActionData oiaD = OrderItemActionData.createValue();
           oiaD.setOrderId(orderId);
           oiaD.setOrderItemId(orderItemId);
           oiaD.setAffectedSku(ediItem.getSkuNum());
           oiaD.setActionCd(action);
           oiaD.setQuantity(shippedQty);
           oiaD.setActionDate(asn856Date);
           oiaD.setActionTime(asn856Date);
           oiaD.setAddBy("ASN");
           oiaD.setModBy("ASN");
           log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII inserting 856 order item action oiaD=" + oiaD );
           oiaD = OrderItemActionDataAccess.insert(conn,oiaD);
           int oiaId = oiaD.getOrderItemActionId();
           List trackingNumList = ediItem.getTrackingNumList();
           String deliveryReference = ediItem.getDeliveryReference();
           if(trackingNumList!=null && trackingNumList.size()>0) {
               String carrierNN = "";
               if(carrier!=null) {
                   carrierNN = carrier+" - ";
               }
               for(Iterator iter2=trackingNumList.iterator(); iter2.hasNext();) {
                    String tn = (String) iter2.next();
                    OrderItemActionData trOiaD = OrderItemActionData.createValue();
                    trOiaD.setOrderId(orderId);
                    trOiaD.setOrderItemId(orderItemId);
                    trOiaD.setAffectedSku(ediItem.getSkuNum());
                    trOiaD.setActionCd(RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.TRACKING_NUMBER);
                    trOiaD.setAffectedTable("CLW_ORDER_ITEM_ACTION");
                    trOiaD.setAffectedId(oiaId);
                    trOiaD.setComments(carrierNN + tn);
                    trOiaD.setQuantity(shippedQty);
                    trOiaD.setActionDate(asn856Date);
                    trOiaD.setActionTime(asn856Date);
                    trOiaD.setAddBy("ASN");
                    trOiaD.setModBy("ASN");
                    OrderItemActionDataAccess.insert(conn,trOiaD);
               }
           }

           if(Utility.isSet(deliveryReference)){
          	 OrderItemActionData delRefOiad = OrderItemActionData.createValue();
             delRefOiad.setOrderId(orderId);
             delRefOiad.setOrderItemId(orderItemId);
             delRefOiad.setAffectedSku(ediItem.getSkuNum());
             delRefOiad.setActionCd(RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.DELIVERY_REF_NUMBER);
             delRefOiad.setAffectedTable("CLW_ORDER_ITEM_ACTION");
             delRefOiad.setAffectedId(oiaId);
             delRefOiad.setComments(deliveryReference);
             delRefOiad.setQuantity(shippedQty);
             delRefOiad.setActionDate(asn856Date);
             delRefOiad.setActionTime(asn856Date);
             delRefOiad.setAddBy("ASN");
             delRefOiad.setModBy("ASN");
             OrderItemActionDataAccess.insert(conn,delRefOiad);

           }
         }
       }
       send856Notification (pDistEdi856);
       return true;
    }

    private static final String mLock_processIntegrationRequests
      = " ISB:";
    //
    // method to call the synchronized method.
    //
    public void processIntegrationRequests
	(IntegrationRequestsVector pIntegrationReqV,
         String pErpNum, int tradingPartnerId)
      throws RemoteException {

          //synchronized(mLock_processIntegrationRequests) {
    	{
              Date d1 = new Date();
              log.info("processIntegrationRequests START " +mLock_processIntegrationRequests+ this.hashCode() + " - " + d1 );

              processIntegrationRequests_p
	        ( pIntegrationReqV,  pErpNum, tradingPartnerId);

              Date d2 = new Date();
              log.info("processIntegrationRequests END " +mLock_processIntegrationRequests+ this.hashCode() + " - " + d2+ " secs. elapsed " + (d2.getTime() - d1.getTime()) );

         }

    }

    /**
     * <code>processIntegrationRequests</code>
     *
     * @param pIntegrationReqV an <code>IntegrationRequestsVector</code> value
     * @param pErpNum          the erp number of what we are processing if applicable
     * @param tradingPartnerId the id of the trading parnter that was used for translation
     * @exception RemoteException if an error occurs
     */
    private  void processIntegrationRequests_p
	(IntegrationRequestsVector pIntegrationReqV, String pErpNum, int tradingPartnerId)
      throws RemoteException {
        Object pRequestD;
        Connection conn = null;
        //contains a hash of any params that should be maintaned for loading this set of
        //integration requests, such as PreparedStatments etc.
        Map paramMap = new java.util.HashMap();
        try {
            conn = getConnection();
            setDebugOn();

            //figure out the stores, distributors and accounts related to this trading partner
            DBCriteria crit = new DBCriteria();
            String tpat = TradingPartnerAssocDataAccess.CLW_TRADING_PARTNER_ASSOC;
            String bet = BusEntityDataAccess.CLW_BUS_ENTITY;
            crit.addJoinTableEqualTo(tpat,TradingPartnerAssocDataAccess.TRADING_PARTNER_ID,tradingPartnerId);
            crit.addJoinCondition(tpat,TradingPartnerAssocDataAccess.BUS_ENTITY_ID,bet,BusEntityDataAccess.BUS_ENTITY_ID);
            BusEntityDataVector beds = new BusEntityDataVector();
            JoinDataAccess.selectTableInto(new BusEntityDataAccess(), beds, conn,crit,500);
            Iterator it = beds.iterator();

            IdVector acctIds = new IdVector();
            IdVector distIds = new IdVector();
            IdVector storeIds = new IdVector();
            while(it.hasNext()){
            	BusEntityData b = (BusEntityData) it.next();
            	if(RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT.equals(b.getBusEntityTypeCd())){
            		acctIds.add(new Integer(b.getBusEntityId()));
            	}else if(RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR.equals(b.getBusEntityTypeCd())){
            		distIds.add(new Integer(b.getBusEntityId()));
            	}else if(RefCodeNames.BUS_ENTITY_TYPE_CD.STORE.equals(b.getBusEntityTypeCd())){
            		storeIds.add(new Integer(b.getBusEntityId()));
            	}else{
                    log.info("Found unknown bus entity type cd: "+b.getBusEntityId()+"::"+b.getBusEntityTypeCd());
                }
            }
            //--------------now finish up populating the store ids by getting the accounts as dist parent bus entity ids
            //start with accounts
            it = acctIds.iterator();
            while(it.hasNext()){
                int id = ((Integer)it.next()).intValue();
                int storeId = BusEntityDAO.getStoreForAccount(conn,id);
                if(storeId > 0){
                    Integer storeIdInt = new Integer(storeId);
                    if(!storeIds.contains(storeIdInt)){
                        storeIds.add(storeIdInt);
                    }
                }
            }

            //now do distributors
            it = distIds.iterator();
            while(it.hasNext()){
                int id = ((Integer)it.next()).intValue();
                int storeId = BusEntityDAO.getStoreForDistributor(conn,id);
                log.info("Found store for dist id "+id+" ("+storeId+")");
                if(storeId > 0){
                    Integer storeIdInt = new Integer(storeId);
                    if(!storeIds.contains(storeIdInt)){
                        storeIds.add(storeIdInt);
                    }
                }
            }
            log.info("ISB:" + this.hashCode() +" acctIds related to trading partner= "+acctIds.size() +"\n distIds realted to trading partner= "+distIds.size()+"\n storeIds realted to trading partner= "+storeIds.size());
            //------------end populating of the store id vector

            /// Creation of buffer to store messages.
            StringBuilder messagesBuffer = new StringBuilder();
            /// Validation of 'AcknowledgeRequestData'-objects from 'pIntegrationReqV' array.
            boolean isSuccessValidation = true;
            for (int i = 0; i < pIntegrationReqV.size(); i++) {
                pRequestD = (Object) pIntegrationReqV.get(i);
                if (pRequestD instanceof AcknowledgeRequestData) {
                    /// Validation of data from 'pRequestD' object
                    boolean validationResult =
                        validateAcknowledgeRequest((AcknowledgeRequestData)pRequestD,
                            conn, paramMap, tradingPartnerId, storeIds, acctIds,
                                distIds, messagesBuffer);
                    if (!validationResult) {
                        isSuccessValidation = false;
                    }
                }
            }

            /// Checking of validation result
            if (!isSuccessValidation) {
                throw new Exception(messagesBuffer.toString());
            }

            log.info("Processing: " + pIntegrationReqV.size() + " integration requests");
            long timer = System.currentTimeMillis();


            TradingPartnerInfo partnerInfo = getTradingPartnerInfo(tradingPartnerId, paramMap);;

            int tr856count = 0;
            for (int i = 0; i < pIntegrationReqV.size(); i++) {
                pRequestD = (Object) pIntegrationReqV.get(i);
                if  (pRequestD instanceof EdiInp856View) {
                    tr856count++;
                }
            }
            Map<String, List<EdiInp856View>> pDistEdi856ByErrorMessage = new TreeMap<String, List<EdiInp856View>>();
            for (int i = 0; i < pIntegrationReqV.size(); i++) {
                    if (i % 1000 == 0 && i > 0) {
                        double avg = (System.currentTimeMillis() - timer) / 1000;
                        log.info("Processed: " + i+ " integration requests.  Averaging: " + avg+ " ms per integration request.");
                        timer = System.currentTimeMillis();
                    }
                    pRequestD = (Object) pIntegrationReqV.get(i);
                    IntegrationRequestData container = null;
                    if (pRequestD instanceof IntegrationRequestsVector) {
                    	log.info("IntegrationServicesBean IIIIIIIIIIIIIIIIII pRequestD: "+ pRequestD.getClass().getName()+ " "+ i+ " of " + pIntegrationReqV.size());
                    	if (isFlatOrderGuides((IntegrationRequestsVector)pRequestD) == true) {
                            processFlatOrderGuides((IntegrationRequestsVector)pRequestD, conn, paramMap,
                                    pErpNum, storeIds, acctIds, distIds, tradingPartnerId);
                            continue;
                        }
                    }else if (pRequestD instanceof IntegrationRequestData) {
                        container = (IntegrationRequestData) pRequestD;
                        pRequestD = container.getIntegrationRequest();
                        log.info("IntegrationServicesBean IIIIIIIIIIIIIIIIII pRequestD: "+ pRequestD.getClass().getName()+ " "+ i+ " of " + pIntegrationReqV.size());
                    }else{
                    	log.info("IntegrationServicesBean IIIIIIIIIIIIIIIIII pRequestD: "+ pRequestD.getClass().getName()+ " "+ i+ " of " + pIntegrationReqV.size());
                    }

                    boolean isProcessed = processIntegrationRequest(pRequestD, conn, paramMap,
                            pErpNum, storeIds, acctIds, distIds,
                            tradingPartnerId,
                            pDistEdi856ByErrorMessage);
            }
            if (pDistEdi856ByErrorMessage.isEmpty() == false) {
                send856ErrorNotification(pDistEdi856ByErrorMessage,
                        partnerInfo,
                        conn);
            }
            double avg;
            if(pIntegrationReqV.size() > 0){
                avg = (System.currentTimeMillis() - timer) / pIntegrationReqV.size();
            }else{
                avg = 0;
            }
            log.info("Processed: " + pIntegrationReqV.size() + " integration requests.  Averaging: " + avg + " ms per integration request.");
        } catch (Exception e) {
            throw processException(e);
        } finally {
            closeConnection(conn);
        }

    }

    /**
     * <code>getTransactionsAcked</code>
     *
     * @param pSender group sender id
     * @param pReceiver group receiver id
     * @param pSetType transaction type
     * @param pGroupControlNum group control number
     * @param pSetControlNum transaction control number
     * @exception RemoteException if an error occurs
     */
    private ElectronicTransactionDataVector getTransactionsAcked(String pSender,
                                                                 String pReceiver,
                                                                 String pSetType,
                                                                 Integer pGroupControlNum,
                                                                 Integer pSetControlNum,
                                                                 Connection con)
        throws RemoteException {
		log.info("getTransactionsAcked -> pSender = " + pSender
				+ " pReceiver = " + pReceiver + " pSetType = " + pSetType
				+ " pGroupControlNum =" + pGroupControlNum
				+ " pSetControlNum = " + pSetControlNum);
        DBCriteria dbc;

        try {
            dbc = new DBCriteria();
            if(Utility.isSet(pSender))
            dbc.addEqualTo(ElectronicTransactionDataAccess.GROUP_SENDER,pSender);
            dbc.addEqualTo(ElectronicTransactionDataAccess.GROUP_RECEIVER,pReceiver);
            dbc.addEqualTo(ElectronicTransactionDataAccess.GROUP_CONTROL_NUMBER, pGroupControlNum);

            if (pSetType != null) {
                dbc.addEqualTo(ElectronicTransactionDataAccess.SET_TYPE,
                               pSetType);
                dbc.addEqualTo(
                        ElectronicTransactionDataAccess.SET_CONTROL_NUMBER,
                        pSetControlNum);
            }

            ElectronicTransactionDataVector transactionDV =
                    ElectronicTransactionDataAccess.select(con, dbc);

            return transactionDV;
        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationService.getTransactionsAcked() SQL Exception happened. " +
                                      exc.getMessage());
        }
    }


    private void processSiteDataUpdateRequest(SiteDataUpdateRequest def,Connection conn, Map paramMap,
            IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds, int tradingPartnerId)
    throws Exception{
    	log.info("processSiteDataUpdateRequest");
    	BusEntityDataVector sites = getSitesFromEntityKey(def.getEntityKey(),pStoreIds,pAccountIds,tradingPartnerId, conn);
    	if(sites == null || sites.size() == 0){
            log.info("No sites found for site identfier "+def.getEntityKey());
            //XXX for GCA there are many more budgets than we have, so for now we will just ignore it if we get an extra.
            //this need to be both configurable and for there to be some sort of erro reporting mechanism
            return;
        }else{
            log.debug("sites found for site identfier "+def.getEntityKey());
        }

    	String p = PropertyDataAccess.CLW_PROPERTY;
    	String ba = BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC;
    	Iterator it = sites.iterator();
    	while(it.hasNext()){
            BusEntityData site = (BusEntityData) it.next();
            int siteId = site.getBusEntityId();
            Iterator it2 = def.getSiteDataEntries().iterator();
            int ct = 0;
            while(it2.hasNext()){
            	String siteFieldValue = (String) it2.next();
            	ct++;
            	//get the property name
            	DBCriteria crit = new DBCriteria();
            	crit.addJoinCondition(ba,BusEntityAssocDataAccess.BUS_ENTITY2_ID,p,PropertyDataAccess.BUS_ENTITY_ID);
            	crit.addJoinTableEqualTo(ba,BusEntityAssocDataAccess.BUS_ENTITY1_ID,siteId);
            	crit.addJoinTableEqualTo(p,PropertyDataAccess.PROPERTY_TYPE_CD,RefCodeNames.PROPERTY_TYPE_CD.SITE_FIELD_CD);
            	crit.addJoinTableEqualTo(p,PropertyDataAccess.SHORT_DESC,PropertyFieldUtil.getFnTag(ct));
            	List ids = JoinDataAccess.selectColumnOnly(conn,p,PropertyDataAccess.CLW_VALUE,crit,1);
            	if(ids != null && !ids.isEmpty()){
            		//get the existing property
            		String shortDesc = (String) ids.get(0);
            		crit = new DBCriteria();
            		crit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,siteId);
            		crit.addEqualTo(PropertyDataAccess.SHORT_DESC,shortDesc);
            		crit.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,RefCodeNames.PROPERTY_TYPE_CD.SITE_FIELD_CD);
            		PropertyDataVector pdv = PropertyDataAccess.select(conn,crit,1);
            		PropertyData prop;
            		//create it if it doesnt exist
            		if(pdv == null || pdv.isEmpty()){
            			prop = PropertyData.createValue();
            			prop.setBusEntityId(siteId);
            			prop.setShortDesc(shortDesc);
            			prop.setPropertyTypeCd(RefCodeNames.PROPERTY_TYPE_CD.SITE_FIELD_CD);
            			prop.setAddBy("System Request");
            		}else{
            			prop = (PropertyData) pdv.get(0);
            		}
            		prop.setPropertyStatusCd(RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
            		prop.setModBy("System Request");
            		prop.setValue(siteFieldValue);
            		//insert update the property
            		if(prop.getPropertyId() == 0){
            			PropertyDataAccess.insert(conn,prop);
            		}else{
            			PropertyDataAccess.update(conn,prop);
            		}
            	}else{
            		log.error("processSiteDataUpdateRequest.Error no site field at index: "+ct+" for site: "+siteId);
            	}

            }
    	}

    }

    private BusEntityDataVector getAccountsFromEntityKey(String def, IdVector pStoreIds, Connection conn)
    throws SQLException{
       BusEntitySearchCriteria sc = new BusEntitySearchCriteria();
       log.info("Looking for account "+def+" belonging to store" +Utility.toCommaSting(pStoreIds));
       sc.setParentBusEntityIds(pStoreIds);
       //sc.setAccountBusEntityIds(pAccountIds);
       sc.setStoreBusEntityIds(pStoreIds);
       String accountIdentifierType = RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM;

       sc.addPropertyCriteria(accountIdentifierType,def);
       return  BusEntityDAO.getBusEntityByCriteria(conn, sc,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
    }

    private BusEntityDataVector getSitesFromEntityKey(String def, IdVector pStoreIds, IdVector pAccountIds, int partnerId, Connection conn)
    throws SQLException{
       if(Utility.isSet(def)){
    	def = Utility.trimLeft(def, "0").trim();
       }



       /*
        * The following is here for upgrade reasons and is not intended as a long term fix.
        * The above code should send out email messages to determine the scope of the problem.
        * Currently we look at the first word of the site reference number and use this to match.
        * This is both cumbersome and does not allow for valid site reference numbers like "WFM-0012".
        * The extent of the use of this code is unknown, I would like for this to be moved into the
        * parsing classes for those accounts where this logic is necessary, but cannot determine this today.
        *
        */
       if(partnerId < 4479){
    	   try{
    	       if(!def.equals(Utility.getFirstToken(def))){
    	    	   EventEmailDataView em = new EventEmailDataView();
    	    	   em.setToAddress(getIntegrationEmailAddress());
    	    	   em.setFromAddress(getIntegrationEmailAddress());
    	    	   em.setEmailStatusCd(Event.STATUS_READY);
    	    	   em.setSubject("Found untokenized site reference: "+def);
    	    	   em.setText("For account ids: "+Utility.toCommaSting(pAccountIds)+" \nand store ids: "+Utility.toCommaSting(pStoreIds)+" \nand partner "+partnerId);
    	    	   EventBean eventEjb = new EventBean();
    	    	   //eventEjb.addEventEmail(em);
    	       }
           }catch(Exception e){
        	   e.printStackTrace();
           }
    	   def = Utility.getFirstToken(def);
       }
       log.debug("Loading definition request: "+def);

       //find the site (always key off the site even for account types)
       BusEntitySearchCriteria sc = new BusEntitySearchCriteria();
       log.info("Looking for site "+def+" belonging to accounts" +Utility.toCommaSting(pAccountIds));
       sc.setParentBusEntityIds(pAccountIds);
       //sc.setAccountBusEntityIds(pAccountIds);
       sc.setStoreBusEntityIds(pStoreIds);
       String siteIdentifierType = RefCodeNames.PROPERTY_TYPE_CD.SITE_REFERENCE_NUMBER;

       try {
    	   TradingPartnerData partnerD = TradingPartnerDataAccess.select(conn, partnerId);
    	   if (Utility.isSet(partnerD.getSiteIdentifierTypeCd()) && partnerD.getSiteIdentifierTypeCd().equals(RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER))
    		   siteIdentifierType = RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER;
       }catch(Exception e){
       }

       sc.addPropertyCriteria(siteIdentifierType,def);
       return  BusEntityDAO.getBusEntityByCriteria(conn, sc,RefCodeNames.BUS_ENTITY_TYPE_CD.SITE);
    }



    /**
     *Loads a par for a site and item. (Not used currently!!! Use processParLoaderRequest)
     * @deprecated
     */
     private void processParDefinitionRequest(ParDefinitionRequest def,Connection conn, Map paramMap,
            IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds, int partnerId)
           throws Exception{
   	    BusEntityDataVector sites = getSitesFromEntityKey(def.getEntityKey(),pStoreIds,pAccountIds,partnerId,conn);
    	if(sites == null || sites.size() == 0){
            log.debug("No sites found for site identfier "+def.getEntityKey());
            //XXX for GCA there are many more budgets than we have, so for now we will just ignore it if we get an extra.
            //this need to be both configurable and for there to be some sort of erro reporting mechanism
            return;
        }else{
            log.debug("sites found for site identfier "+def.getEntityKey());
        }
    	int itemId = ItemSkuMapping.mapToItemId(conn, def.getSku(), null, def.getSkuTypeCd(),0,true,pDistributorIds,false);
        if(itemId == 0){
        	String mess = "Could not find item mapping for sku: "+def.getSku()+" and sku type: "+def.getSkuTypeCd();
        	if(Utility.isTrue(def.getContinueOnError())){
        		log.error(mess);
        	}else{
        		throw new Exception(mess);
        	}
        }

        BusEntityData site = (BusEntityData) sites.get(0);
        int siteId = site.getBusEntityId();

        //get the par record if it exists
        InventoryLevelViewVector ilvv = InventoryLevelDAO.getInvLevelViewCollections(conn, siteId, Utility.toIdVector(itemId));
        InventoryLevelView ilView;
        if (!ilvv.isEmpty()) {
            ilView = (InventoryLevelView) ilvv.get(0);
        } else {
            InventoryLevelData il = InventoryLevelData.createValue();
            il.setBusEntityId(siteId);
            il.setItemId(itemId);
            ilView = new InventoryLevelView(il, new InventoryLevelDetailDataVector());
        }

        InventoryLevelViewWrapper ilViewWrapper = new InventoryLevelViewWrapper(ilView);
        if (def.getAmountForAllPeriods() != null) {

            BusEntityDAO bDao = new BusEntityDAO();

            int accountId = BusEntityDAO.getAccountForSite(conn, siteId);
            FiscalCalenderView fiscalCalender = bDao.getCurrentFiscalCalenderV(conn, accountId);
            if (fiscalCalender == null) {
                String mess = "Could not find 'Fiscal Calendar' for account:" + accountId + ", site:" + siteId;
                if (!Utility.isTrue(def.getContinueOnError())) {
                    throw new Exception(mess);
                } else {
                    log.error(mess);
                }
            } else {
                ilViewWrapper.setParValues(new InventoryLevelDetailDataVector());
                for (Object oFiscalPeriod : fiscalCalender.getFiscalCalenderDetails()) {
                    FiscalCalenderDetailData fp = (FiscalCalenderDetailData) oFiscalPeriod;
                    ilViewWrapper.setParValue(fp.getPeriod(), def.getAmountForAllPeriods());
                }
            }

        } else {

            ilViewWrapper.setParValues(new InventoryLevelDetailDataVector());

            int period = 0;
            for (Integer amount : def.getAmounts()) {
                ilViewWrapper.setParValue(++period, amount);
            }

        }

        ilViewWrapper.setParsModBy("loader");
        ilViewWrapper.setParsModDate(new java.util.Date(System.currentTimeMillis()));

        InventoryLevelDAO.updateInventoryLevelView(conn, ilViewWrapper.getInventoryLevelView(), className);

    }

     /**
      *	processParLoaderRequest
      */
      private void processParLoaderRequest(ParLoaderRequest def,Connection conn, Map paramMap,
             IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds, int partnerId)
            throws Exception{

    	  int siteCatalogId=0;
    	  int siteId = def.getSiteId();
    	  log.debug("processParLoaderRequest.SiteId="+siteId);
    	  if (siteId > 0) {
              DBCriteria dbc = new DBCriteria();
              dbc.addEqualTo(BusEntityDataAccess.BUS_ENTITY_ID, siteId);
              BusEntityDataVector bedv = BusEntityDataAccess.select(conn, dbc);
              if ( bedv == null || bedv.size() == 0) {
                  log.info("No sites found for site id " + siteId);
                  return;
              }
    	  } else {
    		  BusEntityDataVector sites = getSitesFromEntityKey(def.getEntityKey(),pStoreIds,pAccountIds,partnerId,conn);
    		  if(sites == null || sites.size() == 0){
        		  log.info("No sites found for site identfier "+def.getEntityKey());
        		  return;
    		  } else {
                  BusEntityData bed = (BusEntityData) sites.get(0);
                  siteId = bed.getBusEntityId();
        		  log.info("sites found for site identfier "+def.getEntityKey());
        	  }
    	  }

    	  //get shopping catalog for site
    	  if (siteId > 0) {
                DBCriteria conCrit = new DBCriteria();
                conCrit.addEqualTo(CatalogAssocDataAccess.BUS_ENTITY_ID, siteId);
                conCrit.addOrderBy(CatalogAssocDataAccess.CATALOG_ID, false);
                CatalogAssocDataVector catalogAssocs = CatalogAssocDataAccess.select(conn, conCrit);
                if ( catalogAssocs != null && catalogAssocs.size() > 0 ){
                    CatalogAssocData cad = (CatalogAssocData)catalogAssocs.get(0);
                    siteCatalogId = cad.getCatalogId();
                }
    		    log.info("Site catalog : "+siteCatalogId);
    	  }
    	  // Make sure that the site belongs to pAccountIds
    	  for(int i=0; i<pAccountIds.size();i++){
    		  log.debug("AccId "+pAccountIds.get(i).toString());
    	  }
    	  Integer aid = new Integer(BusEntityDAO.getAccountForSite(conn, siteId));
    	  log.debug("IntegrationServicesBean::accountId="+aid.intValue());
    	  if((pAccountIds.size()>0 && pAccountIds != null) && !pAccountIds.contains(aid)){
    		  String mess = "Site "+siteId+" does not belong to account "+aid.intValue() +" but rather belongs to account: "+aid;
    		  if(Utility.isTrue(def.getContinueOnError())){
          		log.error(mess);
          	}else{
          		throw new Exception(mess);
          	}
    	  }

    	  //xxx same for store
    	  for(int i=0; i<pStoreIds.size();i++){
    		  log.debug("pStoreIds "+pStoreIds.get(i).toString());
    	  }
    	  Integer sid = new Integer(BusEntityDAO.getStoreForAccount(conn,aid.intValue()));

    	  log.debug("IntegrationServicesBean::store Id="+sid.intValue());
    	  if((pStoreIds.size()!=0 || pStoreIds != null) && !pStoreIds.contains(sid)){
    		  String mess = "Store "+sid.intValue()+" does not belong to account ";
    		  if(Utility.isTrue(def.getContinueOnError())){
          		log.error(mess);
          	}else{
          		throw new Exception(mess);
          	}
    	  }

    	  // if pDistributorIds is null, get all distributors for store and add to pDistIds
    	  if(pDistributorIds.size()== 0 || pDistributorIds == null){
    		  Distributor distEjb = APIAccess.getAPIAccess().getDistributorAPI();

    		  for(int i=0; i<pStoreIds.size(); i++){
    			 int storeId = ((Integer)pStoreIds.get(i)).intValue();
    			 pDistributorIds =  distEjb.getDistributorIdsForStore(storeId);
    		  }
    	  }
    	  /*for(int ss=0;ss<pDistributorIds.size();ss++){
    		  log.debug("DIST IDS "+pDistributorIds.get(ss));
    	  }*/
    	  int itemId=0;
    	  String distSku = def.getDistSku();
    	  if(def.isLoadOnlyForActiveItem()){
    		  log.debug("*******************LoadOnlyForActiveItem is set");
    		  itemId = ItemSkuMapping.mapToItemId(conn,distSku, def.getSkuTypeCd(), null, siteCatalogId,true,pDistributorIds,true);
    	  } else {
    		  itemId = ItemSkuMapping.mapToItemId(conn,distSku, def.getSkuTypeCd(), null, siteCatalogId,true,pDistributorIds,false);
    	  }

    	  if(itemId == 0){
         	String mess = "Could not find item mapping for sku: "+distSku;
         	//if (Utility.isTrue(def.getContinueOnError())) {
         	//	log.error(mess);
         	//} else {
         	throw new Exception(mess);
         	//}
         }

         //get the par record if it exists
         InventoryLevelViewVector ilvv = InventoryLevelDAO.getInvLevelViewCollections(conn, siteId, Utility.toIdVector(itemId));
         InventoryLevelView ilView;
         if (!ilvv.isEmpty()) {
             ilView = (InventoryLevelView) ilvv.get(0);
         } else {
             InventoryLevelData il = InventoryLevelData.createValue();
             il.setBusEntityId(siteId);
             il.setItemId(itemId);
             ilView = new InventoryLevelView(il, new InventoryLevelDetailDataVector());
         }

         InventoryLevelViewWrapper ilViewWrapper = new InventoryLevelViewWrapper(ilView);
         if (def.getAllPeriods() != null) {

             BusEntityDAO bDao = new BusEntityDAO();

             int accountId = BusEntityDAO.getAccountForSite(conn, siteId);
             FiscalCalenderView fiscalCalender = bDao.getCurrentFiscalCalenderV(conn, accountId);
             if (fiscalCalender == null) {
                 String mess = "Could not find 'Fiscal Calendar' for account:" + accountId + ", site:" + siteId;
                 if (!Utility.isTrue(def.getContinueOnError())) {
                     throw new Exception(mess);
                 } else {
                     log.error(mess);
                 }
             } else {
                 ilViewWrapper.setParValues(new InventoryLevelDetailDataVector());
                 for (Object oFiscalPeriod : fiscalCalender.getFiscalCalenderDetails()) {
                     FiscalCalenderDetailData fp = (FiscalCalenderDetailData) oFiscalPeriod;
                     ilViewWrapper.setParValue(fp.getPeriod(), def.getAllPeriods());
                 }
             }
         } else {
             /*if (def.isLoadOnlyIfData()) {
                 int period = 0;
                 for (Integer parValue : def.getPeriods()) {
                     if (parValue != null) {
                         ilViewWrapper.setParValue(++period, parValue);
                     }
                 }
             } else {
                 ilViewWrapper.setParValues(new InventoryLevelDetailDataVector());
                 int period = 0;
                 for (Integer parValue : def.getPeriods()) {
                     parValue = parValue != null ? parValue : 0;
                     ilViewWrapper.setParValue(++period, parValue);
                 }
             }*/

        	 if(def.isLoadOnlyIfData()){

        		 for(Map.Entry e1: def.getPeriods().entrySet()){

        			 String key = (String)e1.getKey();
        			 if(key!=null && e1.getValue()!=null){
        				 String value = e1.getValue().toString();
        				 //BigDecimal valB = new BigDecimal(value);
        				 ilViewWrapper.setParValue(Integer.parseInt(key), Integer.parseInt(value));
        			 }
        		 }

        	 } else {

        		 for(Map.Entry e1: def.getPeriods().entrySet()){

        			 String key = (String)e1.getKey();
        			 if(key != null && e1.getValue() != null){
        				 String value = e1.getValue().toString();
        				 //BigDecimal valB = new BigDecimal(value);
        				 ilViewWrapper.setParValue(Integer.parseInt(key), Integer.parseInt(value));
        			 }else{
        				 ilViewWrapper.setParValue(Integer.parseInt(key), 0);
        			 }
        		 }

        	 }

         }

         ilViewWrapper.setParsModBy("loader");
         ilViewWrapper.setParsModDate(new java.util.Date(System.currentTimeMillis()));
         InventoryLevelView res = InventoryLevelDAO.updateInventoryLevelView(conn, ilViewWrapper.getInventoryLevelView(), "loader");

     }

      /**
       *	processBackorderLoaderRequest
       */
      private void processBackorderLoaderRequest(BackorderLoaderRequest def,Connection conn, Map paramMap,
    		  IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds, int partnerId)
      throws Exception{

    	  OrderItemDataVector oidv = new OrderItemDataVector();
    	  OrderItemData oid = OrderItemData.createValue();
    	  DBCriteria crit = new DBCriteria();
    	  SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");

    	  String poNum = def.getCustPONum();
    	  if(poNum ==null){
    		  String mess = "No po num defined!";
    		  if(Utility.isTrue(def.getContinueOnError())){
    			  log.error(mess);
    		  }else{
    			  throw new Exception(mess);
    		  }
    	  }else{
    		  crit.addEqualTo(OrderItemDataAccess.OUTBOUND_PO_NUM, poNum);
    	  }

    	  String itemNum = def.getCustPartCode();
    	  if(itemNum ==null){
    		  String mess = "No customer part code defined!";
    		  if(Utility.isTrue(def.getContinueOnError())){
    			  log.error(mess);
    		  }else{
    			   throw new Exception(mess);
    		  }
    	  }else{
    		  crit.addEqualTo(OrderItemDataAccess.DIST_ITEM_SKU_NUM, itemNum);
    	  }
    	  int orderItemId = 0;
    	  oidv = OrderItemDataAccess.select(conn, crit);
    	  if(oidv != null && oidv.size() > 0){
    		  oid = (OrderItemData)oidv.get(0);
    		  orderItemId = oid.getOrderItemId();

    	  }else{
    		  String mess = "No order found for po num: "+poNum+" and dist item: "+itemNum;
    		  if(Utility.isTrue(def.getContinueOnError())){
    			  log.error(mess);
    			  return;
    		  }else{
    			  throw new Exception(mess);
    		  }
    	  }

    	  //Get order id
    	  int orderId = oid.getOrderId();

    	  //Get order data
    	  OrderData order = OrderDataAccess.select(conn, orderId);

    	  String location = def.getLocation();

          //get the backorder record if it exists
          crit = new DBCriteria();
          crit.addEqualTo(BackorderDataAccess.PO_NUM, poNum);
          crit.addEqualTo(BackorderDataAccess.ITEM_NUM, itemNum);
          BackorderDataVector bodv = BackorderDataAccess.select(conn, crit);

          BackorderData bo;
          Date current = new Date();
          if(!bodv.isEmpty()){
          	bo = (BackorderData)bodv.get(0);
          }else{
          	bo = BackorderData.createValue();
          	bo.setPoNum(poNum);
          	bo.setItemNum(Integer.parseInt(itemNum));
          	bo.setLocation(location);
          	bo.setAddBy("loader");
          }

          if(def.isLoadOnlyIfData()){

        	  if(def.getItemStatus()!=null){
        		  bo.setItemStatus(def.getItemStatus());
        	  }
        	  if(def.getBackorderQty()>0){
        		  bo.setBackorderQty(def.getBackorderQty());
        	  }
        	  if(def.getOrderQty()>0){
        		  bo.setOrderQty(def.getOrderQty());
        	  }
        	  if(def.getShipQty()>0){
        		  bo.setShipQty(def.getShipQty());
        	  }
        	  if(def.getEstimatedInStock()!=null && def.getEstimatedInStock().length()>0){
        		  String est = def.getEstimatedInStock();
        		  bo.setEstInStock(sdf.parse(est));
        	  }
        	  if(def.getOrderEntryDate()!=null){
        		  String entryDate = def.getOrderEntryDate();
        		  bo.setOrderEntryDate(sdf.parse(entryDate));
        	  }
        	  if(def.getOrderBranchCode()!=null){
        		  bo.setOrderBranchCode(def.getOrderBranchCode());
        	  }
        	  if(def.getOrderNum()>0){
        		  bo.setOrderNum(Integer.toString(def.getOrderNum()));
        	  }
        	  if(def.getOrderDistributionNum()>0){
        		  bo.setOrderDistributionNum(def.getOrderDistributionNum());
        	  }
        	  if(def.getOrderShipmentNum()>0){
        		  bo.setOrderShipmentNum(def.getOrderShipmentNum());
        	  }
        	  if(def.getShipFromBranchCode()!=null){
        		  bo.setShipBranchCode(def.getShipFromBranchCode());
        	  }
        	  if(def.getItemDesc()!=null){
        		  bo.setItemDesc(def.getItemDesc());
        	  }
        	  if(def.getItemDesc2()!=null){
        		  bo.setItemDesc2(def.getItemDesc2());
        	  }
        	  if(def.getUOM()!=null){
        		  bo.setUom(def.getUOM());
        	  }
        	  if(def.getCustIndicatorCode()!=null){
        		  bo.setCustIndicatorCode(def.getCustIndicatorCode());
        	  }
          }else{

        	  if(def.getItemStatus()==null){
        		  bo.setItemStatus("");
        	  }else{
        		  bo.setItemStatus(def.getItemStatus());
        	  }

        	  if(def.getBackorderQty()<=0){
        		  bo.setBackorderQty(0);
        	  }else{
        		  bo.setBackorderQty(def.getBackorderQty());
        	  }
        	  if(def.getOrderQty()<=0){
        		  bo.setOrderQty(0);
        	  }else{
        		  bo.setOrderQty(def.getOrderQty());
        	  }
        	  if(def.getShipQty()<=0){
        		  bo.setShipQty(0);
        	  }else{
        		  bo.setShipQty(def.getShipQty());
        	  }

        	  if(def.getEstimatedInStock()==null && def.getEstimatedInStock().length()<1){
        		  bo.setEstInStock(null);
        	  }else{
        		  String est = def.getEstimatedInStock();
        		  bo.setEstInStock(sdf.parse(est));
        	  }

        	  if(def.getOrderEntryDate()==null){
        		  bo.setOrderEntryDate(null);
        	  }else{
        		  String entryDate = def.getOrderEntryDate();
        		  bo.setOrderEntryDate(sdf.parse(entryDate));
        	  }
        	  if(def.getOrderBranchCode()==null){
        		  bo.setOrderBranchCode("");
        	  }else{
        		  bo.setOrderBranchCode(def.getOrderBranchCode());
        	  }

        	  if(def.getOrderNum()<=0){
        		  bo.setOrderNum("");
        	  }else{
        		  bo.setOrderNum(Integer.toString(def.getOrderNum()));
        	  }
        	  if(def.getOrderDistributionNum()<=0){
        		  bo.setOrderDistributionNum(0);
        	  }else{
        		  bo.setOrderDistributionNum(def.getOrderDistributionNum());
        	  }
        	  if(def.getOrderShipmentNum()<=0){
        		  bo.setOrderShipmentNum(0);
        	  }else{
        		  bo.setOrderShipmentNum(def.getOrderShipmentNum());
        	  }

        	  if(def.getShipFromBranchCode()==null){
        		  bo.setShipBranchCode("");
        	  }else{
        		  bo.setShipBranchCode(def.getShipFromBranchCode());
        	  }
        	  if(def.getItemDesc()==null){
        		  bo.setItemDesc("");
        	  }else{
        		  bo.setItemDesc(def.getItemDesc());
        	  }
        	  if(def.getItemDesc2()==null){
        		  bo.setItemDesc2("");
        	  }else{
        		  bo.setItemDesc2(def.getItemDesc2());
        	  }
        	  if(def.getUOM()==null){
        		  bo.setUom("");
        	  }else{
        		  bo.setUom(def.getUOM());
        	  }
        	  if(def.getCustIndicatorCode()==null){
        		  bo.setCustIndicatorCode("");
        	  }else{
        		  bo.setCustIndicatorCode(def.getCustIndicatorCode());
        	  }

          }

          bo.setModBy("loader");
          bo.setModDate(DBAccess.toSQLDate(current));
          if(bo.getBackorderId() > 0){
        	  BackorderDataAccess.update(conn, bo);
          }else{
        	  BackorderDataAccess.insert(conn, bo);
          }
          //add new order item action for cancelled items
          if(def.getItemStatus()!=null && def.getItemStatus().equals("*")){

        	  OrderItemActionData oiaD = OrderItemActionData.createValue();

        	  oiaD.setActionCd(RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.CANCELED);
        	  oiaD.setActionDate(current);
        	  oiaD.setAddBy("loader");
        	  oiaD.setOrderId(orderId);
        	  oiaD.setOrderItemId(orderItemId);
        	  if(def.getBackorderQty()>0){
        		  oiaD.setQuantity(def.getBackorderQty());
        	  }

        	  OrderItemActionDataAccess.insert(conn, oiaD);

          }
      }


    /**
     *Loads a budget for either a site or a budget depending on how the budget(cost center) is configured.
     *If the budget is configured for an account then the site may be used as the key, but the sites accoount
     *will be loaded.  This may cause an account budget to be loaded twice with 2 different numbers, but it is unclear
     *what this would mean at this point.
     */
     private void processBudgetDefinitionRequest(BudgetDefinitionRequest def,Connection conn, Map paramMap,
            IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds, int partnerId)
           throws Exception{
    	log.info("processBudgetDefinitionRequest.");
   	    BusEntityDataVector sites = getSitesFromEntityKey(def.getEntityKey(),pStoreIds,pAccountIds, partnerId,conn);
    	if(sites == null || sites.size() == 0){
            log.debug("No sites found for site identfier "+def.getEntityKey());
            //XXX for GCA there are many more budgets than we have, so for now we will just ignore it if we get an extra.
            //this need to be both configurable and for there to be some sort of erro reporting mechanism
            return;
        }else{
            log.debug("sites found for site identfier "+def.getEntityKey());
        }
        IdVector budgetBusEntIdsLoaded = new IdVector();
        CostCenterDataVector masterCcdv = new CostCenterDataVector();
        BudgetUtil bu = new BudgetUtil(conn);
        Set accountIds = new HashSet();
        Iterator it = sites.iterator();
        Map maxPeriodByAccount = new HashMap();
        int bYear = 0;
        while(it.hasNext()){
            BusEntityData site = (BusEntityData) it.next();
            int siteId = site.getBusEntityId();
            int accountId = BusEntityDAO.getAccountForSite(conn,site.getBusEntityId());
            Integer accountIdInt = new Integer(accountId);
            accountIds.add(accountIdInt);
            Integer maxPeriods = (Integer)maxPeriodByAccount.get(accountIdInt);
            if (maxPeriods == null){
            	APIAccess factory = getAPIAccess();
            	Account accBean = factory.getAccountAPI();
            	FiscalCalenderView fcV = accBean.getCurrentFiscalCalenderV(accountId);
            	FiscalCalendarInfo aCal = new FiscalCalendarInfo(fcV);
            	maxPeriods = new Integer(aCal.getNumberOfBudgetPeriods());
            	maxPeriodByAccount.put(accountIdInt, maxPeriods) ;
            }

            Integer budgetYear = BudgetDAO.getCurrentBudgetYear(conn, accountId);

            CostCenterDataVector ccdv = bu.getCostCentersForSite(siteId);
            masterCcdv.addAll(ccdv);

            if (budgetYear != null) {
            	bYear = budgetYear.intValue();
                Iterator ccit = ccdv.iterator();
                while (ccit.hasNext()) {
                    CostCenterData cc = (CostCenterData) ccit.next();
                    if (cc.getShortDesc() == null || def.getBudgetIdentifier() == null || cc.getShortDesc().toLowerCase().indexOf(def.getBudgetIdentifier().toLowerCase().trim()) >= 0) {
                        BudgetViewVector bvv = BudgetDAO.getBudgetsForSite(conn, accountId, site.getBusEntityId(), cc.getCostCenterId(), budgetYear);
                        Iterator biv = bvv.iterator();
                        while (biv.hasNext()) {
                            BudgetView bv = (BudgetView) biv.next();
                            Integer bidKey = new Integer(bv.getBudgetData().getBusEntityId());
                            if (!budgetBusEntIdsLoaded.contains(bidKey)) {
                                budgetBusEntIdsLoaded.add(bidKey);
                                insertUpdateBudgetData(conn, bv, def, cc, bv.getBudgetData().getBusEntityId(), maxPeriods.intValue());
                                //actually load the budget
                            }
                        }
                    }
                }
            } else {
                log.info("The year of budget couldn't be determined.AccountId:" + accountId);
            }
        }
        //we didn't find an existing budget to update, so create new ones
        if(budgetBusEntIdsLoaded.isEmpty() && !sites.isEmpty()){
            if(masterCcdv.isEmpty()){
                //now we would have to create a cost center....
            }
            HashSet processedCostCenters = new HashSet();
            Iterator ccit=masterCcdv.iterator();
            while(ccit.hasNext()){
                CostCenterData cc = (CostCenterData) ccit.next();
                Integer ccKey = new Integer(cc.getCostCenterId());
                if(processedCostCenters.contains(ccKey)){
                    continue;
                }
				if(def.getBudgetIdentifier()==null){
					log.error("Error cost center name/identifier not defined!");
					throw new Exception("Error cost center name/identifier not defined!");
				}
                //if(!(cc.getShortDesc().indexOf(def.getBudgetIdentifier()) >= 0)){
				//if(!cc.getShortDesc().equalsIgnoreCase(def.getBudgetIdentifier())){
                if(cc.getShortDesc().toLowerCase().indexOf(def.getBudgetIdentifier().toLowerCase().trim()) < 0){
                    continue;
                }

                processedCostCenters.add(ccKey);
                if(RefCodeNames.BUDGET_TYPE_CD.ACCOUNT_BUDGET.equals(cc.getCostCenterTypeCd())){
                    BudgetView budget = BudgetUtil.createBudgetView();
                    budget.getBudgetData().setBudgetYear(bYear);
                    for(Iterator iter = accountIds.iterator(); iter.hasNext();) {
                      Integer accountIdI = (Integer) iter.next();
                      insertUpdateBudgetData(conn,budget, def, cc, accountIdI.intValue(), ((Integer)maxPeriodByAccount.get(accountIdI)).intValue());
                    }
                }else if(RefCodeNames.BUDGET_TYPE_CD.SITE_BUDGET.equals(cc.getCostCenterTypeCd())){
                    //loop through the sites and create a budget for each of them that matched the
                    //criteria in the budget definition request
                    Iterator siteIt = sites.iterator();
                    while(siteIt.hasNext()){
                        BusEntityData site = (BusEntityData) siteIt.next();
                        BudgetView budget = BudgetUtil.createBudgetView();
                        budget.getBudgetData().setBudgetYear(bYear);
                        int accountIdI = BusEntityDAO.getAccountForSite(conn,site.getBusEntityId());
                        insertUpdateBudgetData(conn,budget, def, cc, site.getBusEntityId(), ((Integer)maxPeriodByAccount.get(accountIdI)).intValue());
                    }
                }else{
                    log.debug("ERROR: Wrong cost center type: "+cc.getCostCenterTypeCd());
                }
            } // end while(ccit.hasNext()){
        } // end if(budgetBusEntIdsLoaded.isEmpty()){
    }

    /**
     *Handles the actual loading of the budget data request once a corosponding db entry has been found
     *or determined not to exist
     */
    private void insertUpdateBudgetData(Connection pCon,
                                        BudgetView budget,
                                        BudgetDefinitionRequest def,
                                        CostCenterData pCostCenter,
                                        int busEntityId,
                                        int maxPeriods) throws Exception {

        budget.getBudgetData().setBudgetStatusCd(RefCodeNames.BUDGET_STATUS_CD.ACTIVE);
        if(def.getAmountForFuturePeriods() != null){
        	BusEntityDAO bd = new BusEntityDAO();
        	int currPeriod = 0;
        	Date theDate = Utility.addWeekdays(new Date(), 1); //add x days to account for updates at the end of the month
        	if(RefCodeNames.BUDGET_TYPE_CD.ACCOUNT_BUDGET.equals(pCostCenter.getCostCenterTypeCd())){
        		currPeriod = bd.getAccountBudgetPeriod(pCon,busEntityId,0,theDate);//same as below, but busEntityId is an account id here (note param position)
        	}else if(RefCodeNames.BUDGET_TYPE_CD.SITE_BUDGET.equals(pCostCenter.getCostCenterTypeCd())){
        		currPeriod = bd.getAccountBudgetPeriod(pCon,0,busEntityId,theDate);//same as aboce, but busEntityId is a site id here (note param position)
        	}else{
                throw new RuntimeException("ERROR: Wrong cost center type: "+pCostCenter.getCostCenterTypeCd());
            }

            BudgetViewWrapper budgetWrapper = new BudgetViewWrapper(budget);
            for (int period = 1; period <= maxPeriods; period++) {
                log.debug("In loop: " + period + "::" + currPeriod);
                if (currPeriod <= period) {
                    log.debug("Setting with amount of: " + def.getAmountForFuturePeriods());
                    budgetWrapper.setAmount(period, def.getAmountForFuturePeriods());
                }
            }
        	budget = budgetWrapper.getBudget();
    	}else{
    		if(def.isLoadOnlyIfData()){
    			BudgetViewWrapper bvw = new BudgetViewWrapper(budget);
                for (int period = 1; period <= maxPeriods; period++) {
                    BigDecimal amt = def.getAmount(period);
                    if (amt != null) {
                        bvw.setAmount(period, amt);
                    }
                }
    			budget = bvw.getBudget();
    		} else {
                BudgetViewWrapper bvw = new BudgetViewWrapper(budget);
                for (int period = 1; period <= maxPeriods; period++) {
                    BigDecimal amt = def.getAmount(period);
                    if (amt != null) {
                        bvw.setAmount(period, amt);
                    }
                }
                budget = bvw.getBudget();
            }
    	}

        budget.getBudgetData().setModBy("System");
        if(budget.getBudgetData().getBudgetId() == 0){
            log.debug("BudgetDefLoader: inserting new entry");
            budget.getBudgetData().setAddBy("System");
            budget.getBudgetData().setCostCenterId(pCostCenter.getCostCenterId());
            budget.getBudgetData().setBudgetTypeCd(pCostCenter.getCostCenterTypeCd());
            budget.getBudgetData().setBusEntityId(busEntityId);
            BudgetDAO.updateBudget(pCon, budget, "System");
        }else{
            log.debug("BudgetDefLoader: updating entry id: "+budget.getBudgetData().getBudgetId());
            BudgetDAO.updateBudget(pCon, budget, "System");
        }
    }

    /**
     * Process a request to associate a user with anouther entity.  Currently this only
     * supports associating a user with a site (will create the account association
     * automatically when making the site association).
     */
    private void processUserAssocRequest(UserAssocRequestData userAssoc,Connection conn, Map paramMap,
    		IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds)
    throws Exception{
        //These query may need to be revised to make them faster.

    	log.info("processUserAssocRequest.");

    	try{
        long timer = System.currentTimeMillis();
        long totalTimer = timer;
        log.debug("Processing user association user: ["+userAssoc.getCustomerSystemKey()+"] and site ["+userAssoc.getSiteBudgetReference()+"]");
        //find the users this relates to restrict by stores
        String userKey = userAssoc.getCustomerSystemKey();
        IdVector userIds;
        String paramMapKey = "processUserAssocRequest.userKey."+userKey;
        if(paramMap.containsKey(paramMapKey)){
        	log.debug("Using cached User");
            userIds = (IdVector) paramMap.get(paramMapKey);
        }else{
            UserSearchCriteriaData uCrit = new UserSearchCriteriaData();
            uCrit.setCustomerSystemKey(userKey);
            uCrit.setStoreIds(pStoreIds);
            userIds = UserDataAccess.selectIdOnly(conn, UserDAO.convertToDBCriteria(uCrit));
            paramMap.put(paramMapKey,userIds);
        }

        log.debug("Get Users Step:");
        log.debug("timer step 0: "+(System.currentTimeMillis() - timer) );
        timer = System.currentTimeMillis();
        if(userIds == null || userIds.size() ==0){
        	log.debug("users size = "+userIds.size()+" returning");
        	return ;
        }
        //find the site this request relates to restrict by stores
        IdVector siteIds;
        paramMapKey = "processUserAssocRequest.siteRef."+userAssoc.getSiteBudgetReference();
        if(paramMap.containsKey(paramMapKey)){
        	siteIds = (IdVector)paramMap.get(paramMapKey);
            log.debug("Using cached Site");
        }else{
            BusEntitySearchCriteria sCrit = new BusEntitySearchCriteria();
            sCrit.setStoreBusEntityIds(pStoreIds);
            sCrit.addPropertyCriteria(RefCodeNames.PROPERTY_TYPE_CD.SITE_REFERENCE_NUMBER,userAssoc.getSiteBudgetReference()); 
            DBCriteria sDBcrit = BusEntityDAO.convertToDBCriteria(sCrit, RefCodeNames.BUS_ENTITY_TYPE_CD.SITE);
            siteIds = BusEntityDataAccess.selectIdOnly(conn, sDBcrit);
            paramMap.put(paramMapKey,siteIds);
        }

        if (siteIds.size() == 0)
        	return;
        	
        log.debug("Get Sites Step:");
        log.debug("timer step 1: "+(System.currentTimeMillis() - timer));
        timer = System.currentTimeMillis();

        if(siteIds != null){
        	log.debug("sites size = "+siteIds.size());
        }else{
        	log.debug("sites size = null");
        }
        log.debug("users size = "+userIds.size());

        //now we have our sites and we have our users, so make the associations
        Iterator uit = userIds.iterator();
        while(uit.hasNext()){
            int userId = ((Integer) uit.next()).intValue();
            //first associate the user with the found sites
            if(siteIds != null && !siteIds.isEmpty()){
            	log.debug("adding user to site association! userId="+userId+" siteIds="+Utility.toCommaSting(siteIds));
                long timer2 = System.currentTimeMillis();
                UserDAO.addBusEntityAssociations(conn,userId,siteIds,RefCodeNames.BUS_ENTITY_TYPE_CD.SITE,null);
                log.debug("timer step 1a: "+(System.currentTimeMillis() - timer2) );
                timer2 = System.currentTimeMillis();
            }
            log.debug("Associate Users & Sites:");
            log.debug("timer step 2: "+(System.currentTimeMillis() - timer) );
            timer = System.currentTimeMillis();

            //now associate the accounts for the sites which we found
            Iterator sit = siteIds.iterator();
            HashSet accountSet = new HashSet();
            while(sit.hasNext()){
                int sid = ((Integer) sit.next()).intValue();
                paramMapKey = "paramMap.acct.site."+sid;
                Integer ai = (Integer) paramMap.get(paramMapKey);
                if(ai == null){
                    ai = new Integer(BusEntityDAO.getAccountForSite(conn,sid));
                    paramMap.put(paramMapKey,ai);
                }
                paramMapKey = "paramMap.acct.user."+ai+"."+userId;
                if(!paramMap.containsKey(paramMapKey)){
                    //jut add a dummy opbject (the account id) to indicate that we have processed this record already, we don't need to retrive it later
                    paramMap.put(paramMapKey,ai);
                    accountSet.add(ai);
                }
            }

            log.debug("Get Accounts:");
            log.debug("timer step 3: "+(System.currentTimeMillis() - timer));
            timer = System.currentTimeMillis();

            IdVector accts = new IdVector();
            accts.addAll(accountSet);
            if(accts != null && !accts.isEmpty()){
            	log.debug("adding user to accounts association! userId="+userId+" siteIds="+Utility.toCommaSting(accts));
                UserDAO.addBusEntityAssociations(conn,userId,accts,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT,null);
            }
            log.debug("Associate User Accounts:");
            log.debug("timer step 4: "+(System.currentTimeMillis() - timer) );
            timer = System.currentTimeMillis();
        }
        log.debug("total time: "+(System.currentTimeMillis() - totalTimer) );
    	}catch(Exception e){
    		log.error("User Assoc Error Caught:");
    		e.printStackTrace();
    		throw e;
    	}
    }

    /**
     *Processes a userInfoRequest object.  Mostly just deligates to the @see UserBean.updateUser
     */
    private void processUserRequest(UserInfoData user, Connection conn, Map paramMap,
    		IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds)
    throws Exception{

    	log.info("processUserRequest.");
        if(user.getUserData().getUserId() == 0){
            //DBCriteria crit = new DBCriteria();
            UserSearchCriteriaData crit = new UserSearchCriteriaData();
            crit.setUserName(user.getUserData().getUserName());
            crit.setStoreIds(pStoreIds);
            crit.setUserNameMatch(User.NAME_EXACT);
            UserDataVector udv = UserDAO.getUsersCollectionByCriteria(conn, crit);
            if(udv.size() > 1){
                throw new RemoteException("Found "+udv.size()+" users for name: "+user.getUserData().getUserName());
            }else if(udv.size() == 1){
                UserData currUser = (UserData)udv.get(0);
                UserData loadUser = user.getUserData();
                user.setUserData(currUser);


                //copy over any properties from the found user.  This effectivly states
                //what the loader will be able to overide versus the UI
                if(Utility.isSet(loadUser.getFirstName())){
                	currUser.setFirstName(loadUser.getFirstName());
                }
                if(Utility.isSet(loadUser.getLastName())){
                	currUser.setLastName(loadUser.getLastName());
                }
                if(Utility.isSet(loadUser.getPassword())){
                	currUser.setPassword(loadUser.getPassword());
                }
            }else{
            	user.getUserData().setEffDate(new Date());
            }
        }

        if(!Utility.isSet(user.getUserData().getUserTypeCd())){
            user.getUserData().setUserTypeCd(RefCodeNames.USER_TYPE_CD.MSB);
        }
        UserRightsTool rights = new UserRightsTool(user.getUserData());
        rights.setNoReporting(!Utility.isTrue(user.getUserHasReportingDefault()));
        rights.setBrowseOnly(!Utility.isTrue(user.getUserCanShopDefault()));
        rights.setCanApprovePurchases(Utility.isTrue(user.getUserApprovalLevelDefault()));
        if(rights.canApprovePurchases()){
            user.getUserData().setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER);
        }
        //setup the impleied rights only for new users (in other words allow our UI to overide these settings)
        if(!Utility.isSet(user.getUserData().getUserRoleCd())){
            if(rights.canApprovePurchases()){
                rights.setEmailForApproval(true);
            }else{
                rights.setEmailForApproval(true);
                rights.setEmailOrderApproved(true);
                rights.setEmailOrderModifications(true);
                rights.setEmailOrderRejection(true);
            }
            rights.setOnAccount(true);
            rights.setPoNumRequired(false);
            rights.setShowPrice(true);
            rights.setUserOnContract(true);
            user.getUserData().setUserRoleCd(rights.makePermissionsToken());
        }




        if(!Utility.isSet(user.getUserData().getPrefLocaleCd())){
        	//TODO lookup from trading profile
        	user.getUserData().setPrefLocaleCd("en_US");
        }
        if(!Utility.isSet(user.getUserData().getWorkflowRoleCd())){
             if(rights.canApprovePurchases()){
                user.getUserData().setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER);
            }else{
        	user.getUserData().setWorkflowRoleCd("UNKNOWN");
            }
        }


        log.debug(user.getUserData().toString());
        UserBean usrBean = new UserBean();
        usrBean.updateUserInfo(conn, user);
        UserDAO.addBusEntityAssociations(conn,user.getUserData().getUserId(),pStoreIds,RefCodeNames.USER_ASSOC_CD.STORE,"system");
    }

    /**
     * <code>processOrderRequest</code>
     *
     * @param pOrderReq an <code>OrderRequestData</code> value
     * @return a <code>ProcessOrderResultData</code> value
     * @exception RemoteException if an error occurs
     * @exception BudgetRuleException if an error occurs
     */
    private ProcessOrderResultData processOrderRequest(OrderRequestData pOrderReq,
                                                       Connection con)
                                                throws RemoteException,
                                                       BudgetRuleException,
                                                       OrderTotalException,
                                                       Exception {
    	log.info("processOrderRequest.");
        setDebugOn();
        OrderRequestActor reqact = new OrderRequestActor(pOrderReq);

        return reqact.process(con);
    }

    /**
     * <code>processOrderRequest</code>
     *
     * @param pOrderReq an <code>OrderRequestData</code> value
     * @return a <code>ProcessOrderResultData</code> value
     * @exception RemoteException if an error occurs
     * @exception BudgetRuleException if an error occurs
     */
    public ProcessOrderResultData processOrderRequest(OrderRequestData pOrderReq)
                                               throws RemoteException,
                                                      BudgetRuleException,
                                                      OrderTotalException {

        Connection conn = null;

        log.info("processOrderRequest.");
        try {
            conn = getConnection();
            OrderRequestActor reqact = new OrderRequestActor(pOrderReq);
            return reqact.process(conn);
        } catch (SQLException e) {
            e.printStackTrace();
            log.error(" 8103 processOrderRequest: " + e);
            throw new RemoteException("Database error", e);
        } catch (Exception e) {
            e.printStackTrace();
            log.error(" 8104 processOrderRequest: " + e);
            throw new RemoteException("Processing fault 1", e);
        } finally {
            closeConnection(conn);
        }
    }

    /**
     * <code>fetchOrderFulfillmentRequests</code>
     *
     * @param pErpNumDistributor a <code>String</code> value
     * @param pReserveEntries a <code>boolean</code> value
     * @return an <code>OrderFulfillmentData</code> value
     * @exception RemoteException if an error occurs
     */
    public OrderFulfillmentData fetchOrderFulfillmentRequests(String pErpNumDistributor,
                                                              boolean pReserveEntries)
                                                       throws RemoteException {

        // Get the order items in a pending fulfilment state
        // for the distributor specified.
        OrderFulfillmentData ofd = OrderFulfillmentData.createValue();
        ofd.setErpNumDistributor(pErpNumDistributor);

        Connection conn = null;

        try {
            conn = getConnection();

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(OrderItemDataAccess.DIST_ERP_NUM,
                           pErpNumDistributor);
            dbc.addNotEqualTo(OrderItemDataAccess.ORDER_ITEM_STATUS_CD,
                              RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT);

            String sqlExcluededPoNums = OrderItemDataAccess.getSqlSelectIdOnly(
                                                OrderItemDataAccess.ERP_PO_NUM,
                                                dbc);
            DBCriteria dbc1 = new DBCriteria();
            dbc1.addEqualTo(OrderItemDataAccess.DIST_ERP_NUM,
                            pErpNumDistributor);
            dbc1.addEqualTo(OrderItemDataAccess.ORDER_ITEM_STATUS_CD,
                            RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT);
            dbc1.addNotOneOf(OrderItemDataAccess.ERP_PO_NUM,
                             sqlExcluededPoNums);

            OrderItemDataVector v = OrderItemDataAccess.select(conn, dbc1);
            ofd.setEntriesCollection(v);
        } catch (Exception e) {
            log.error("fetchOrderFulfillmentRequests, error: " + e);
        } finally {
        	closeConnection(conn);
        }

        return ofd;
    }

    private void updateOrderState(Connection pConn, int pOrderId,
                                  String pOrderStatusCd)
                           throws SQLException {

        if (pOrderStatusCd.equals(RefCodeNames.ORDER_STATUS_CD.ORDERED)) {

            String updateSql = " update " + OrderDataAccess.CLW_ORDER +
                               " set " + OrderDataAccess.ORDER_STATUS_CD +
                               " = '" + pOrderStatusCd + "' , " +
                               OrderDataAccess.EXCEPTION_IND + " = 'N' " +
                               " where " + OrderDataAccess.ORDER_ID + " = " +
                               pOrderId;
            Statement stmt = pConn.createStatement();
            stmt.executeQuery(updateSql);
            stmt.close();

            String updateSql2 = " update " +
                                OrderItemDataAccess.CLW_ORDER_ITEM +
                                " set " +
                                OrderItemDataAccess.ORDER_ITEM_STATUS_CD +
                                " = '" +
                                RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_ERP_PO +
                                "' where " + OrderDataAccess.ORDER_ID +
                                " = " + pOrderId;
            Statement stmt2 = pConn.createStatement();
            stmt2.executeQuery(updateSql2);
            stmt2.close();
        } else if (pOrderStatusCd.equals(
                           RefCodeNames.ORDER_STATUS_CD.PROCESS_ERP_PO)) {

            String updateSql = " update " + OrderDataAccess.CLW_ORDER +
                               " set " + OrderDataAccess.ORDER_STATUS_CD +
                               " = '" + pOrderStatusCd + "' , " +
                               OrderDataAccess.EXCEPTION_IND + " = 'N' " +
                               " where " + OrderDataAccess.ORDER_ID + " = " +
                               pOrderId + " and " +
                               OrderDataAccess.ORDER_STATUS_CD + " = '" +
                               RefCodeNames.ORDER_STATUS_CD.ORDERED + "'";
            Statement stmt = pConn.createStatement();
            stmt.executeQuery(updateSql);
            stmt.close();

            String updateSql2 = " update " +
                                OrderItemDataAccess.CLW_ORDER_ITEM +
                                " set " +
                                OrderItemDataAccess.ORDER_ITEM_STATUS_CD +
                                " = '" +
                                RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_ERP_PO +
                                "' where " + OrderDataAccess.ORDER_ID +
                                " = " + pOrderId;
            Statement stmt2 = pConn.createStatement();
            stmt2.executeQuery(updateSql2);
            stmt2.close();
        } else if (pOrderStatusCd.equals(RefCodeNames.ORDER_STATUS_CD.INVOICED)) {

            // Orders can only update to this status if all the
            // order items have been cancelled or invoiced.
            String checkSql = "select count(*) from " +
                              OrderItemDataAccess.CLW_ORDER_ITEM +
                              " where " + OrderDataAccess.ORDER_ID + " = " +
                              pOrderId + " and " +
                              OrderItemDataAccess.ORDER_ITEM_STATUS_CD +
                              " not in ( " + "'" +
                              RefCodeNames.ORDER_STATUS_CD.INVOICED + "'," +
                              "'" + RefCodeNames.ORDER_STATUS_CD.CANCELLED +
                              "'" + ")";
            Statement stmt = pConn.createStatement();
            ResultSet rs = stmt.executeQuery(checkSql);
            int rescount = 0;

            if (rs.next()) {
                rescount = rs.getInt(1);
            }

            stmt.close();

            if (rescount == 0) {

                // No items pending any processing.
                String updateSql = " update " + OrderDataAccess.CLW_ORDER +
                                   " set " +
                                   OrderDataAccess.ORDER_STATUS_CD + " = '" +
                                   pOrderStatusCd + "' where " +
                                   OrderDataAccess.ORDER_ID + " = " +
                                   pOrderId + " and " +
                                   OrderDataAccess.ORDER_STATUS_CD + " = '" +
                                   RefCodeNames.ORDER_STATUS_CD.PROCESS_ERP_PO +
                                   "'";
                Statement stmt2 = pConn.createStatement();
                stmt2.executeQuery(updateSql);
                stmt2.close();
            }
        } else if (pOrderStatusCd.equals(
                           RefCodeNames.ORDER_STATUS_CD.PENDING_REVIEW)) {

            String updateSql = " update " + OrderDataAccess.CLW_ORDER +
                               " set " + OrderDataAccess.ORDER_STATUS_CD +
                               " = '" + pOrderStatusCd + "' , " +
                               OrderDataAccess.EXCEPTION_IND + " = 'Y' " +
                               " where " + OrderDataAccess.ORDER_ID + " = " +
                               pOrderId;
            Statement stmt = pConn.createStatement();
            stmt.executeQuery(updateSql);
            stmt.close();
        } else {

            String updateSql = " update " + OrderDataAccess.CLW_ORDER +
                               " set " + OrderDataAccess.ORDER_STATUS_CD +
                               " = '" + pOrderStatusCd + "'" + " where " +
                               OrderDataAccess.ORDER_ID + " = " + pOrderId;
            Statement stmt = pConn.createStatement();
            stmt.executeQuery(updateSql);
            stmt.close();
        }

        return;
    }

    private void updateOrderItem(Connection pConn, Integer pOrderItemId,
                                 String pOrderItemStatusCd,
                                 boolean pSetTestValues)
                          throws SQLException {

        String updateSql2 = " update " + OrderItemDataAccess.CLW_ORDER_ITEM +
                            " set " +
                            OrderItemDataAccess.ORDER_ITEM_STATUS_CD +
                            " = '" + pOrderItemStatusCd + "' ";

        if (pSetTestValues) {

            java.util.Date current = new java.util.Date(System.currentTimeMillis());
            java.sql.Date sqldate = new java.sql.Date(current.getTime());
            java.sql.Time sqltime = new java.sql.Time(current.getTime());
            updateSql2 += ", " + OrderItemDataAccess.ERP_ORDER_LINE_NUM + " = " + OrderItemDataAccess.CUST_LINE_NUM + ", " + OrderItemDataAccess.ERP_ORDER_NUM + " = '" + (pOrderItemId.intValue() * 10) + "', " + OrderItemDataAccess.ERP_PO_NUM + " = '" + ((pOrderItemId.intValue() * 10) + 1) + "', " + OrderItemDataAccess.ERP_PO_DATE + " = TO_DATE('" + sqldate + "', 'YYYY-MM-DD') , " + OrderItemDataAccess.ERP_PO_TIME + " = TO_DATE('" + sqltime + "', 'HH24:MI:SS') ";
        }

        updateSql2 += " where " + OrderItemDataAccess.ORDER_ITEM_ID + " = " + pOrderItemId.intValue();
        log.debug("1009: updateOrderItem: " + updateSql2);

        Statement stmt2 = pConn.createStatement();
        stmt2.executeQuery(updateSql2);
        stmt2.close();

        return;
    }

    private void testSendToERP() {

        Connection conn = null;

        try {
            conn = getConnection();

            LinkedList orders = getOrdersByStatus(conn,
                                                  RefCodeNames.ORDER_STATUS_CD.ORDERED);
            log.debug("TEST: START: testSendToERP ");

            for (int idx = 0; idx < orders.size(); idx++) {

                Integer oId = (Integer)orders.get(idx);
                log.debug("TEST: order id to process: " + oId);
                updateOrderState(conn, oId.intValue(),
                                 RefCodeNames.ORDER_STATUS_CD.PROCESS_ERP_PO);
            }
        } catch (Exception e) {
            log.error("getOrdersByStatus, error: " + e);
        } finally {
        	closeConnection(conn);
        }

        log.debug("TEST: DONE: testSendToERP ");
    }

    private void testPoFromERP() {

        Connection conn = null;

        try {
            conn = getConnection();

            LinkedList oitems = getOrderItemsByStatus(conn,
                                                      RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_ERP_PO);
            log.debug("TEST: START: testPoFromERP ");

            for (int idx = 0; idx < oitems.size(); idx++) {

                Integer oItemId = (Integer)oitems.get(idx);
                log.debug("TEST: order id to process: " + oItemId);

                boolean setTestValues = true;
                updateOrderItem(conn, oItemId,
                                RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT,
                                setTestValues);
            }
        } catch (Exception e) {
            log.error("testPoFromERP, error: " + e);
        } finally {
        	closeConnection(conn);
        }

        log.debug("TEST: DONE: testPoFromERP ");
    }

    private int testCreateCustInvoices(int pOrderId) {

        Connection conn = null;

        try {
            conn = getConnection();

            DBCriteria dbc = new DBCriteria();
            OrderData od = OrderDataAccess.select(conn, pOrderId);
            InvoiceCustData icd = InvoiceCustData.createValue();
            icd.setOrderId(od.getOrderId());
            icd.setInvoiceNum(String.valueOf(od.getOrderId() + 310));
            icd.setInvoiceDate(new Date());
            icd.setErpSystemCd(od.getErpSystemCd());
            icd.setStoreId(od.getStoreId());
            icd = InvoiceCustDataAccess.insert(conn, icd);
            dbc = new DBCriteria();
            dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, pOrderId);

            OrderItemDataVector oidv = OrderItemDataAccess.select(conn, dbc);

            // Create an invoice distributor entry.
            for (int i = 0; i < oidv.size(); i++) {

                OrderItemData oid = (OrderItemData)oidv.get(i);
                InvoiceCustDetailData icdd = InvoiceCustDetailData.createValue();
                icdd.setInvoiceCustId(icd.getInvoiceCustId());
                icdd.setItemSkuNum(oid.getItemSkuNum());
                icdd.setItemShortDesc(oid.getItemShortDesc());
                icdd.setItemUom(oid.getItemUom());
                icdd.setItemPack(oid.getItemPack());
                icdd.setItemQuantity(oid.getTotalQuantityOrdered());
                InvoiceCustDetailDataAccess.insert(conn, icdd);
            }

            return icd.getInvoiceCustId();
        } catch (Exception e) {
            log.error("testCreateCustInvoices, error: " + e);
        } finally {
        	closeConnection(conn);
        }

        log.debug("TEST: DONE: testCreateCustInvoices ");

        return 0;
    }

    private int testCreateDistInvoices(int pOrderId) {

        Connection conn = null;

        try {
            conn = getConnection();

            DBCriteria dbc = new DBCriteria();
            OrderData od = OrderDataAccess.select(conn, pOrderId);
            InvoiceDistData idd = InvoiceDistData.createValue();
            idd.setOrderId(od.getOrderId());
            idd.setDistOrderNum(String.valueOf(od.getOrderId() + 300));
            idd.setInvoiceNum(String.valueOf(od.getOrderId() + 310));
            idd.setInvoiceDate(new Date());
            idd.setTrackingNum(String.valueOf(310));
            idd.setTrackingType("GPS");
            idd.setDistShipmentNum(String.valueOf(System.currentTimeMillis()));
            idd.setCarrier("WE SHIPEM");
            idd.setStoreId(od.getStoreId());
            idd.setErpSystemCd(od.getErpSystemCd());
            idd = InvoiceDistDataAccess.insert(conn, idd);
            dbc = new DBCriteria();
            dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, pOrderId);

            OrderItemDataVector oidv = OrderItemDataAccess.select(conn, dbc);

            // Create an invoice distributor entry.
            for (int i = 0; i < oidv.size(); i++) {

                OrderItemData oid = (OrderItemData)oidv.get(i);
                InvoiceDistDetailData idid = InvoiceDistDetailData.createValue();
                idid.setInvoiceDistId(idd.getInvoiceDistId());
                idid.setDistItemSkuNum(oid.getDistItemSkuNum());
                idid.setDistItemShortDesc(oid.getItemShortDesc());
                idid.setDistItemUom(oid.getDistItemUom());
                idid.setDistItemPack(oid.getDistItemPack());
                idid.setDistItemQuantity(oid.getTotalQuantityOrdered());
                idid.setItemSkuNum(oid.getItemSkuNum());
                idid.setItemShortDesc(oid.getItemShortDesc());
                idid.setItemUom(oid.getItemUom());
                idid.setItemPack(oid.getItemPack());
                idid.setItemQuantity(oid.getTotalQuantityOrdered());
                InvoiceDistDetailDataAccess.insert(conn, idid);
            }

            return idd.getInvoiceDistId();
        } catch (Exception e) {
            log.error("testCreateDistInvoices, error: " + e);
        } finally {
        	closeConnection(conn);
        }

        log.debug("TEST: DONE: testCreateDistInvoices ");

        return 0;
    }

    private LinkedList getOrdersByStatus(Connection pConn,
                                         String pOrderStatusCd)
                                  throws SQLException {

        LinkedList orders = new LinkedList();
        /*String sql = " select distinct oi." + OrderItemDataAccess.ORDER_ID +
                     " from " + OrderItemDataAccess.CLW_ORDER_ITEM +
                     " oi , " + OrderDataAccess.CLW_ORDER + " o " +
                     " where o." + OrderDataAccess.ORDER_STATUS_CD + " = '" +
                     pOrderStatusCd + "' and o." + OrderDataAccess.ORDER_ID +
                     " = " + " oi." + OrderItemDataAccess.ORDER_ID +
                     " order by oi." + OrderItemDataAccess.ORDER_ID;*/
        String sql = " select distinct oi." + OrderItemDataAccess.ORDER_ID +
                     " from " + OrderItemDataAccess.CLW_ORDER_ITEM +
                     " oi , " + OrderDataAccess.CLW_ORDER + " o " +
                     " where o." + OrderDataAccess.ORDER_STATUS_CD + " = ? " +
                     " and o." + OrderDataAccess.ORDER_ID +
                     " = " + " oi." + OrderItemDataAccess.ORDER_ID +
                     " order by oi." + OrderItemDataAccess.ORDER_ID;

        PreparedStatement stmt = pConn.prepareStatement(sql);
        stmt.setString(1, pOrderStatusCd);
        ResultSet rs = stmt.executeQuery();

        while (rs.next()) {

            int n = rs.getInt(1);

            if (n >= 0) {
                log.debug("adding order id: " + n);
                orders.add(new Integer(n));
            }
        }

        stmt.close();

        return orders;
    }

    private LinkedList getOrderItemsByStatus(Connection pConn,
                                             String pOrderItemStatusCd)
                                      throws SQLException {

        LinkedList orders = new LinkedList();
        String sql = " select distinct " +
                     OrderItemDataAccess.ORDER_ITEM_ID + " from " +
                     OrderItemDataAccess.CLW_ORDER_ITEM + " where " +
                     OrderItemDataAccess.ORDER_ITEM_STATUS_CD + " =  ?";
                     //                     pOrderItemStatusCd + "'";
        PreparedStatement stmt = pConn.prepareStatement(sql);
        stmt.setString(1, pOrderItemStatusCd);
        ResultSet rs = stmt.executeQuery();

        while (rs.next()) {

            int n = rs.getInt(1);

            if (n >= 0) {
                log.debug("adding order item id: " + n);
                orders.add(new Integer(n));
            }
        }

        stmt.close();

        return orders;
    }

    /**
     *  <code>sendOrderRequestsToERP</code>
     * Send order requests to the ERP system for
     * construction of a PO. All orders that have an
     * approved status is sent.
     *
     * @param pProcessFlag a <code>String</code> value
     * @exception RemoteException if an error occurs
     */
    public void sendOrderRequestsToERP(String pProcessFlag)
                                throws RemoteException {
        log.info("sendOrderRequestsToERP process flag: " + pProcessFlag);

        try {

            if (pProcessFlag.equals("test")) {

                // Turn on debug level log entries.
                setDebugOn();
                testSendToERP();
            }
        } catch (Exception e) {
            log.error("sendOrderRequestsToERP: " + e);
            throw new RemoteException("error: " + e);
        }

        return;
    }

    /**
     *  <code>processOrderResponseFromERP</code>
     * Process POs from the ERP system.
     *
     * @param pProcessFlag a <code>String</code> value
     * @exception RemoteException if an error occurs
     */
    public void processOrderResponseFromERP(String pProcessFlag)
                                     throws RemoteException {
        log.info("processResponseFromERP.process flag: " + pProcessFlag);

        try {

            if (pProcessFlag.equals("test")) {

                // Turn on debug level log entries.
                setDebugOn();
                testPoFromERP();
            }
        } catch (Exception e) {
            log.error("processResponseFromERP: " + e);
            throw new RemoteException("error: " + e);
        }

        return;
    }

    public int sendInvoicesToERP(int pOrderId, String pProcessFlag)
                          throws RemoteException {
        log.info("sendInvoicesToERP process flag: " + pProcessFlag);

        if (pProcessFlag.equals("test")) {

            return testCreateDistInvoices(pOrderId);
        }

        return 0;
    }

    public int processInvoicesReleasedFromERP(int pOrderId,
                                              String pProcessFlag)
                                       throws RemoteException {
        log.info("processInvoicesReleasedFromERP process flag: " +pProcessFlag);

        if (pProcessFlag.equals("test")) {

            return testCreateCustInvoices(pOrderId);
        }

        return 0;
    }

    public ProcessOrderResultData reprocessOrderRequest(int pOrderId,
                                                        String pOptionalOrderStatus,
                                                        String userName)
                                                 throws RemoteException,
                                                        BudgetRuleException {
log.info("reprocessOrderRequest.");

        ProcessOrderResultData checkRes = ProcessOrderResultData.createValue();
/////////////////////////////////////////////////////////////////////////////////////////////
        Connection conn = null;
        try {
          conn= getConnection();
        }catch (Exception exc) {
          String mess = "No DB connection ";
          exc.printStackTrace();
          throw new RemoteException (mess+exc.getMessage());
        }
        User userEjb = null;
        try {
          APIAccess factory = getAPIAccess();
          userEjb = factory.getUserAPI();
        } catch (Exception exc) {
          String mess = "No User Ejb access";
          exc.printStackTrace();
          throw new RemoteException (mess+exc.getMessage());
        }
        String workflowRole = RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN;
        if(!userName.equalsIgnoreCase("System")) {
          try {
            UserData userD = userEjb.getUserByName(userName,0);
            workflowRole = userD.getWorkflowRoleCd();
          } catch (Exception exc) {
            String mess = "Can't find user data. User name: "+userName;
            exc.printStackTrace();
            throw new RemoteException (mess+exc.getMessage());
          }
        }else{
          workflowRole = RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER;
        }
        boolean reprocessPipelineFl = false;
        try {
          reprocessPipelineFl = isPipelineActive(conn,RefCodeNames.PIPELINE_CD.REPROCESS_ORDER);
        }catch (SQLException exc) {
          exc.printStackTrace();
          //Go old way
        }
        if(reprocessPipelineFl) {
          if(RefCodeNames.ORDER_STATUS_CD.DUPLICATED.equals(pOptionalOrderStatus) ||
             RefCodeNames.ORDER_STATUS_CD.REJECTED.equals(pOptionalOrderStatus) ||
             RefCodeNames.ORDER_STATUS_CD.CANCELLED.equals(pOptionalOrderStatus) ||
             RefCodeNames.ORDER_STATUS_CD.PENDING_ORDER_REVIEW.equals(pOptionalOrderStatus) ||
             RefCodeNames.ORDER_STATUS_CD.PENDING_REVIEW.equals(pOptionalOrderStatus))
             {
            //So far would not check anything
            //(not really correct: may be invoiced or under Lawson processing)
            OrderBean ob = new OrderBean();
            OrderData orderD = null;
            try {
              orderD = OrderDataAccess.select(conn, pOrderId);
              ob.updateOrderInfo(pOrderId, pOptionalOrderStatus,userName);
              checkRes.setOrderId(pOrderId);
              checkRes.setOKFlag(true);
              //checkRes.setOrderStatusCd(pOptionalOrderStatus);

              checkRes.setOrderDate(orderD.getOriginalOrderDate());
              checkRes.setOrderStatusCd(orderD.getOrderStatusCd());
              checkRes.setOrderNum(orderD.getOrderNum());

              checkRes.setSiteId(orderD.getSiteId());
              checkRes.setAccountId(orderD.getAccountId());
              return checkRes;
            }catch(Exception exc) {
            	exc.printStackTrace();
              throw new RemoteException(exc.getMessage());
            }
          } else {
            //Do reprocess pipeline
            try {
              OrderPipelineBaton baton = new OrderPipelineBaton();
              OrderData orderD = OrderData.createValue();
              orderD.setOrderId(pOrderId);
              baton.setOrderData(orderD);
              baton.setOrderStatus(pOptionalOrderStatus);
              baton.setBatonNumber(0);
              baton.setUserName(userName);
              baton.setUserWorkflowRoleCd(workflowRole);
              baton.setBypassWkflRuleActionCd("");
              OrderPipelineActor pipelineActor = new OrderPipelineActor();
              OrderPipelineBaton[] pipelineResult =
                   pipelineActor.processPipeline(
                     baton,
                     RefCodeNames.PIPELINE_CD.REPROCESS_ORDER,
                     conn,
                     getAPIAccess());
              if(pipelineResult.length>0) {
                orderD = baton.getOrderData();
                checkRes.setSiteId(orderD.getSiteId());
                checkRes.setAccountId(orderD.getAccountId());
                checkRes.setOrderId(orderD.getOrderId());
                checkRes.setOrderNum(orderD.getOrderNum());
                checkRes.setOrderDate(orderD.getOriginalOrderDate());
                checkRes.setOrderStatusCd(orderD.getOrderStatusCd());
                checkRes.setOKFlag(true);
                HashMap errors = baton.getErrors();
                Collection errorVals = errors.values();
                Iterator errorIter = errorVals.iterator();
                while (errorIter.hasNext()) {
                  ArrayList errorAL = (ArrayList) errorIter.next();
                  Iterator it = errorAL.iterator();
                  while (it.hasNext()) {
                   OrderPipelineBaton.OrderError oe =
                               (OrderPipelineBaton.OrderError) it.next();
                   checkRes.addResponseMsg(oe.text);

                  }
                  checkRes.setOKFlag(false);
                }
                //Make reprocess note
                String resultOrderStatus = orderD.getOrderStatusCd();
                OrderPropertyData opD = OrderPropertyData.createValue();
                opD.setOrderId(orderD.getOrderId());
                opD.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE);
                opD.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                opD.setShortDesc("OrderReprocessed");
    	          String mx = "Order reprocessed on: " + new Date() +
                " new status is: " + resultOrderStatus;
                opD.setValue(mx);
	              opD.setAddBy(userName);
	              opD.setModBy(userName);
                OrderPropertyDataAccess.insert(conn,opD);
                //
                if(pipelineResult.length>1) {
                  //Do not have such processing so far
                  String mess = "Something wrong with order processing. "+
                    "Order request generated  "+
                      pipelineResult.length +" orders";
                    throw new RemoteException(mess);
                }
              } else {
                String mess = "Program error in reprocess pipeline. No results returned. "+
                  "Order id: "+pOrderId;
                throw new RemoteException(mess);
              }
            }catch (Exception exc) {
                throw processException(exc);
            }finally {
        	    closeConnection(conn);
            }

            return checkRes;
          }
        }
/////////////////////////////////////////////////////////////////////////////////////////////
        if (!RefCodeNames.ORDER_STATUS_CD.DUPLICATED.equals(
                     pOptionalOrderStatus)) {
            checkRes = p_checkOrderRequest(pOrderId);
            if (!checkRes.isOK()) {

                // Don't migrate the order status.
                checkRes.setOrderStatusCd
                    (RefCodeNames.ORDER_STATUS_CD.PENDING_ORDER_REVIEW);
                log.info("reprocessOrderRequest returning: " + checkRes);
                return checkRes;
            }
        }

        boolean doWorkflow = true, dojc = true;
        if (RefCodeNames.ORDER_STATUS_CD.CANCELLED.equals(pOptionalOrderStatus)||
            RefCodeNames.ORDER_STATUS_CD.DUPLICATED.equals(pOptionalOrderStatus)  ||
            RefCodeNames.ORDER_STATUS_CD.REJECTED.equals(pOptionalOrderStatus) ||
            RefCodeNames.ORDER_STATUS_CD.PENDING_REVIEW.equals(pOptionalOrderStatus) ) {
            doWorkflow = false;
        }

        OrderJoinData ojd = new OrderJoinData();

        try {

            APIAccess factory = getAPIAccess();
            OrderBean ob = new OrderBean();
            Order ordBean = factory.getOrderAPI();

            // Check the Workflow rules.
            WorkflowRuleResult wres = null;
            ojd = ordBean.fetchOrder(pOrderId);

            OrderData ord = ojd.getOrderData();
            String orderTypeCd = ord.getOrderTypeCd();
            String currOrderStatus = ord.getOrderStatusCd();
            if (  currOrderStatus.equals
              (RefCodeNames.ORDER_STATUS_CD.ERP_REJECTED) ) {
              // This order was rejected after it had been approved.
              // Don't go throw the workflow again.
              doWorkflow = false;
              dojc = false;
            }

            if(RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER.equals(workflowRole)) {
              doWorkflow = false;
            }

            int siteId = ord.getSiteId();
            int accountId = ord.getAccountId();

            if (doWorkflow) {
                // When reprocessing an order, force the
                // order to go through the workflow for the
                // site.
                ord.setWorkflowStatusCd("reprocess");
                log.debug(" reprocess the order, send to workflow" );

                OrderItemDataVector oidv =
                    OrderDAO.getOrderItems(conn, pOrderId);

                wres = checkOrderWorkflow(conn,
                        siteId,
                        accountId,
                        ord,
                        oidv,
                        RefCodeNames.WORKFLOW_RULE_ACTION.STOP_ORDER);

                if (wres.isOK()) {
                    pOptionalOrderStatus =
                    (RefCodeNames.ORDER_TYPE_CD.TO_BE_CONSOLIDATED.
                                             equals(orderTypeCd))?
                    RefCodeNames.ORDER_STATUS_CD.PENDING_CONSOLIDATION:
                    RefCodeNames.ORDER_STATUS_CD.ORDERED;
                } else if (wres.isPendingReview()) {
                    // This order had been stopped and now needs to go forward.
                    pOptionalOrderStatus =
                    (RefCodeNames.ORDER_TYPE_CD.TO_BE_CONSOLIDATED.
                                             equals(orderTypeCd))?
                    RefCodeNames.ORDER_STATUS_CD.PENDING_CONSOLIDATION:
                    RefCodeNames.ORDER_STATUS_CD.ORDERED;
                } else if (wres.isPending()) {
                    pOptionalOrderStatus = RefCodeNames.ORDER_STATUS_CD.PENDING_APPROVAL;
                } else {
                    pOptionalOrderStatus = RefCodeNames.ORDER_STATUS_CD.PENDING_REVIEW;
                }
            }
            ojd = ob.updateOrderInfo(pOrderId, pOptionalOrderStatus,
                                     userName);
            checkRes.setOrderStatusCd(pOptionalOrderStatus);

            String note = "Exception(s) cleared on: " + new Date();
            OrderDAO.enterOrderProperty(conn,
                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                               "ExceptionCleared", note, pOrderId, 0, 0, 0, 0,
                               0, 0, userName);

            //update janitors closet
            if (dojc && pOptionalOrderStatus.equals
		(RefCodeNames.ORDER_STATUS_CD.ORDERED)) {
                updateJanitorsCloset(ojd);
            }
        } catch (Exception e) {
            e.printStackTrace();
            String msg = "Reprocess failed for order id: " + pOrderId+ " "+e.getMessage();
            log.error(" 95  " + msg + "\n error: " + e);
            throw new RemoteException(msg);
        } finally {
	    closeConnection(conn);
        }

        return checkRes;
    }

    public void checkOrders()
                     throws RemoteException {
        log.debug("checkOrders was called");

        return;
    }

    /**
     * Finds the distributor for this item given a list of possible distributors, the
     * distributor sku and catalogId.  Used in the 855 order creation process to narrow down to the actual
     * mapping record.
     * @param catalogId
     * @return the item mappings records
     */
    private ItemMappingDataVector getDistributorMappingForDistSku(Connection con, String distSku, String distUom, IdVector pDistIds, int catalogId) throws SQLException{
    	DBCriteria crit = new DBCriteria();
    	crit.addEqualTo(ItemMappingDataAccess.ITEM_NUM, distSku);
    	if(Utility.isSet(distUom)){
    		crit.addEqualTo(ItemMappingDataAccess.ITEM_UOM, distUom);
    	}
    	crit.addOneOf(ItemMappingDataAccess.BUS_ENTITY_ID, pDistIds);
    	crit.addEqualTo(ItemMappingDataAccess.ITEM_MAPPING_CD, RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
    	crit.addJoinCondition(ItemMappingDataAccess.CLW_ITEM_MAPPING, ItemMappingDataAccess.ITEM_ID, CatalogStructureDataAccess.CLW_CATALOG_STRUCTURE, ItemDataAccess.ITEM_ID);
    	crit.addJoinTableEqualTo(CatalogStructureDataAccess.CLW_CATALOG_STRUCTURE, CatalogStructureDataAccess.CATALOG_ID, catalogId);

    	log.info(ItemMappingDataAccess.getSqlSelectIdOnly("*", crit));
    	return ItemMappingDataAccess.select(con, crit);
    }

    /**
     * Finds the distributor for this item given a list of possible distributors and the
     * distributor sku.  Used in the 855 order creation process to narrow down to the actual
     * mapping record.
     * @return the item mappings records
     */
    private ItemMappingDataVector getManufactureMappingBySku(Connection con, String manufId, int pManufId) throws SQLException{
    	DBCriteria crit = new DBCriteria();
    	crit.addEqualTo(ItemMappingDataAccess.ITEM_NUM, manufId);

    	crit.addEqualTo(ItemMappingDataAccess.BUS_ENTITY_ID, pManufId);
    	crit.addEqualTo(ItemMappingDataAccess.ITEM_MAPPING_CD, RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER);
    	crit.addJoinCondition(ItemMappingDataAccess.CLW_ITEM_MAPPING, ItemMappingDataAccess.ITEM_ID, ItemDataAccess.CLW_ITEM, ItemDataAccess.ITEM_ID);
    	crit.addJoinTableEqualTo(ItemDataAccess.CLW_ITEM, ItemDataAccess.ITEM_STATUS_CD,RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    	log.info(ItemMappingDataAccess.getSqlSelectIdOnly("*", crit));
    	return ItemMappingDataAccess.select(con, crit);
    }

    private boolean validateAcknowledgeRequest(AcknowledgeRequestData pAckReq,
        Connection conn, Map paramMap, int partnerId, IdVector pStoreIds,
        IdVector pAccountIds, IdVector pDistributorIds, StringBuilder messages) throws RemoteException {

        if (log.isInfoEnabled()) {
            log.info("validateAcknowledgeRequest");
            log.info("Trading partner id=" + partnerId);
        }
        boolean isDataCorrect = true;
        if (pAckReq.getAccountId() > 0) {
            pAccountIds = new IdVector();
            if (log.isInfoEnabled()) {
                log.info("Resseting account id list as ack request has account id set");
                log.info("Account id=" + pAckReq.getAccountId());
            }
            pAccountIds.add(new Integer(pAckReq.getAccountId()));
        }
        try {
            // process current acknowledgement from vendor
            boolean matchByVendorOrderNum = pAckReq.getMatchNumType().equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.VENDOR_ORDER_NUM);
            if (log.isDebugEnabled()){
                log.debug("matchByVendorOrderNum=" + matchByVendorOrderNum);
                log.debug("pAckReq.getErpPoNum()=" + pAckReq.getErpPoNum());
                log.debug("pAckReq.getVendorOrderNum()=" + pAckReq.getVendorOrderNum());
            }
            String erpPoNum = matchByVendorOrderNum ? pAckReq.getVendorOrderNum() : pAckReq.getErpPoNum();
            if (log.isDebugEnabled()) {
                log.debug("erpPoNum to operate on=" + erpPoNum);
            }
            // get the original order record for this acknowledgement
            PurchaseOrderData thePo = null;

            if (log.isDebugEnabled()){
                log.debug("pDistributorIds=" + Utility.toCommaSting(pDistributorIds));
                log.debug("pStoreIds=" + Utility.toCommaSting(pStoreIds));
                log.debug("pAccountIds=" + Utility.toCommaSting(pAccountIds));
            }

            BusEntityData site = null;
            int siteId = 0;
            int accountId = 0;

            if(pAckReq.getSiteKey() != null){
        		BusEntityDataVector sites = this.getSitesFromEntityKey(pAckReq.getSiteKey(), pStoreIds, pAccountIds, partnerId, conn);
        		if(sites.size() > 1){
        			throw new Exception("multiple sites found for site key: "+pAckReq.getSiteKey());
        		}else if (sites.size() == 1){
        			site = (BusEntityData)sites.get(0);
        			siteId = site.getBusEntityId();
        		}
            }

            if (pAckReq.getStoreId() > 0 && pStoreIds.contains(new Integer(pAckReq.getStoreId()))) {
                if(pAckReq.getOrderId() == 0){
                   IdVector storeIds = new IdVector();
                   storeIds.add(new Integer(pAckReq.getStoreId()));
                   thePo = getOrderByPoNum(pStoreIds,pDistributorIds, erpPoNum,siteId,accountId, conn, pAckReq.getMatchNumType());
                 } else if (pAckReq.getOrderId() > 0) {
		           OrderData theOrder = OrderDataAccess.select(conn, pAckReq.getOrderId());
		           DBCriteria crit = new DBCriteria();
		           crit.addEqualTo(PurchaseOrderDataAccess.ORDER_ID,theOrder.getOrderId());
		           PurchaseOrderDataVector podv = PurchaseOrderDataAccess.select(conn,crit);
		           thePo = (PurchaseOrderData) podv.get(0);
                 }
            } else {
                if (pStoreIds == null || pStoreIds.size() == 0) {
                    isDataCorrect = false;
                    messages.append("Trading partner not configured to any stores, directly or indirectly. Possibly no associations to trading were made.\r\n");
                }
                thePo = getOrderByPoNum(pStoreIds,pDistributorIds, erpPoNum,siteId,accountId, conn, pAckReq.getMatchNumType());
            }
            if(thePo == null && !pAckReq.isRequestCreateOrderIfNotExists() ){
            	isDataCorrect = false;
            	messages.append("Could not find order for po number: "+erpPoNum);
            }
            //check to see if we need to create a new order (not necessary if no items in 855
            if (log.isInfoEnabled()) {
                log.info("thePo=" + thePo);
                log.info("pAckReq.getAckItemDV()=" + pAckReq.getAckItemDV().size());
                log.info("pAckReq.getSiteKey()=" + pAckReq.getSiteKey());
                log.info("pAckReq.isRequestCreateOrderIfNotExists()=" + pAckReq.isRequestCreateOrderIfNotExists());
            }
            if (thePo == null &&
                pAckReq.isRequestCreateOrderIfNotExists() &&
                pAckReq.getSiteKey() == null) {
                isDataCorrect = false;
                messages.append("Cannot have null site key and create order flag set: ");
                messages.append(pAckReq);
                messages.append("\r\n");
            }
            if (thePo == null &&
                pAckReq.getAckItemDV() != null &&
                pAckReq.getSiteKey() != null &&
                pAckReq.isRequestCreateOrderIfNotExists() &&
                pStoreIds != null) {

                if (log.isDebugEnabled()){
                    log.debug("checking to create new order");
                }
                //make the check
                if (site == null) {
                	isDataCorrect = false;
                    messages.append("Could not find site for (");
                    messages.append(pAckReq.getSiteKey());
                    messages.append(") and create order flag was set\r\n");
                }else{
                    accountId = 0;
                    int dbaccountId = BusEntityDAO.getAccountForSite(conn,site.getBusEntityId());
                    if (accountId == 0 || dbaccountId == accountId) {
                        accountId = dbaccountId;
                    } else {
                        isDataCorrect = false;
                        messages.append("multiple accounts found for site id: ");
                        messages.append(site.getBusEntityId());
                        messages.append("\r\n");
                    }

                    PropertyUtil pru = new PropertyUtil(conn);
                    boolean createOrder = Utility.isTrue(pru.fetchValueIgnoreMissing(
                        0, accountId, RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_BY_855));
                    if (log.isDebugEnabled()) {
                        log.debug("CREATE_ORDER_BY_855 for account " + accountId + "=" + createOrder);
                    }
                    if (createOrder) {
                        if (log.isInfoEnabled()) {
                            log.info("account is setup to create a new order");
                        }
                        boolean foundError = false;
                        HashSet notesToLog = new HashSet();
                        Iterator it = pAckReq.getAckItemDV().iterator();
                        ItemInfo itemInfo = new ItemInfo(conn, partnerId, site.getBusEntityId());
                        while (it.hasNext()) {
                            AckItemData itm = (AckItemData) it.next();
                            itemInfo.getItemInfo(itm.getDistSkuNum(), itm.getUom(), pDistributorIds, notesToLog);
                            if (!(itm.getAction().equals("IR") || itm.getAction().equals("ID"))) {
                                if (itemInfo.foundError)
                                    foundError = true;
                                if (foundError)
                                    continue;
                            }
                        }
                        if (foundError) {
                            it = notesToLog.iterator();
                            while (it.hasNext()) {
                                String notes = (String)it.next();
                                log.error(notes);
                                messages.append(notes).append("\r\n");
                            }
                            isDataCorrect = false;
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            log.error("validateAcknowledgeRequest: " + ex);
            isDataCorrect = false;
            messages.append("Error. validateAcknowledgeRequest() Exception happened. ");
            messages.append(ex.getMessage());
            messages.append("\r\n");
        }
        if (log.isDebugEnabled()) {
            log.debug("[validateAcknowledgeRequest] result: " + isDataCorrect);
        }
        return isDataCorrect;
    }

    private boolean processAcknowledgeRequest
    (AcknowledgeRequestData pAckReq,
     Connection conn, Map paramMap, int partnerId,IdVector pStoreIds, IdVector pAccountIds, IdVector pDistributorIds)
    throws RemoteException {

        log.info("processAcknowledgeRequest.");
        log.info("Trading partner id="+partnerId);
        HashSet notesToLog = new HashSet();
        LinkedList itemNotesToLog = new LinkedList();
        String notes;
        boolean reprocessOrderFl = false;
        int storeId = 0;
        boolean newOrder = false;
        boolean skipDupOrderValidate = pAckReq.getOrderId() == -1;

        if(pAckReq.getAccountId() > 0){
        	pAccountIds = new IdVector();
        	log.info("Resseting account id list as ack request has account id set");
        	log.info("Account id="+pAckReq.getAccountId());
        	pAccountIds.add(new Integer(pAckReq.getAccountId()));
        }

        try {

            // process current acknowledgement from vendor
        	boolean matchByVendorOrderNum = pAckReq.getMatchNumType().equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.VENDOR_ORDER_NUM);
            if(log.isDebugEnabled()){
				log.debug("matchByVendorOrderNum="+matchByVendorOrderNum);
				log.debug("pAckReq.getErpPoNum()="+pAckReq.getErpPoNum());
				log.debug("pAckReq.getVendorOrderNum()="+pAckReq.getVendorOrderNum());
            }
            String erpPoNum = matchByVendorOrderNum ? pAckReq.getVendorOrderNum() : pAckReq.getErpPoNum();
            if (!Utility.isSet(erpPoNum))
            	erpPoNum = pAckReq.getVendorOrderNum();
            if(log.isDebugEnabled()){log.debug("erpPoNum to operate on="+erpPoNum);}
            // get the original order record for this acknowledgement
            PurchaseOrderData thePo = null;
            PurchaseOrderDataVector podv = null;
            OrderData theOrder = null;
            OrderItemDataVector poItems = null;
            ItemInfo itemInfo = null;

            if(log.isDebugEnabled()){
            	log.debug("pDistributorIds="+Utility.toCommaSting(pDistributorIds));
        		log.debug("pStoreIds="+Utility.toCommaSting(pStoreIds));
        		log.debug("pAccountIds="+Utility.toCommaSting(pAccountIds));
            }

            BusEntityData site = null;
            int siteId = 0;
            int accountId = 0;

            if(pAckReq.getSiteKey() != null){
        		BusEntityDataVector sites = this.getSitesFromEntityKey(pAckReq.getSiteKey(), pStoreIds, pAccountIds, partnerId, conn);
        		if(sites.size() > 1){
        			throw new Exception("multiple sites found for site key: "+pAckReq.getSiteKey());
        		}else if(sites.size() == 1){
        			site = (BusEntityData)sites.get(0);
        			siteId = site.getBusEntityId();
        		}
            }

            if(pAckReq.getStoreId() > 0 && pStoreIds.contains(new Integer(pAckReq.getStoreId()))){
            	IdVector storeIds = new IdVector();
            	storeIds.add(new Integer(pAckReq.getStoreId()));
            }else{
            	if(pStoreIds == null || pStoreIds.size() == 0){
            		throw new RemoteException("Trading partner not configured to any stores, directly or indirectly.  Possibly no associations to trading were made.");
            	}
            }
            if (pAckReq.getOrderId() <= 0 && !skipDupOrderValidate){
            	thePo = getOrderByPoNum(pStoreIds, pAccountIds, erpPoNum, siteId,accountId, conn, pAckReq.getMatchNumType());
            	if (thePo != null){
            		pAckReq.setOrderId(thePo.getOrderId());
            	}
            }

            if (pAckReq.getOrderId() > 0){
	            theOrder = OrderDataAccess.select(conn, pAckReq.getOrderId());
	            DBCriteria crit = new DBCriteria();
	            crit.addEqualTo(PurchaseOrderDataAccess.ORDER_ID,theOrder.getOrderId());
	            podv = PurchaseOrderDataAccess.select(conn,crit);
	            thePo = (PurchaseOrderData) podv.get(0);
	            poItems = getOrderItemsByOrderId(theOrder.getOrderId(), conn);
	            storeId = theOrder.getStoreId();
            }else{
        		storeId = ((Integer) pStoreIds.get(0)).intValue();
        	}

            PropertyUtil pru = new PropertyUtil(conn);

            //errors are only very serious problems that require attention, not data mismatches or
            //missing information.  An example of an error would be a valid 855 against a cancelled po
            boolean foundError =false;

            //check to see if we need to create a new order (not necessary if no items in 855
            log.info("thePo ="+thePo);
            log.info("pAckReq.getAckItemDV() ="+pAckReq.getAckItemDV().size());
            log.info("pAckReq.getSiteKey() ="+pAckReq.getSiteKey());
            log.info("pAckReq.getSiteKey() ="+pAckReq.getSiteKey());
            log.info("pAckReq.isRequestCreateOrderIfNotExists()="+pAckReq.isRequestCreateOrderIfNotExists());
            if(thePo == null && pAckReq.isRequestCreateOrderIfNotExists() && pAckReq.getSiteKey() == null){
            	throw new Exception("Cannot have null site key and create order flag set: "+pAckReq);
            }

            if(thePo == null && !pAckReq.isRequestCreateOrderIfNotExists() ){
            	throw new RemoteException("Could not find order for po number: "+erpPoNum);
            }

            if(thePo == null && pAckReq.getAckItemDV() != null && pAckReq.isRequestCreateOrderIfNotExists()){
            	log.debug("checking to create new order");

            	if (site == null){
            		throw new Exception("Could not find site for ("+pAckReq.getSiteKey()+") and create order flag was set");
            	}

        		accountId = 0;
        		BusEntityData account = null;
        		int contractId = 0;
                int catalogId = 0;

    			int dbaccountId = BusEntityDAO.getAccountForSite(conn,site.getBusEntityId());
    			if(accountId == 0 || dbaccountId == accountId){
    				accountId = dbaccountId;
    				account = BusEntityDataAccess.select(conn, accountId);
    			}else{
    				throw new Exception("multiple accounts found for site id: "+site.getBusEntityId());
    			}

        		boolean createOrder = Utility.isTrue(pru.fetchValueIgnoreMissing(0, accountId, RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_BY_855));
        		log.debug("CREATE_ORDER_BY_855 for account "+accountId+"="+createOrder);
        		if(createOrder){
        			newOrder = true;
        			if (pAckReq.isPriceFromContract()){
                        int[] r = getContractAndCatalogIdBySiteId(conn, siteId);
                        contractId = r[0];
                        catalogId = r[1];
                    }
        			log.info("account is setup to create a new order");
            		//ok we need to create it...
            		OrderRequestData req = new OrderRequestData(pAckReq.getSiteKey(),accountId);
            		req.setSkipDupOrderValidation(skipDupOrderValidate);

            		req.setSiteId(site.getBusEntityId());

            		req.setBillingOrder(true); //otherwise we would send it back to them.
            		req.setBypassCustomerWorkflow(true);//order is placed and done with...nothing we can do with workflow
            		req.addOrderNote("Created From Order Acknowledgment");
            		req.setCustomerPoNumber(pAckReq.getErpPoNum());
            		TradingPartnerData partnerD = TradingPartnerDataAccess.select(conn, partnerId);
            		String skuType = partnerD.getSkuTypeCd();
            		req.setSkuTypeCd(skuType);
            		Iterator it = pAckReq.getAckItemDV().iterator();
            		itemInfo = new ItemInfo(conn, partnerId, site.getBusEntityId());
            		while(it.hasNext()){
            			AckItemData itm = (AckItemData) it.next();
            			itemInfo.getItemInfo(itm.getDistSkuNum(), itm.getUom(), pDistributorIds, notesToLog);
            			//only create if they are not deleted or rejected
            			if(!(itm.getAction().equals("IR") || itm.getAction().equals("ID"))){
            				int cwsku = 0;
            				if (itemInfo.foundError)
            					foundError = true;

            				if (foundError)
            					continue;

        					double price = 0;
        					if (pAckReq.isPriceFromContract() && itemInfo.itemId > 0){
        						price = getContractItemPrice(conn, storeId, site.getBusEntityId(), contractId, catalogId, itemInfo.itemId).doubleValue();
        					}else{
	        					if(itm.getPrice() != null){
	        						price = itm.getPrice().doubleValue();
	        					}else{
	        						price = 0;
	        					}
        					}
        					req.addItemEntry(itm.getLineNum(), itemInfo.itemId, cwsku, itm.getQuantity(), price, itm.getUom(), itm.getItemName(), null, false, 0, "", false, itemInfo.distId,RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.SYSTEM_ACCEPTED);
            			}
            		}

            		if (foundError){
						it = notesToLog.iterator();
						String message = "";
			            while(it.hasNext()){
			                notes = (String)it.next();
			                log.error(notes);
			                message += notes + "\r\n";
			            }
						throw new Exception(message);
					}
            		//XXX guess at trading profile.  Should maybe pass the profile through from the transaction.
            		TradingPartnerBean tradingPartnerEjb = new TradingPartnerBean();
            		TradingProfileDataVector tProfileDV = tradingPartnerEjb.getTradingProfileByPartnerId(partnerId);
            		if(tProfileDV != null && tProfileDV.size() > 0){
            			TradingProfileData profile = (TradingProfileData) tProfileDV.get(0);
            			req.setIncomingProfileId(profile.getTradingProfileId());
            		}
            		req.setOrderRefNumber(pAckReq.getVendorOrderNum());
            		req.setHistoricalOrder(true);

            		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
            		req.setCustomerOrderDate(sdf.format(pAckReq.getAckDate()));

            		//processIntegrationRequest(req, conn, new HashMap(), null, pStoreIds, pAccountIds, pDistributorIds, 0);
            		ProcessOrderResultData res = processOrderRequest(req);
            		log.info(res);

            		theOrder = OrderDataAccess.select(conn, res.getOrderId());

            		getAPIAccess().getPipelineAPI().processPipeline(theOrder,RefCodeNames.PIPELINE_CD.CUST_ORDER_PROCESSING);

            		theOrder.setOriginalOrderDate(pAckReq.getAckDate());
            		theOrder.setOriginalOrderTime(pAckReq.getAckDate());
            		if (contractId > 0)
            			theOrder.setContractId(contractId);
            		if (theOrder.getOrderStatusCd().equals(RefCodeNames.ORDER_STATUS_CD.ORDERED))
            				theOrder.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED);

            		OrderDataAccess.update(conn, theOrder);

            		DBCriteria crit = new DBCriteria();
                    crit.addEqualTo(PurchaseOrderDataAccess.ORDER_ID,theOrder.getOrderId());
                    crit.addEqualTo(PurchaseOrderDataAccess.STORE_ID,storeId);
                    podv = PurchaseOrderDataAccess.select(conn,crit);
                    poItems = getOrderItemsByOrderId(theOrder.getOrderId(), conn);

                	for (int i = 0; i < podv.size(); i++){
                		PurchaseOrderData po = (PurchaseOrderData) podv.get(i);
                		po.setOutboundPoNum(erpPoNum);
                		PurchaseOrderDataAccess.update(conn, po);
                	}

                	for (int i = 0; i < poItems.size(); i++) {
                		OrderItemData item = (OrderItemData)poItems.get(i);
                		item.setOutboundPoNum(erpPoNum);
                		OrderItemDataAccess.update(conn, item);
                	}

            		OrderPropertyData prop = OrderPropertyData.createValue();
            		prop.setAddBy("IntegrationServicesBean");
            		prop.setModBy("IntegrationServicesBean");
                    prop.setShortDesc(RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_PO_NUM);
                    prop.setOrderPropertyTypeCd(RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_PO_NUM);
                    prop.setOrderPropertyStatusCd(RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                    prop.setOrderId(res.getOrderId());
                    prop.setValue(pAckReq.getErpPoNum());
                    OrderPropertyDataAccess.insert(conn, prop);

            	} //if(make order)
            }


            if (poItems != null && poItems.size() > 0) {
                //find the po
                OrderData matchOrder = theOrder;
                TradingPartnerInfo partnerInfo = null;
                partnerInfo = getTradingPartnerInfo(partnerId,paramMap);


                //get the distributor and the company code
                String distCompanyId = pAckReq.getDistributorsCompanyCode();

                if (Utility.isSet(distCompanyId)){
                	distCompanyId = distCompanyId.trim();
	                DistributorData dist = null;
	                String distErp = null;

	                for (int i = 0; i < podv.size(); i++){
                		PurchaseOrderData po = (PurchaseOrderData) podv.get(i);

		                if(po != null){
		                    distErp = po.getDistErpNum();
		                }
		                if(!Utility.isSet(distErp)){
		                    OrderItemData firstOrderItem = (OrderItemData) poItems.get(0);
		                    distErp = firstOrderItem.getDistErpNum();
		                }
		                if(Utility.isSet(distErp)){
		                    dist = getDistributorData(conn, 0, distErp, paramMap);
		                    //check to see of the distributors company code matches if it is set in the
		                    //ack request

		                    if(dist != null){
		                        String value = dist.getDistributorsCompanyCode();
		                        if(Utility.isSet(value)){
		                            if(!value.equals(distCompanyId)){
		                                foundError = true;
		                                notesToLog.add("distributor company code in file ("+distCompanyId+") does not match "+
		                                "company code for this pos distributor ("+value+") for po "+po.getErpPoNum());
		                            }
		                        }
		                    }
		                }

		              //check the status of the purchase order, and update it to be acknowledged if the distributor is
		                //configured to allow it
		                if(po != null){
		                    if(po.getPurchaseOrderStatusCd().equals(RefCodeNames.PURCHASE_ORDER_STATUS_CD.PENDING_FULFILLMENT) ||
		                        po.getPurchaseOrderStatusCd().equals(RefCodeNames.PURCHASE_ORDER_STATUS_CD.SENT_TO_DISTRIBUTOR) ||
		                        po.getPurchaseOrderStatusCd().equals(RefCodeNames.PURCHASE_ORDER_STATUS_CD.SENT_TO_DISTRIBUTOR_FAILED)){
		                        if(Boolean.FALSE.equals(dist.getManualPOAcknowldgementRequiered())){
		                            po.setPurchaseOrderStatusCd(RefCodeNames.PURCHASE_ORDER_STATUS_CD.DIST_ACKD_PURCH_ORDER);
		                            PurchaseOrderDataAccess.update(conn, po);
		                        }
		                    }else if (po.getPurchaseOrderStatusCd().equals(RefCodeNames.PURCHASE_ORDER_STATUS_CD.CANCELLED)){
		                        notesToLog.add("PO "+po.getErpPoNum()+" was cancelled");
		                        foundError = true;
		                    }
		                }
	                }
                }


                //Get warning 855 records
                IdVector orderItem855Warnings = null;

                // get Adjust Order Quantity flag
                accountId = matchOrder.getAccountId();
                DBCriteria dbc = new DBCriteria();
                dbc.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID, accountId);
                dbc.addEqualTo(PropertyDataAccess.SHORT_DESC,
                        RefCodeNames.PROPERTY_TYPE_CD.ADJUST_QTY_BY_855);
                dbc.addEqualTo(PropertyDataAccess.PROPERTY_STATUS_CD,
                        RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                PropertyDataVector propertyDV =
                        PropertyDataAccess.select(conn,dbc);
                boolean adjustQtyFl = false;
                if(!propertyDV.isEmpty()) {
                    String ss = ((PropertyData) propertyDV.get(0)).getValue();
                    adjustQtyFl = Utility.isTrue(ss,false);
                }
                log.debug("adjustQtyFl="+adjustQtyFl);
                boolean priceIsSameAsCost = Utility.isTrue(pru.fetchValueIgnoreMissing(0, matchOrder.getStoreId(), RefCodeNames.PROPERTY_TYPE_CD.EQUAL_COST_AND_PRICE));

                String val = pru.fetchValueIgnoreMissing(0, accountId, RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_ITEMS_BY_855);
                boolean addItems = Utility.isTrue(val);
                if (!addItems)
                	addItems = Utility.isTrue(pru.fetchValueIgnoreMissing(0, accountId, RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_BY_855));

                int maxOrderLineNum = 0; // will be used if addItems is true when add item is needed
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(pAckReq.getAckDate());

                if (calendar.DAY_OF_WEEK == calendar.FRIDAY)
                    calendar.add(Calendar.HOUR, 96); // give four day to deliver the goods
                else if (calendar.DAY_OF_WEEK == calendar.THURSDAY)
                    calendar.add(Calendar.HOUR, 72); // give three day to deliver the goods
                else
                    calendar.add(Calendar.HOUR, 48); // give 2 day to deliver the goods

                Date shipDate = calendar.getTime();
                Date currentDate = new Date();


                /*if(Utility.isSet(pAckReq.getHeaderLevelActionCode()) && pAckReq.getHeaderLevelActionCode().equals("AH")){
			    	Iterator it = poItems.iterator();
	            	while(it.hasNext()){
	            		OrderItemData oid = (OrderItemData) it.next();
	            		//add the action
	                    OrderItemActionData ackAction = OrderItemActionData.createValue();
	                    ackAction.setOrderId(oid.getOrderId());
	                    ackAction.setOrderItemId(oid.getOrderItemId());
	                    ackAction.setAffectedSku("" + oid.getItemSkuNum());
	                    ackAction.setQuantity(oid.getTotalQuantityOrdered());
	                    if (pAckReq.getAckDate() != null){
		                    ackAction.setActionDate(pAckReq.getAckDate());
		                    ackAction.setActionTime(pAckReq.getAckDate());
	                    }else{
	                    	ackAction.setActionDate(currentDate);
		                    ackAction.setActionTime(currentDate);
	                    }
	                    ackAction.setAddBy("system 10");
	                    if(pAckReq.getHeaderLevelActionCode().equals("AH")){
	                    	ackAction.setActionCd(translateOrderAcknowlegmentCode(pAckReq.getHeaderLevelActionCode()));
	                    }
	                    OrderItemActionDataAccess.insert(conn, ackAction);
	            	}
	            }else if(Utility.isSet(pAckReq.getHeaderLevelActionCode())){
	            	log.info("Unknown Header Level Action: " + pAckReq.getHeaderLevelActionCode());
	            }*/

                for (int i = 0; i < pAckReq.getAckItemDV().size(); i++) {

                    AckItemData ackItemD = (AckItemData)pAckReq.getAckItemDV().get(i);
                    boolean itemSubstitution = ackItemD.getAction().equals("IS");


                    // Validate that we have the fields needed to look up the
                    // order item record.  If not, set flag so we won't
                    // try to look the record up.
                    int cwSku = ackItemD.getCwSkuNum();
                    String vendorSku = ackItemD.getDistSkuNum();
                    boolean haveRequiredFields = true;
                    itemNotesToLog.clear();

                    // check if both cw sku and vendor sku are missing
                    if (cwSku == 0 && !Utility.isSet(vendorSku)) {
                        haveRequiredFields = false;
                        itemNotesToLog.add("Missing System Sku and vendorSku.");
                    }

                    // Now check the rest of the fields
                    int quantity = ackItemD.getQuantity();

                    if (quantity == 0) {
                        notes = "Missing quantity: " + ", quantity=" +
                                quantity;
                        itemNotesToLog.add(notes);
                    }

                    // Get the order item record
                    int poLineNumber = ackItemD.getLineNum();
                    OrderItemData itemMatch = null;
                    OrderItemDataVector itemsMatch = null;

                    if (haveRequiredFields) {

                        // First try to match on po line number
                        // and one of the SKUs.
                        // This will try to match against
                        // either the cwSku or the
                        // vendorSku, in either the "main" or
                        // the sub fields in the
                        // database.

                    	if (itemSubstitution) {
                    		itemsMatch = getOrderItemByPoLineNumber(poLineNumber, poItems);
                    		if (itemsMatch.size() == 0){
                    			throw new RemoteException("Failed on finding po line# =" + poLineNumber);
							}
                    	} else {
	                    	log.debug("#### Searching by PO line and SKUs: poLine#=" +poLineNumber + " System Sku=" + cwSku +" Vendor Sku=" + vendorSku);
	                        itemsMatch = getOrderItemByPoLineNumberAndSku(
	                                             poLineNumber, cwSku, vendorSku,
	                                             poItems);
                    	}

                        // If we don't have the po line number or couldn't get a
                        // match on it, try just the SKU numbers without the po
                        // line number.
                        if (itemsMatch.size() == 0) {
                            itemsMatch = getOrderItemBySku(cwSku, vendorSku,
                                                           poItems);
                            log.debug("#### Searching by SKUs: cwSku=" + cwSku + " vendorSku=" + vendorSku);
                        }

                        // At this point we *might* have some kind of match
                        if (itemsMatch.size() == 1) {
                            itemMatch = (OrderItemData)itemsMatch.get(0);
                        } else if (itemsMatch.size() > 1) {
                        	//if there are multiple line number matching see if we can find one of those
                        	//that matches both by sku and be po number.
                        	OrderItemDataVector itemsMatch2 = getOrderItemBySku(cwSku, vendorSku,itemsMatch);
                        	if (itemsMatch2.size() == 1) {
                                itemMatch = (OrderItemData)itemsMatch2.get(0);
                                itemsMatch = itemsMatch2;
                        	}

                            notes = "Found multiple matching order item records.\n";
                            notes += "Possible order item ids:";
                            for (int x = 0; x < itemsMatch.size(); x++) {
                                notes += " " + ((OrderItemData)itemsMatch.get(
                                                        x)).getOrderItemId();
                            }

                            itemNotesToLog.add(notes);
                        } else {

                            // Try to find a substitution.
                            int contractId = matchOrder.getContractId();
                            Contract contractEjb = APIAccess.getAPIAccess().getContractAPI();

                            ContractData contract = null;
                            try {
                                contract = contractEjb.getContract(contractId);
                            } catch (DataNotFoundException e) {
                                //ignore
                                log.info("processAcknowledgeRequest()=> WARN: " + e.getMessage());
                            }

                            log.debug("#### Searching by PO line: poLine#=" +poLineNumber);
                            itemsMatch = getOrderItemByPoLineNumber(
                                                 poLineNumber, poItems);

                            if (itemsMatch.size() > 1) {
                                notes = "Found multiple matching order item records for line # " +
                                        poLineNumber + ".\n";
                                notes += "Possible order item ids:";

                                for (int x = 0; x < itemsMatch.size(); x++) {
                                    notes += " " + ((OrderItemData)itemsMatch.get(
                                                            x)).getOrderItemId();
                                }

                                itemNotesToLog.add(notes);
                            } else if (itemsMatch.size() == 1) {
                                itemMatch = (OrderItemData)itemsMatch.get(0);
                                log.debug("Matching off of po line (substituion)");

                                if (isApprovedSubWithItem(contractId,
                                                          itemMatch.getItemId(),
                                                          cwSku, vendorSku,
                                                          conn,paramMap)) {
                                    itemMatch = (OrderItemData)itemsMatch.get(0);
                                }
                            }

                            if (itemsMatch.size() == 0) {
                                itemsMatch = getApprovedSubstitutionItems(
                                                     contractId, poItems,
                                                     cwSku, vendorSku, conn,paramMap);
                                log.debug("#### Get Approved Substition Item: itemsMatch#=" +itemsMatch);
                            }

                            if (itemsMatch.size() == 1) {
                                itemMatch = (OrderItemData)itemsMatch.get(0);
                            } else if (itemsMatch.size() > 1) {
                                notes = "Found multiple matching order item records for approved substitution.\n";
                                notes += "Possible order item ids:";

                                for (int x = 0; x < itemsMatch.size(); x++) {
                                    notes += " " + ((OrderItemData)itemsMatch.get(
                                                            x)).getOrderItemId();
                                }

                                itemNotesToLog.add(notes);
                            } else { // no order item match found
                            	if (addItems){
                            		reprocessOrderFl = true;
                            		if (maxOrderLineNum == 0){
                            			for (int j = 0; j < poItems.size(); j++) {
                            				maxOrderLineNum = Math.max(maxOrderLineNum, ((OrderItemData)poItems.get(j)).getOrderLineNum());
										}
                            		}

                            		OrderItemData oiD = OrderItemData.createValue();
                            		OrderItemData foiD = (OrderItemData)poItems.get(0);
                            		oiD.setOrderId(matchOrder.getOrderId());
    								oiD.setOutboundPoNum(foiD.getOutboundPoNum());
                            		oiD.setOrderItemStatusCd(foiD.getOrderItemStatusCd());
                            		oiD.setOrderLineNum(++maxOrderLineNum);
                            		oiD.setCustLineNum(poLineNumber);
                            		oiD.setErpPoLineNum(poLineNumber);
                            		oiD.setErpOrderLineNum(maxOrderLineNum);
                            		oiD.setErpPoNum(foiD.getErpPoNum());
                            		oiD.setErpPoDate(foiD.getErpPoDate());
                            		oiD.setErpPoTime(foiD.getErpPoTime());
                            		oiD.setDistErpNum(foiD.getDistErpNum());
                            		oiD.setSaleTypeCd(foiD.getSaleTypeCd());
                            		oiD.setTaxExempt(foiD.getTaxExempt());
                            		oiD.setAddBy("Integration-855");
                            		oiD.setModBy("Integration-855");

                            		if (itemInfo == null){
                            			itemInfo = new ItemInfo(conn, partnerId, matchOrder.getSiteId());
                            		}

                            		BusEntityData distBus = null;

                            		if (itemInfo.distId > 0){
                            			distBus = BusEntityDataAccess.select(conn, itemInfo.distId);
                            		}else{
                            			distBus = Utility.getDistBusEntityByErpNumber(conn, foiD.getDistErpNum(), new HashMap());
                            		}

                            		if (distBus == null){
                            			throw new RemoteException("Unable to match item with Distributor. itemId=" + itemInfo.itemId + ", vendorSku=" + ackItemD.getDistSkuNum());
                            		}
                            		int distId = distBus.getBusEntityId();
                            		pDistributorIds.clear();
                            		pDistributorIds.add(new Integer(distId));

                                    setOrderItemDataInfo(conn,
                                            partnerId,
                                            matchOrder.getStoreId(),
                                            matchOrder.getSiteId(),
                                            contract != null ? contract.getContractId() : 0,
                                            contract != null ? contract.getCatalogId() : 0,
                                            oiD,
                                            itemInfo,
                                            pDistributorIds,
                                            ackItemD.getPrice(),
                                            ackItemD,
                                            notesToLog);

                            		if (podv.size() > 1){
	    								for (int j = 0; j < podv.size(); j++){
	    									thePo = (PurchaseOrderData) podv.get(j);
	    									if (thePo.getDistErpNum().equals(foiD.getDistErpNum())){
	    										oiD.setPurchaseOrderId(thePo.getPurchaseOrderId());
	    										break;
	    									}
	    								}
    								}else{
    									oiD.setPurchaseOrderId(thePo.getPurchaseOrderId());
    								}

    								OrderItemDataAccess.insert(conn, oiD);
    								poItems.add(oiD);

    								itemMatch = oiD;
    								// add the action
    		                        OrderItemActionData ackAction = OrderItemActionData.createValue();
    		                        ackAction.setOrderId(itemMatch.getOrderId());
    		                        ackAction.setOrderItemId(itemMatch.getOrderItemId());
    		                        ackAction.setAffectedSku("" + cwSku);
    		                        ackAction.setQuantity(quantity);
    		                        if (pAckReq.getAckDate() != null){
    				                    ackAction.setActionDate(pAckReq.getAckDate());
    				                    ackAction.setActionTime(pAckReq.getAckDate());
    			                    }else{
    			                    	ackAction.setActionDate(currentDate);
    				                    ackAction.setActionTime(currentDate);
    			                    }
    		                        ackAction.setAddBy("IntegrationServicesBean");
    		                        ackAction.setActionCd(RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.SYSTEM_ACCEPTED);
    		                        OrderItemActionDataAccess.insert(conn, ackAction);
                            	}else{
	                                notes = "No matching order item or approved substitution found for" +
	                                        " SKUs: System Sku=" + cwSku +
	                                        " vendorSku=" + vendorSku;
	                                itemNotesToLog.add(notes);
                            	}
                            }
                        }

                    }
/* Order  quantiy change rules if adjustQtyFl is set (Yuriy)
=========================================================
IA = Item Accepted
DR
AC
AA
IA
ID = Item Deleted
IR = Item Rejected
NewQty = OrderQty - AckQty, if NewQty <= 0 then change item status to cancelled
==========================================================
IQ = Item Accepted - Quantity Changed
NewQty = AckQty, if NewQty <= 0 then change item status to cancelled
==========================================================
IH = Item on Hold (update item status, action and qty in detail)
IS = Item Accepted - Substitution made
IC = Item Accepted, Changes made
IB = Item Backordered
No order quantity change
===========================================================
*/

                    if (itemMatch != null) {
                    	//line match found
                    	if (partnerInfo != null)
                    		setItemAdjustedCost(partnerInfo.getTradingPartnerData(), ackItemD, itemMatch, itemNotesToLog, null, null);
                        if (cwSku == 0) {
                            cwSku = itemMatch.getItemSkuNum();
                        }

                        // check to see if multiple invoce item
                        // has match to same order item


                        if(ackItemD == null || ackItemD.getAction() == null){
                        	return true;
                        }

                        if (ackItemD.getAction().equals("IB")) {
                            itemMatch.setQuantityBackordered(
                                    itemMatch.getQuantityBackordered() +
                                    ackItemD.getQuantity());
                        } else {
                            itemMatch.setQuantityConfirmed(
                                    itemMatch.getQuantityConfirmed() +
                                    ackItemD.getQuantity());
                            itemMatch.setTargetShipDate(shipDate);
                        }

                        if(foundError){
                            itemMatch.setOrderItemStatusCd(translateOrderAcknowlegmentCode(ackItemD.getAction()));
                        }
                        boolean rejectedFl = false;
                        int orderQty = itemMatch.getTotalQuantityOrdered();
                        BigDecimal orderPrice = itemMatch.getDistItemCost();
                        int adjustedQty = orderQty;
                        BigDecimal adjustedPrice = orderPrice;

                        // add the action
                        OrderItemActionData ackAction = OrderItemActionData.createValue();
                        ackAction.setOrderId(itemMatch.getOrderId());
                        ackAction.setOrderItemId(itemMatch.getOrderItemId());
                        ackAction.setAffectedSku("" + cwSku);
                        ackAction.setQuantity(quantity);
                        if (pAckReq.getAckDate() != null){
		                    ackAction.setActionDate(pAckReq.getAckDate());
		                    ackAction.setActionTime(pAckReq.getAckDate());
	                    }else{
	                    	ackAction.setActionDate(currentDate);
		                    ackAction.setActionTime(currentDate);
	                    }
                        ackAction.setAddBy("system 9");

                        if (ackItemD.getAction().equals("IA") ||
                            ackItemD.getAction().equals("AA") ||
                            ackItemD.getAction().equals("AC") ||
                            ackItemD.getAction().equals("DR") ) {
                        	if (ackItemD.getAction().equals("AC")){// Item Accepted and Shipped
                        		ackAction.setActionCd(RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.DIST_SHIPPED);
                        		OrderItemActionDataAccess.insert(conn, ackAction);
                        	}
                            ackAction.setActionCd(translateOrderAcknowlegmentCode(ackItemD.getAction()));
                            if(adjustQtyFl) {
                                adjustedQty = ackItemD.getQuantity();
                                if(adjustedQty<0) adjustedQty = 0;
                                adjustedPrice = ackItemD.getPrice();
                            }
                        }
                        else if (ackItemD.getAction().equals("IB")) {
                            ackAction.setActionCd(
                            		translateOrderAcknowlegmentCode(ackItemD.getAction()));
                        }
                        else if (ackItemD.getAction().equals("IC")) {
                            ackAction.setActionCd(
                            		translateOrderAcknowlegmentCode(ackItemD.getAction()));
                        }
                        else if (ackItemD.getAction().equals("ID")) {
                           log.debug("Doing item deleted action");
                            ackAction.setActionCd(translateOrderAcknowlegmentCode(ackItemD.getAction()));
                            if(adjustQtyFl) {
                                log.debug("doing adjustQty logic");
                                rejectedFl = true;
                                adjustedQty = orderQty - ackItemD.getQuantity();
                                log.debug("adjustedQty now="+adjustedQty);
                                if(adjustedQty<0) adjustedQty = 0;
                                adjustedPrice = ackItemD.getPrice();
                            }
                        }
                        else if (ackItemD.getAction().equals("IH")) {
                            ackAction.setActionCd(translateOrderAcknowlegmentCode(ackItemD.getAction()));
                        }
                        else if (ackItemD.getAction().equals("IQ")) {
                            ackAction.setActionCd(
                            		translateOrderAcknowlegmentCode(ackItemD.getAction()));
                            if(adjustQtyFl) {
                                adjustedQty = ackItemD.getQuantity();
                                if(adjustedQty<0) adjustedQty = 0;
                                adjustedPrice = ackItemD.getPrice();
                            }
                        }
                        else if (ackItemD.getAction().equals("IR")) {
                            ackAction.setActionCd(
                            		translateOrderAcknowlegmentCode(ackItemD.getAction()));
                            if(adjustQtyFl) {
                                rejectedFl = true;
                                adjustedQty = orderQty - ackItemD.getQuantity();
                                if(adjustedQty<0) adjustedQty = 0;
                                adjustedPrice = ackItemD.getPrice();
                            }
                        }
                        else if (itemSubstitution) {
                            ackAction.setActionCd(
                            		translateOrderAcknowlegmentCode(ackItemD.getAction()));
                            itemSubstitution = false;
                            if(adjustQtyFl) {
                                adjustedQty = ackItemD.getQuantity();
                                if(adjustedQty<0) adjustedQty = 0;
                                adjustedPrice = ackItemD.getPrice();
                                if (!Utility.isEqual(itemMatch.getDistItemSkuNum(), ackItemD.getDistSkuNum())){
                                	itemSubstitution = true;
                                } else if (!Utility.isEqual(itemMatch.getDistItemUom(), ackItemD.getUom())){
                                	itemSubstitution = true;
                                }
                            }
                        }
                        else if (ackItemD.getAction().equals("SH")){
                            if(ackItemD.getActionDate()!= null){
                                ackAction.setActionDate(ackItemD.getActionDate());
                            }
                            ackAction.setActionCd(getOrderItemActionCodeForShipped(new Date(),ackAction.getActionDate()));
                        } else {
                            ackAction.setActionCd("ACK1=" + ackItemD.getAction());
                        }
                        OrderItemActionDataAccess.insert(conn, ackAction);

                        if(adjustedPrice == null){adjustedPrice=orderPrice;}//if adjusted price was not set then default it to the order price
                        if(adjustQtyFl && (itemSubstitution || (adjustedQty != orderQty || !orderPrice.equals(adjustedPrice)))) {
                            //check if already processed
                        	//This check has been removed as we have customers (noteably JD China) that change the same order item multiple times.
                        	//There is no identifier in the file, so we have to trust that we are not processing somthing twice
                        	//or are not being sent somthing twice.
                            /*boolean flag = false;
                            if(rejectedFl) {
                                if(orderItem855Warnings==null) {
                                    dbc = new DBCriteria();
                                    dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID, matchOrder.getOrderId());
                                    dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC,"Inbound EDI 855 Warning");
                                    dbc.addGreaterThan(OrderPropertyDataAccess.ORDER_ITEM_ID,0);
                                    orderItem855Warnings =
                                           OrderPropertyDataAccess.selectIdOnly(conn,
                                                   OrderPropertyDataAccess.ORDER_ITEM_ID, dbc);
                                }
                                int orderItemId = itemMatch.getOrderItemId();
                                if(orderItem855Warnings.contains(new Integer(orderItemId))) {
                                    flag = true;
                                    log.debug("IntegrationServicesBean. WARNING. Duplicated attempt to adjust order item quantity by 855 file. Order id: "+matchOrder.getOrderId()+" Item id: "+itemMatch.getItemId());
                                }
                            }*/
                            //if(!flag) {
                        		if (itemSubstitution){
                        			if (!Utility.isEqual(itemMatch.getDistItemSkuNum(), ackItemD.getDistSkuNum())){
                        				String ss = "Item vender sku was changed due to 855 acknowledgement action: " +
	                                    ackAction.getActionCd()+". "+
	                                    " Previous Vendor SKU =" + itemMatch.getDistItemSkuNum() + " and Item Id=" + itemMatch.getItemId() +
	                                    ". Current Vendor SKU=" + ackItemD.getDistSkuNum();
	                        			itemNotesToLog.add(ss);
	                        			itemMatch.setDistItemSkuNum(ackItemD.getDistSkuNum());
                        			}
                        			if (!Utility.isEqual(itemMatch.getDistItemUom(), ackItemD.getUom())){
                        				String ss = "Item UOM was changed due to 855 acknowledgement action: " +
	                                    ackAction.getActionCd()+". "+
	                                    " Previous UOM=" + itemMatch.getDistItemUom() + " and Item Id=" + itemMatch.getItemId() +
	                                    ". Current UOM=" + ackItemD.getUom();
	                        			itemNotesToLog.add(ss);
	                        			itemMatch.setDistItemUom(ackItemD.getUom());

                        			}
                        		}

                                itemMatch.setTotalQuantityOrdered(adjustedQty);
                                itemMatch.setDistUomConvCost(adjustedPrice);
                                try{
                                	adjustedPrice = adjustedPrice.divide(itemMatch.getDistUomConvMultiplier(),BigDecimal.ROUND_UP);
                                }catch(Exception e){
                                	log.error("processAcknowledgeRequest.Non Fatal Error determining price.  Could not divide "+adjustedPrice+" by "+itemMatch.getDistUomConvMultiplier());
                                }
                                itemMatch.setDistItemCost(adjustedPrice);
                                if(priceIsSameAsCost){
                                	itemMatch.setCustContractPrice(adjustedPrice);
                                }
                                if(adjustedQty == 0){
                                    itemMatch.setOrderItemStatusCd(RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED);
                                    String ss = "Order line was cancelled due to 855 acknowledgement action: " +
                                            ackAction.getActionCd()+". "+
                                            " SKUs: System Sku=" + cwSku +
                                            ". Initial qty=" + orderQty+ " Result qty="+adjustedQty;
                                    itemNotesToLog.add(ss);
                                } else if(adjustedQty != orderQty) {
                                    String ss = "Order quantity was changed due to 855 acknowledgement action: " +
                                            ackAction.getActionCd()+". "+
                                            " SKUs: System Sku=" + cwSku +
                                            ". Initial qty=" + orderQty+ " Result qty="+adjustedQty;
                                    itemNotesToLog.add(ss);
                                } 

                                if (itemSubstitution){
                                	if (itemInfo == null)
                                		itemInfo = new ItemInfo(conn, partnerId, matchOrder.getSiteId());
                                    setOrderItemDataInfo(conn,
                                            partnerId,
                                            matchOrder.getStoreId(),
                                            matchOrder.getSiteId(),
                                            0,
                                            0,
                                            itemMatch,
                                            itemInfo,
                                            pDistributorIds,
                                            adjustedPrice,
                                            ackItemD,
                                            notesToLog);
                                }
                                reprocessOrderFl = true;
                            //}
                        }
                        itemMatch.setModBy("system 8");
                        OrderItemDataAccess.update(conn, itemMatch);
                    }


                    // log order item exception to order property table
                    for (int j = 0; j < itemNotesToLog.size(); j++) {
                        notes = (String)itemNotesToLog.get(j);
                        log.error(notes);

                        int itemId = itemMatch == null
                                         ? 0 : itemMatch.getOrderItemId();
                        OrderDAO.enterOrderProperty(conn,
                                           RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                           "Inbound EDI 855 Warning", notes,
                                           matchOrder.getOrderId(), itemId, 0,
                                           0, 0, 0, 0, "");
                    }
                    itemNotesToLog.clear();
                }

                if (!newOrder){// cancell order if all the items on order are cancelled
	                boolean cancelledOrder = true;
	                dbc = new DBCriteria();
	                dbc.addEqualTo(OrderItemDataAccess.ORDER_ID,matchOrder.getOrderId());
	                OrderItemDataVector oiDV = OrderItemDataAccess.select(conn,dbc);
	                if (oiDV.size() == poItems.size()){
	                	for (int i = 0; i < poItems.size(); i++) {
	                		OrderItemData item = (OrderItemData)poItems.get(i);
	                		if (!RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED.equals(item.getOrderItemStatusCd())){
	                			cancelledOrder = false;
	                			break;
	                		}
						}
	                	if (cancelledOrder)
		                	matchOrder.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.CANCELLED);
	                }
                }

                boolean modifyCustPoNum = Utility.isTrue(pru.fetchValueIgnoreMissing(0, accountId, RefCodeNames.PROPERTY_TYPE_CD.MODIFY_CUST_PO_NUM_BY_855));
                if (modifyCustPoNum && !Utility.isEqual(matchOrder.getRequestPoNum(), pAckReq.getCustPoNum())){
                	matchOrder.setRequestPoNum(pAckReq.getCustPoNum());
                }
                // update an order entry.
                OrderDataAccess.update(conn, matchOrder);
                //update the po if one was found
                if(thePo != null){
                    PurchaseOrderDataAccess.update(conn, thePo);
                }

                // reporcess
                if(reprocessOrderFl) {
                    APIAccess factory = new APIAccess();
                    String origStatusCd = matchOrder.getOrderStatusCd();
                    //PipelineUtil pip = new PipelineUtil();
                    Map orderItemStatusMap = new HashMap();
                    for (int i = 0; i < poItems.size(); i++) {// keep original order item status
                		OrderItemData item = (OrderItemData)poItems.get(i);
                		orderItemStatusMap.put(item.getOrderItemId()+"", item.getOrderItemStatusCd());
                    }
                    
                    //STORE ORDER UPDATE pipeline
                    StoreOrderChangeRequestData  pChangeRequest = StoreOrderChangeRequestData.createValue();
            		pChangeRequest.setOrderData(matchOrder);
            		pChangeRequest.setOldOrderData(matchOrder);
            		pChangeRequest.setOldOrderItems(new OrderItemDataVector());
            		pChangeRequest.setOrderItemsDesc(new OrderItemDescDataVector());
            		pChangeRequest.setUserName("Integration-855");
            		pChangeRequest.setTotalFreightCost(matchOrder.getTotalFreightCost());
            		pChangeRequest.setTotalMiscCost(matchOrder.getTotalMiscCost());
            		dbc = new DBCriteria();
                    dbc.addEqualTo(OrderMetaDataAccess.ORDER_ID, matchOrder.getOrderId());
                    OrderMetaDataVector orderMetaDV = OrderMetaDataAccess.select(conn,dbc);
                    pChangeRequest.setOrderMeta(orderMetaDV);
                    OrderMetaData omD = Utility.getMetaObject(matchOrder, orderMetaDV, RefCodeNames.CHARGE_CD.SMALL_ORDER_FEE);
                    if (omD != null){
                    	pChangeRequest.setSmallOrderFeeAmt(new BigDecimal(omD.getValue()));
                    }                    
                    omD = Utility.getMetaObject(matchOrder, orderMetaDV, RefCodeNames.CHARGE_CD.FUEL_SURCHARGE);
                    if (omD != null){
                    	pChangeRequest.setFuelSurchargeAmt(new BigDecimal(omD.getValue()));
                    }                    
                    omD = Utility.getMetaObject(matchOrder, orderMetaDV, RefCodeNames.CHARGE_CD.DISCOUNT);
                    if (omD != null){
                    	pChangeRequest.setDiscountAmt(new BigDecimal(omD.getValue()));
                    }
            		
            		
                    try{
                    	factory.getStoreOrderAPI().updateOrder(pChangeRequest);
                        //pip.processPipeline(conn, factory, matchOrder, RefCodeNames.PIPELINE_CD.CANCEL_BACKORDERED);
                    }finally{
                        //we don't care what the status that the pipeline sets the order to, we will set it to
                        //the status that the order currently is in.  We do not want to change it no matter what
                        //the circumstances!
                        matchOrder.setOrderStatusCd(origStatusCd);
                        OrderDataAccess.update(conn,matchOrder);
                        poItems = getOrderItemsByOrderId(theOrder.getOrderId(), conn);
                        for (int i = 0; i < poItems.size(); i++) {// restore original order item status
                    		OrderItemData item = (OrderItemData)poItems.get(i);
                    		String orderItemId = item.getOrderItemId()+"";
                    		String originalItemStatusCd = (String) orderItemStatusMap.get(orderItemId);
                    		if (originalItemStatusCd != null && !item.getOrderItemStatusCd().equals(originalItemStatusCd)){
                    			item.setOrderItemStatusCd(originalItemStatusCd);
                    			OrderItemDataAccess.update(conn, item);
                    		}
                        }
                    }
                }
            } else {
                notes = "No matching order items found for po number: " +
                        pAckReq.getErpPoNum();
                notesToLog.add(notes);
            }

            int orderId = thePo == null ? 0 : thePo.getOrderId();

            // log invoice item exception to order property table
            Iterator it = notesToLog.iterator();
            while(it.hasNext()){
                notes = (String)it.next();
                log.error(notes);
                OrderDAO.enterOrderProperty(conn,
                                   RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                   "Inbound EDI 855 Warning", notes, orderId,
                                   0, 0, 0, 0, 0, 0, "");
            }

            OrderDAO.enterOrderProperty(conn,
                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.VENDOR_ORDER_NUMBER,
                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.VENDOR_ORDER_NUMBER,
                               pAckReq.getVendorOrderNum(), orderId, 0, 0, 0,
                               0, 0, 0, "");
        } catch (Exception e) {
            e.printStackTrace();
            log.error("processAcknowledgeRequest: " + e);
            throw new RemoteException("Error. processAcknowledgeRequest() Exception happened. " + e.getMessage(), e);
        }

        return true;
    }

    private void setOrderItemDataInfo(Connection conn,
                                      int partnerId,
                                      int storeId,
                                      int siteId,
                                      int contractId,
                                      int catalogId,
                                      OrderItemData oiD,
                                      ItemInfo itemInfo,
                                      IdVector pDistributorIds,
                                      BigDecimal price,
                                      AckItemData ackItemD,
                                      HashSet notesToLog) throws Exception {

        itemInfo.getItemInfo(ackItemD.getDistSkuNum(), ackItemD.getUom(),  pDistributorIds, notesToLog);
		if (itemInfo.foundError){
			if (ackItemD.getAction().equals("IS")){
				oiD.setCustContractPrice(ackItemD.getPrice());
				oiD.setDistItemCost(ackItemD.getPrice());
				oiD.setDistItemSkuNum(ackItemD.getDistSkuNum());
				oiD.setDistItemUom(ackItemD.getUom());
				log.info(itemInfo.message);
				return;
			}else{
	            log.error(itemInfo.message);
				throw new Exception(itemInfo.message);
			}
		}

		ProductData pd = null;
        CatalogInformation catInfoEjb = null;

        try {
            catInfoEjb = getAPIAccess().getCatalogInformationAPI();
            pd = catInfoEjb.getCatalogClwProduct(itemInfo.catalogId, itemInfo.itemId, 0, siteId);
        } catch (Exception e) { //ignore
        }

        if (pd == null) {
            try {
                pd = catInfoEjb.getCatalogClwProduct(itemInfo.alterCatalogId, itemInfo.itemId, 0, siteId);
            } catch (Exception e) { //ignore
            }
        }

		if (pd == null) {
			throw new Exception("Failed to get product information for itemId=" + itemInfo.itemId);
		}

		BigDecimal priceFromContract = null;

		if (price != null){
			oiD.setCustContractPrice(ackItemD.getPrice());
		}else{
			if (contractId != 0){
                priceFromContract = getContractItemPrice(conn, storeId, siteId, contractId, catalogId, itemInfo.itemId);
                oiD.setCustContractPrice(priceFromContract);
			}
		}
		oiD.setTotalQuantityOrdered(ackItemD.getQuantity());

		// set customer item information.
		oiD.setCustItemShortDesc(pd.getShortDesc());
		oiD.setCustItemUom(pd.getUom());

		// set manufacturer item information.
		oiD.setManuItemSkuNum(pd.getManufacturerSku());
		oiD.setManuItemShortDesc(pd.getManufacturerName());
		oiD.setManuItemMsrp(new BigDecimal(pd.getListPrice()));
		oiD.setManuItemUpcNum(pd.getUpc());
		oiD.setManuPackUpcNum(pd.getPkgUpc());

		// set distributor item information.

		int distId = ((Integer)pDistributorIds.get(0)).intValue();
		oiD.setDistItemSkuNum(pd.getDistributorSku(distId));
		oiD.setDistItemUom(pd.getDistributorUom(distId));
		oiD.setDistItemPack(pd.getDistributorPack(distId));
        oiD.setDistItemShortDesc(pd.getShortDesc());
        oiD.setDistItemCost(oiD.getCustContractPrice());
        oiD.setDistItemQuantity(ackItemD.getQuantity());

		log.debug("Setting itemSkuNum = "+pd.getSkuNum());
		oiD.setItemId(itemInfo.itemId);
		oiD.setItemSkuNum(pd.getSkuNum());
		oiD.setItemShortDesc(pd.getShortDesc());
		oiD.setItemUom(pd.getUom());
		oiD.setItemPack(pd.getPack());
		oiD.setItemSize(pd.getSize());
		oiD.setCostCenterId(pd.getCostCenterId());
    }
    /**
     * translates the codes that come in on an EDI 855 into somthing Human readable.  These are later sent through the translation routines
     * @param code the 2 digit (generally 2 digit) code from an EDI file
     * @return the human readable RefCodeNames value
     */
    private String translateOrderAcknowlegmentCode(String code){
    	if (code.equals("IB") ||
		code.equals("BP")
		) {
    		return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_BACKORDERED;
    	}
        if (code.equals("IA") ||
        		code.equals("AA") ||
        		code.equals("AC") ||
        		code.equals("DR") ) {
            return  RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ACCEPTED;
        }else if (code.equals("IC")) {
        	return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ACCEPTED_CHANGES_MADE;
        }else if (code.equals("ID")) {
            return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_DELETED;
        }else if (code.equals("IH")) {
        	return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ON_HOLD;
        }else if (code.equals("IQ")) {
            return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ACCEPTED_QUANTITY_CHANGED;
        }else if (code.equals("IR")) {
            return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_REJECTED;
        }else if (code.equals("IS")) {
            return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ACCEPTED_SUBSTITUTION;
        }else if (code.equals("AH")) {
                return RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.ACK_ON_HOLD;
        }else if (code.equals("SH")){
            return null;
        } else {
            return "ACK1=" + code;
        }
    }

    public int convertCostAndQty(BigDecimal divisor,Object obj,List itemNotesToLog, boolean exceptionOnQtyConversion, boolean convertRequestedCost)
    throws RemoteException {
        int curQty;
        if(obj instanceof InvoiceDistDetailData){
            curQty = ((InvoiceDistDetailData) obj).getDistItemQtyReceived();
            if(curQty == 0){
                curQty = ((InvoiceDistDetailData) obj).getDistItemQuantity();
            }
        }else{
            curQty = ((AckItemData) obj).getQuantity();
        }
        int exceptionCount=0;
        BigDecimal currQtyBD = new BigDecimal(curQty);
        BigDecimal newQty;
        try{
            newQty = currQtyBD.divide(divisor,BigDecimal.ROUND_UNNECESSARY);
            newQty.setScale(0,BigDecimal.ROUND_UNNECESSARY);

        }catch(ArithmeticException e){
            itemNotesToLog.add("quantity not evenly divisible by divisor: "+curQty+"/"+divisor);
            if(exceptionOnQtyConversion){
                exceptionCount++;
                return exceptionCount;
            }
            log.debug(">>>>>>>>>>>>>>>>>>>>>>>>> 4178");
            newQty = currQtyBD.divide(divisor,BigDecimal.ROUND_DOWN);
        }
        if(obj instanceof InvoiceDistDetailData){
            ((InvoiceDistDetailData) obj).setDistItemQuantity(newQty.intValue());
        }else{
            ((AckItemData) obj).setQuantity(newQty.intValue());
        }


        if(convertRequestedCost){
            BigDecimal curCost;
            if(obj instanceof InvoiceDistDetailData){
                curCost = ((InvoiceDistDetailData) obj).getItemReceivedCost();
            }else{
                curCost = ((AckItemData) obj).getPrice();
            }
            if(curCost != null){// price is optional for inbound edi 855
	            BigDecimal newCost = curCost.multiply(divisor);
	            try{
	                newCost.setScale(2,BigDecimal.ROUND_UNNECESSARY);
	            }catch(ArithmeticException e){
	                log.debug(">>>>>>>>>>>>>>>>>>>>>>>>> 4191");
	                itemNotesToLog.add("UOM CONVERSION: Rounding was necessary when converting cost: "+curCost+ " * " +divisor+"="+newCost);
	                exceptionCount++;
	                newCost.setScale(2,BigDecimal.ROUND_HALF_UP);
	            }
	            if(obj instanceof InvoiceDistDetailData){
	                ((InvoiceDistDetailData) obj).setItemReceivedCost(newCost);
	                log.debug("Setting recieved cost from "+curCost+" to: "+newCost);
	            }else{
	                ((AckItemData) obj).setPrice(newCost);
	            }
	            itemNotesToLog.add("Resetting Recieved Cost From: ["+curCost+"] To: ["+newCost+"]");
            }
        }


        itemNotesToLog.add("Resetting Quantity From: ["+curQty+"] To: ["+newQty+"]");
        return exceptionCount;
    }

    /**
     *Sorts out the various rules as to what the adjusted cost should actually be set to based off the
     *distributor pricing model and the setup as to how/if to convert the unit of measure, i.e. divide it
     *out into eaches or not
     *@returns the number of exceptions encountered
     */
    public int setItemAdjustedCost(TradingPartnerData pTradingPartnerData,
    Object obj, OrderItemData itemMatch, List itemNotesToLog, List invoiceNotesToLog,
    DistributorData pDistributor) throws RemoteException {
        int exceptionCount = 0;
        //convert the UOM
        if(pTradingPartnerData != null && RefCodeNames.UOM_CONVERSION_TYPE_CD.CONVERT_UOM_TO_EACH.equals(pTradingPartnerData.getUomConversionTypeCd())){
            int pack = 0;
            try{
                if(Utility.isSet(itemMatch.getDistItemPack())){
                    pack = Integer.parseInt(itemMatch.getDistItemPack());
                }else if(Utility.isSet(itemMatch.getItemPack())){
                    pack = Integer.parseInt(itemMatch.getItemPack());
                }
            }catch(RuntimeException e){}
            if(pack > 1){
                int newExceptionCt = convertCostAndQty(new BigDecimal(pack), obj, itemNotesToLog,true, true);
                exceptionCount += newExceptionCt;
                if(newExceptionCt > 0){
                    if(obj instanceof InvoiceDistDetailData){
                        ((InvoiceDistDetailData) obj).setItemUom(itemMatch.getItemUom());
                        //((InvoiceDistDetailData) obj).setDistItemUom(itemMatch.getItemUom());
                    }else{
                        ((AckItemData) obj).setUom(itemMatch.getItemUom());
                    }
                }
            }
        }else if(itemMatch.getDistUomConvMultiplier() != null && itemMatch.getDistUomConvMultiplier().compareTo(ONE) != 0){
            exceptionCount += convertCostAndQty(itemMatch.getDistUomConvMultiplier(), obj, itemNotesToLog,false,true);
            //there is a lot less logic we need to go into for an ackknowledgement.
            //for an ack request, just reset quantities and costs.
            //For the invoice request we need to hold the invoice if it has not been shipped complete
            if(obj instanceof InvoiceDistDetailData){

            }
        }

        return exceptionCount;
    }

    private void insertInvoiceDistDetailAndProperties(Connection conn,
    InvoiceDistDetailDescDataVector items,int defaultInvoiceDistId,OrderData orderMatch)throws SQLException {
        Iterator it = items.iterator();
        while(it.hasNext()){
            InvoiceDistDetailDescData itemDesc = (InvoiceDistDetailDescData) it.next();

            InvoiceDistDetailData invDetailD = itemDesc.getInvoiceDistDetail();
            List itemNotesToLog = itemDesc.getInvoiceDistDetailNotes();
            int invoiceDId;
            if(invDetailD.getInvoiceDistId() == 0){
                invoiceDId = defaultInvoiceDistId;
            }else{
                invoiceDId = invDetailD.getInvoiceDistId();
            }
            OrderItemData itemMatch = itemDesc.getOrderItem();
            invDetailD.setAddBy("system 16");
            invDetailD.setInvoiceDistId(invoiceDId);
            InvoiceDistDetailDataAccess.insert(conn, invDetailD);
            log.debug("Inserting invoice dist detail: " + invDetailD.getInvoiceDistId() + "::" +invDetailD.getInvoiceDistDetailId());

            // log invoice item exception to order property table
            for (int j = 0; j < itemNotesToLog.size(); j++) {
                String notes = (String)itemNotesToLog.get(j);
                log.info(notes);

                int itemId = 0;
                if(itemMatch != null){
                    itemId = itemMatch.getOrderItemId();
                }


                OrderDAO.enterOrderProperty(conn,
                RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                "Inbound EDI 810 Note", notes,
                orderMatch.getOrderId(), itemId,
                invoiceDId,
                invDetailD.getInvoiceDistDetailId(),
                0, 0, 0, "");
            }
        }
    }






    private DistributorData getDistributorData(Connection conn, int pBusEntityId, String pErpNum, Map paramMap)
    throws Exception{
        DistributorBean distBean = new DistributorBean();
        DistributorData d = null;
        if(pBusEntityId != 0){
            String key = DistributorData.class.getName() + pBusEntityId;
            d = (DistributorData) paramMap.get(key);
            if(d == null){
            	log.debug("Getting distributor id: " + pBusEntityId);
                d = distBean.getDistributor(pBusEntityId,conn);
                paramMap.put(key,d);
            }else{
            	log.debug("Using Cached distributor id: " + pBusEntityId);
            }
        }else if(Utility.isSet(pErpNum)){
            String key = DistributorData.class.getName() + "ERP" + pErpNum;
            d = (DistributorData) paramMap.get(key);
            if(d == null){
            	log.debug("Getting distributor erp: " + pErpNum);
                d = distBean.getDistributorByErpNum(pErpNum,conn);
                paramMap.put(key,d);
            }else{
            	log.debug("Using Cached distributor erp: " + pErpNum);
            }
        }
        return d;
    }

    /**
     *Matches the distributor line number to a order item
     */
    private OrderItemData matchDistributorInvoiceItem(InvoiceDistDetailData invDetailD,
    List itemNotesToLog, List notesToLog, OrderItemDataVector poItems, OrderData matchOrder,
    Connection conn, Map paramMap)
    throws Exception{
        // Validate that we have the fields needed to look up the
        // order item record.  If not, set flag so we won't
        // try to look the record up.
        int poLineNumber = invDetailD.getErpPoLineNum();
        int cwSku = invDetailD.getItemSkuNum();
        String vendorSku = invDetailD.getDistItemSkuNum();
        boolean haveRequiredFields = true;
        int exceptionCount = 0;
        OrderItemDataVector itemsMatch = null;
        String notes = null;

        // check if both cw sku and vendor sku are missing
        if (cwSku == 0 && !Utility.isSet(vendorSku)) {
            haveRequiredFields = false;
            itemNotesToLog.add("Missing System Sku and Vendor Sku.");
            exceptionCount++;
        }

        OrderItemData itemMatch = null;

        if(haveRequiredFields){
            // First try to match on po line number and one of the SKUs.
            // This will try to match against either the cwSku or the
            // vendorSku, in either the "main" or the sub fields in the
            // database.
        	log.debug("#### Searching by PO line and SKUs: poLine#=" +poLineNumber + " System Sku=" + cwSku +" vendorSku=" + vendorSku);
            itemsMatch = getOrderItemByPoLineNumberAndSku(
            poLineNumber, cwSku, vendorSku,
            poItems);

            // If we don't have the po line number or couldn't get a
            // match on it, try just the SKU numbers without the po
            // line number.
            if (itemsMatch.size() == 0) {
                itemsMatch = getOrderItemBySku(cwSku, vendorSku,
                poItems);
                log.debug("#### Searching by SKUs: System Sku=" +cwSku + " vendorSku=" + vendorSku);
            }

            // At this point we *might* have some kind of match
            if (itemsMatch.size() == 1) {
                itemMatch = (OrderItemData)itemsMatch.get(0);
            } else if (itemsMatch.size() > 1) {
                notes = "Found multiple matching order item records.\n";
                notes += "Possible order item ids:";

                for (int x = 0; x < itemsMatch.size(); x++) {
                    notes += " " + ((OrderItemData)itemsMatch.get(
                    x)).getOrderItemId();
                }

                itemNotesToLog.add(notes);
                exceptionCount++;
            } else {

                // Try to find a substitution.
                int contractId = matchOrder.getContractId();
                log.debug("#### Searching by PO line: poLine#=" + poLineNumber);
                itemsMatch = getOrderItemByPoLineNumber(poLineNumber, poItems);

                if (itemsMatch.size() > 1) {
                    notes = "Found multiple matching order item records for line # " + poLineNumber + ".\n";
                    notes += "Possible order item ids:";

                    for (int x = 0; x < itemsMatch.size(); x++) {
                        notes += " " + ((OrderItemData)itemsMatch.get(x)).getOrderItemId();
                    }

                    itemNotesToLog.add(notes);
                    exceptionCount++;
                } else if (itemsMatch.size() == 1) {

                    if (isApprovedSubWithItem(contractId,
                    itemMatch.getItemId(),
                    cwSku, vendorSku,
                    conn, paramMap)) {
                        itemMatch = (OrderItemData)itemsMatch.get(0);
                    }else{
                        itemMatch = (OrderItemData)itemsMatch.get(0);
                        exceptionCount++;
                        itemNotesToLog.add("Match based off po line, but not a valid substitution");
                    }
                }

                if (itemsMatch.size() == 0) {
                    itemsMatch = getApprovedSubstitutionItems(
                    contractId, poItems,
                    cwSku, vendorSku, conn, paramMap);
                    log.debug("#### Get Approved Substition Item: itemsMatch#=" +itemsMatch);
                }

                if (itemsMatch.size() == 1) {
                    itemMatch = (OrderItemData)itemsMatch.get(0);
                } else if (itemsMatch.size() > 1) {
                    notes = "Found multiple matching order item records for approved substitution.\n";
                    notes += "Possible order item ids:";

                    for (int x = 0; x < itemsMatch.size(); x++) {
                        notes += " " + ((OrderItemData)itemsMatch.get(
                        x)).getOrderItemId();
                    }

                    itemNotesToLog.add(notes);
                    exceptionCount++;
                } else { // no order item match found
                    notes = "No matching order item or approved substitution found for" +
                    " SKUs: System Sku=" + cwSku +
                    " Vendor Sku=" + vendorSku;
                    itemNotesToLog.add(notes);
                    exceptionCount++;
                }
            }
        }
        if(exceptionCount > 0){
            throw new Exception("Exception count greater than 0");
        }
        return itemMatch;
    }

    /**
     *Inserts the distributor invoice notes that may have been generated
     */
    private void insertDistributorInvoiceNotes(Connection conn, InvoiceDistData invoiceD, OrderData matchOrder, List notesToLog, Map miscInvoiceNotes)
    throws SQLException{
    	int orderId = invoiceD.getOrderId();
    	if(orderId == 0){
    		orderId = matchOrder == null ? 0 : matchOrder.getOrderId();
    	}

        // log invoice item exception to order property table, use iterator as this is most likely
        // a linked list, which doesn't handle random access efficiently
        Iterator it = notesToLog.iterator();
        while(it.hasNext()){
            String notes = (String) it.next();
            log.error(notes);
            OrderDAO.enterOrderProperty(conn,
            RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
            "Inbound EDI 810 Messeges", notes, orderId,
            0, invoiceD.getInvoiceDistId(), 0, 0, 0, 0,
            "");
        }

        //log misc notes
        it = miscInvoiceNotes.keySet().iterator();
        while(it.hasNext()){
            String propName = (String) it.next();
            List l = (List) miscInvoiceNotes.get(propName);
            Iterator it2 = l.iterator();
            while(it2.hasNext()){
                String val = (String) it2.next();
                OrderDAO.enterOrderProperty(conn,
                propName,
                propName, val, orderId,
                0, invoiceD.getInvoiceDistId(), 0, 0, 0, 0,
                "");
            }
        }
    }

    /**
     *Inserts a distributor invoice, does much of the post processing of the invoice, freight,
     *makes sure subtotal is updated according to any reset item subtotals etc etc.
     */
    private InvoiceDistData insertInvoiceDistData(Connection conn,InvoiceDistData invoiceD,
            int exceptionCount, BigDecimal recvdTotal, List notesToLog, List insertedInvoices, boolean checkDuplInvoiceNum)
    throws SQLException, RemoteException{

        //BigDecimal vendorTotal = invoiceD.getSubTotal();

        // check if a invoice with same invoice number exists in the table
        int storeId = invoiceD.getStoreId();
        if (checkDuplInvoiceNum){

	        InvoiceDistDataVector existingInvoices =
	                existingInvoiceFound(invoiceD.getInvoiceNum(), invoiceD.getErpPoNum(), storeId, conn,insertedInvoices);
	        //we'll find at least one as the data has already been inserted into the database
	        //THIS WAS CHANGED, now we only insert once, and don't update it after the fact
	        recvdTotal = recvdTotal == null ? new BigDecimal(0).setScale(2) : recvdTotal.setScale(2,BigDecimal.ROUND_HALF_UP);
	        //vendorTotal = vendorTotal == null ? new BigDecimal(0).setScale(2) : vendorTotal.setScale(2,BigDecimal.ROUND_HALF_UP);
	
	        if (existingInvoices.size() > 0) {
	        	//String sql = "select sum("+InvoiceDistDetailDataAccess.ITEM_RECEIVED_COST+"*"+InvoiceDistDetailDataAccess.DIST_ITEM_QTY_RECEIVED+") "+
	            //" FROM "+InvoiceDistDetailDataAccess.CLW_INVOICE_DIST_DETAIL+" WHERE "+ InvoiceDistDetailDataAccess.INVOICE_DIST_ID+"=?";
	        	//PreparedStatement stmt = conn.prepareStatement(sql);
	            boolean foundDup = false;
	            for(int i=0;i<existingInvoices.size();i++){
	                InvoiceDistData existing = (InvoiceDistData) existingInvoices.get(i);
	                //stmt.setInt(1,existing.getInvoiceDistId());
	                //ResultSet rs = stmt.executeQuery();
	                BigDecimal existingRecievedTot = existing.getSubTotal();
	
	                //if(rs.next()){
	                //	existingRecievedTot = rs.getBigDecimal(1);
	                //}
	                //rs.close();
	                log.debug("------->comparing"+existingRecievedTot+" and " +recvdTotal);
	                if(existingRecievedTot != null && recvdTotal != null){
	                	existingRecievedTot = existingRecievedTot.setScale(2,BigDecimal.ROUND_HALF_UP);
	                	recvdTotal = recvdTotal.setScale(2,BigDecimal.ROUND_HALF_UP);
	                	double remainder = recvdTotal.subtract(existingRecievedTot).abs().doubleValue();
	                	if(remainder < .02){
	                            if(storeId>0) {
	                		log.debug("It is a duplicate");
	                		notesToLog.add(
	                                "Found existing invoice record(s) for vendor invoice number: " +
	                                invoiceD.getInvoiceNum() + " and erp po number: " +
	                                invoiceD.getErpPoNum());
	                                invoiceD.setInvoiceStatusCd(RefCodeNames.INVOICE_STATUS_CD.DUPLICATE);
	                            } else {
	                		notesToLog.add(
	                                "Found existing invoice record(s) for vendor invoice number: " +
	                                invoiceD.getInvoiceNum() + " and erp po number: " +
	                                invoiceD.getErpPoNum() + " Found invoice store id: "+existing.getStoreId());
	                                invoiceD.setInvoiceStatusCd(RefCodeNames.INVOICE_STATUS_CD.PENDING_REVIEW);
	                            }
	                        foundDup = true;
	                        break;
	                	}
	                }
	            }
	            //stmt.close();
	
	
	            if(!foundDup){
	                exceptionCount++;
	                notesToLog.add(
	                "Found existing invoice record(s) for vendor invoice number: " +
	                invoiceD.getInvoiceNum() + " and erp po number: " +
	                invoiceD.getErpPoNum() + " and the sub totals were not equal");
	            }
	        }
        }

        invoiceD.setSubTotal(recvdTotal);


        //if it is a dup don't log it as an exception
        log.debug("BEFORE: " + invoiceD.getInvoiceStatusCd());
        if (exceptionCount > 0 && !invoiceD.getInvoiceStatusCd().equals(RefCodeNames.INVOICE_STATUS_CD.DUPLICATE)) {
            invoiceD.setInvoiceStatusCd(
                    RefCodeNames.INVOICE_STATUS_CD.PENDING_REVIEW);
        } else if(!Utility.isSet(invoiceD.getInvoiceStatusCd())){
            invoiceD.setInvoiceStatusCd(
                    RefCodeNames.INVOICE_STATUS_CD.DIST_SHIPPED);
        }
        log.debug("AFTER: " + invoiceD.getInvoiceStatusCd());

        if(invoiceD.getInvoiceDistId() > 0){
            InvoiceDistDataAccess.update(conn, invoiceD);
        }else{
            invoiceD = InvoiceDistDataAccess.insert(conn, invoiceD);
        }
        return invoiceD;
    }


    /**
     *Processes a 997 request
     */
    private boolean process997Acknowledge(Ack997Data pAck997D, Connection con)
                                   throws RemoteException {

    	log.info("process997Acknowledge");
        // constant to define the status of a transaction set
        int ACKA_MSG = 3;
        int ACKE_MSG = 4;
        int ACKR_MSG = 5;
        ElectronicTransactionDataVector transactionDV = getTransactionsAcked(pAck997D.getGroupSender(),
                                                                             pAck997D.getGroupReceiver(),
                                                                             pAck997D.getSetType(),
                                                                             new Integer(pAck997D.getGroupControlNumber()),
                                                                             new Integer(pAck997D.getSetControlNumber()),
                                                                             con);

        if (transactionDV == null || transactionDV.size() == 0) {
            log.error(
                    "Failed to process inbound 997 acknowledgement. Nooutbound " +
                    "transaction found for Group Sender Id = " +
                    pAck997D.getGroupSender() + ", Group Receiver Id = " +
                    pAck997D.getGroupReceiver() + ", Set type = " +
                    pAck997D.getSetType() + ", Group Control Number = " +
                    pAck997D.getGroupControlNumber() +
                    " and Set Control Number = " +
                    pAck997D.getSetControlNumber());

            return false;
        }

        for (int i = 0; i < transactionDV.size(); i++) {

            ElectronicTransactionData transaction = (ElectronicTransactionData)transactionDV.get(
                                                            i);

            if (transaction.getSetStatus() != 1) {
                log.info("Failed to process inbound 997 acknowledgement. Transaction " +
            	"has been acknowledged previously for Group Sender Id = " +
            	pAck997D.getGroupSender() +
            	", Group Receiver Id = " +
            	pAck997D.getGroupReceiver() + ", Set type = " +
            	pAck997D.getSetType() + ", Group Control Number = " +
            	pAck997D.getGroupControlNumber() +
            	" and Set Control Number = " +
            	 pAck997D.getSetControlNumber());

                return false;
            }

            if (pAck997D.getAckCode().equals("A"))
                transaction.setSetStatus(ACKA_MSG); //accepted ok
            else if (pAck997D.getAckCode().equals("E"))
                transaction.setSetStatus(ACKE_MSG); //accepted with issue
            else if (pAck997D.getAckCode().equals("R"))
                transaction.setSetStatus(ACKR_MSG); //rejected

            try {
                ElectronicTransactionDataAccess.update(con, transaction);
            } catch (Exception exc) {
                log.error("exc.getMessage");
                exc.printStackTrace();
                throw new RemoteException("Error. process997Acknowledge() Exception happened. " +
                                          exc.getMessage());
            }
            //Update order item status
            if("850".equals(transaction.getSetType())) {
              int orderId = transaction.getOrderId();
              String keyStr = transaction.getKeyString();
              String poNum = null;
              if(keyStr!=null) {
                int erpInd = keyStr.indexOf("ErpPoNumber:");
                if(erpInd>=0) {
                  erpInd += "ErpPoNumber:".length();
                  int erpEnd = keyStr.indexOf(',',erpInd);
                  if(erpEnd>erpInd) {
                    poNum = keyStr.substring(erpInd,erpEnd).trim();
                  }
                }
              }
              if(orderId>0 && poNum!=null) {
                DBCriteria dbc = new DBCriteria();
                dbc.addEqualTo(OrderItemDataAccess.ORDER_ID,orderId);
                dbc.addEqualTo(OrderItemDataAccess.ERP_PO_NUM,poNum);
                try {
                  OrderItemDataVector oiDV = OrderItemDataAccess.select(con,dbc);
                  if(oiDV.size()>0) {
                    for(int jj=0; jj<oiDV.size(); jj++) {
                      OrderItemData oiD = (OrderItemData) oiDV.get(jj);
                      if(RefCodeNames.ORDER_ITEM_STATUS_CD.SENT_TO_DISTRIBUTOR.equals(oiD.getOrderItemStatusCd())){
                        if (pAck997D.getAckCode().equals("A"))
                           oiD.setOrderItemStatusCd(RefCodeNames.ORDER_ITEM_STATUS_CD.PO_ACK_SUCCESS);
                        else if (pAck997D.getAckCode().equals("E"))
                           oiD.setOrderItemStatusCd(RefCodeNames.ORDER_ITEM_STATUS_CD.PO_ACK_ERROR);
                        else if (pAck997D.getAckCode().equals("R"))
                           oiD.setOrderItemStatusCd(RefCodeNames.ORDER_ITEM_STATUS_CD.PO_ACK_REJECT);
                        OrderItemDataAccess.update(con, oiD);
                      }
                    }
                  } else {
                   String msg = "IntegrationServicesBean.process997Acknowledge. "+
                                "Error. Can't find order items for the order. Order Id: "+orderId+
                               " Po number: "+poNum;
                   log.error(msg);
                  }
                }catch(SQLException exc) {
                  exc.printStackTrace();
                }
             }
          }
        }

        return true;
    }

    public TradingPartnerDescView getTradingProfileConfig(int profileId,
                                                            String setType,
                                                            String direction)
                                                     throws RemoteException {

        Connection con = null;
        DBCriteria dbc;
        //TradingProfileConfigData profileConfigD = null;
        try {
            con = getConnection();
            dbc = new DBCriteria();

            dbc.addEqualTo(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, profileId);
            dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);
            dbc.addEqualTo(TradingProfileConfigDataAccess.DIRECTION, direction);

            log.debug(TradingProfileConfigDataAccess.getSqlSelectIdOnly("*",dbc));
            TradingProfileConfigDataVector profileConfigDV =
                    TradingProfileConfigDataAccess.select(con, dbc);

            if (profileConfigDV.size() >= 1) {
                TradingPartnerDescView ret = TradingPartnerDescView.createValue();
                TradingProfileConfigData config = (TradingProfileConfigData)profileConfigDV.get(0);
                ret.setTradingProfileConfigData(config);
                ret.setTradingPropertyMapDataVector(TradingPropertyMapDataAccess.select(con,dbc));
                ret.setTradingProfileData(TradingProfileDataAccess.select(con, config.getTradingProfileId()));
                ret.setTradingPartnerData(TradingPartnerDataAccess.select(con, ret.getTradingProfileData().getTradingPartnerId()));
                return ret;
            } else if (profileConfigDV.size() == 0) {
                return null;
            }
        } catch (NamingException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getTradingProfileConfig() Naming Exception happened. " +
                                      exc.getMessage());
        } catch (DataNotFoundException exc) {
        	log.error("exc.getMessage");
        	exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getTradingProfileConfig() DataNotFoundException happened. " +
            		exc.getMessage());
        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getTradingProfileConfig() SQL Exception happened. " +
                                      exc.getMessage());
        } finally {
        	closeConnection(con);
        }

        return null;
    }

    private int getPartnerId(String erpNum, int busEntityId, String entityType, Connection conn, boolean applicationTradingPartner, boolean outbound)
        throws RemoteException {
           return getPartnerId(erpNum, busEntityId, entityType, conn, applicationTradingPartner, null, outbound);
    }


    private int getPartnerId(String erpNum, int busEntityId, String entityType, Connection conn, boolean applicationTradingPartner, Map paramMap, boolean outbound)
    throws RemoteException {
        return getPartnerId(erpNum, busEntityId, entityType, conn, applicationTradingPartner, paramMap, outbound, null);
    }

    private int getPartnerId(String erpNum, int busEntityId, String entityType, Connection conn, boolean applicationTradingPartner, Map paramMap, boolean outbound, String optSetType)
                     throws RemoteException {

        DBCriteria dbc;
        log.debug("getPartnerId ------- erpNum="+erpNum);
        try {
            dbc = new DBCriteria();
            if(applicationTradingPartner){
                dbc.addEqualTo(TradingPartnerDataAccess.TRADING_PARTNER_TYPE_CD,RefCodeNames.TRADING_PARTNER_TYPE_CD.APPLICATION);
                dbc.addEqualTo(TradingPartnerDataAccess.TRADING_PARTNER_STATUS_CD,RefCodeNames.TRADING_PARTNER_STATUS_CD.ACTIVE);
            }else{
                if(busEntityId == 0){
                    DBCriteria bedbc = new DBCriteria();
                    bedbc.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, entityType);
                    if(outbound){
                        bedbc.addEqualTo(BusEntityDataAccess.BUS_ENTITY_STATUS_CD,RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
                    }
                    bedbc.addEqualTo(BusEntityDataAccess.ERP_NUM, erpNum);
                    String busEntReq = BusEntityDataAccess.getSqlSelectIdOnly(BusEntityDataAccess.BUS_ENTITY_ID,bedbc);
                    dbc.addOneOf(TradingPartnerAssocDataAccess.BUS_ENTITY_ID,busEntReq);
                }else{
                    dbc.addEqualTo(TradingPartnerAssocDataAccess.BUS_ENTITY_ID,busEntityId);
                }

                String tpAssocReq = TradingPartnerAssocDataAccess.getSqlSelectIdOnly(TradingPartnerAssocDataAccess.TRADING_PARTNER_ID,dbc);

                dbc = new DBCriteria();
                dbc.addOneOf(TradingPartnerDataAccess.TRADING_PARTNER_ID, tpAssocReq);
                dbc.addNotEqualTo(TradingPartnerDataAccess.TRADING_PARTNER_STATUS_CD,
                        RefCodeNames.TRADING_PARTNER_STATUS_CD.INACTIVE);

                //If the set type is speciied only return trading partners that support said set type
                if(Utility.isSet(optSetType)){
                    DBCriteria stdbc = new DBCriteria();
                    String tpc = TradingProfileConfigDataAccess.CLW_TRADING_PROFILE_CONFIG;
                    String tp = TradingProfileDataAccess.CLW_TRADING_PROFILE;
                    stdbc.addJoinTableEqualTo(tpc,TradingProfileConfigDataAccess.SET_TYPE,optSetType);
                    stdbc.addJoinCondition(tpc,TradingProfileConfigDataAccess.TRADING_PROFILE_ID,tp, TradingProfileDataAccess.TRADING_PROFILE_ID);
                    stdbc.addDataAccessForJoin(new TradingPartnerDataAccess());
                    stdbc.addDataAccessForJoin(new TradingProfileConfigDataAccess());
                    String stsql = JoinDataAccess.getSqlSelectIdOnly(tp, TradingProfileDataAccess.TRADING_PARTNER_ID, stdbc);
                    dbc.addOneOf(TradingPartnerDataAccess.TRADING_PARTNER_ID, stsql);
                }
            }
            String key = TradingPartnerDataAccess.getSqlSelectIdOnly("",dbc);
            Integer partnerId = null;
            if(paramMap != null){
                partnerId = (Integer)paramMap.get(key);
                log.debug(">>>>>>>>>>>>Cached Value: key("+key+")::" + partnerId);
            }
    log.debug("IntegrationServicesBean >>>>>>>>>>>>>>>>>>>>>>>>>>>>> tp sql: "+TradingPartnerDataAccess.getSqlSelectIdOnly("*",dbc)+ " partnerId=" + partnerId );
            if(partnerId == null){
                IdVector tpIds = TradingPartnerDataAccess.selectIdOnly(conn, dbc);
                if (tpIds.size() == 0) {
                    log.error("No Tranding partner set up for entity type = " +entityType + " and erp num = " + erpNum);
                    //throw new RemoteException("Error. IntegrationServicesBean.getPartnerId() throw Exception.");
                    return 0;
                } else if (tpIds.size() > 1) {
                    log.error("More than one Tranding partner found for entity type = " +entityType + " and erp num = " + erpNum);
                    throw new RemoteException("Error. IntegrationServicesBean.getPartnerId() throw Exception.");
                }
                partnerId = (Integer)tpIds.get(0);
                if(paramMap != null){
                    paramMap.put(key, partnerId);
                }
		log.debug("found partnerId=" + partnerId+ " for erpNum=" + erpNum );
            }

            return partnerId.intValue();

        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getPartnerId() SQL Exception happened. " +
                                      exc.getMessage());
        }
    }

    /**
     *Returns a lightly populated TradingPartnerDescView object where the config is populated and the
     *TradingPropertyMapDataVector property is populated
     */
    public TradingPartnerDescView getOutboundTradingProfileConfig(String erpNum,
                                                                    int busEntityId,
                                                                    int incommingProfileId,
                                                                    String setType)
        throws RemoteException {

        Connection conn = null;
        DBCriteria dbc;

        try {
            conn = getConnection();

            String entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT;

            if (setType.equals("850")) {
                entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR;
            }

            if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_SEND_TO_EXT_CUST_SYS)) {
                entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.STORE;
            }

            int partnerId;
            if(setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT) ||
            setType.equals(RefCodeNames.EDI_TYPE_CD.TMANIFEST_OUT)
            ) {
                log.debug("looking for app tp");
                entityType = null;
                partnerId = getPartnerId(erpNum,busEntityId, entityType, conn, true,true);

            }else{
                log.debug("NOT  looking for app tp"+ " erpNum=" + erpNum+ " busEntityId=" + busEntityId+ " entityType=" + entityType+ " setType=" + setType);
                partnerId = getPartnerId(erpNum,busEntityId, entityType, conn, false, null, true, setType);
            }

            DBCriteria mapDbc = new DBCriteria();
            dbc = new DBCriteria();
            dbc.addEqualTo(TradingProfileDataAccess.TRADING_PARTNER_ID, partnerId);

            IdVector profileIds = TradingProfileDataAccess.selectIdOnly(conn, dbc);

            if (profileIds.size() == 0) {
                log.error("Could not find profile for partner id: " + partnerId);
                return null;
            }

            dbc = new DBCriteria();

            //mapDbc.addEqualToIgnoreCase(TradingPropertyMapDataAccess.DIRECTION, "out");
            //dbc.addEqualToIgnoreCase(TradingProfileConfigDataAccess.DIRECTION, "out");
            if (profileIds.size() == 1) {
                dbc.addEqualTo(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, (Integer)profileIds.get(0));
                dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);

                mapDbc.addEqualTo(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, (Integer)profileIds.get(0));
                mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);
            } else {
                if (incommingProfileId > 0 && RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT.equals(entityType)) {
                    dbc.addEqualTo(TradingProfileConfigDataAccess.INCOMING_TRADING_PROFILE_ID, incommingProfileId);
                    dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);

                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, incommingProfileId);
                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);

                } else {
                    dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);
                    dbc.addOneOf(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, profileIds);

                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);
                    mapDbc.addOneOf(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, profileIds);
                }
            }
            mapDbc.addOrderBy(TradingPropertyMapDataAccess.ORDER_BY,true);

            log.info(TradingProfileConfigDataAccess.getSqlSelectIdOnly("*", dbc));
            TradingProfileConfigDataVector profileConfigDV =
                    TradingProfileConfigDataAccess.select(conn, dbc);

            if (profileConfigDV.size() >= 1) {
                TradingPartnerDescView ret = TradingPartnerDescView.createValue();
                TradingProfileConfigData config = (TradingProfileConfigData)profileConfigDV.get(0);
                ret.setTradingProfileConfigData(config);
                ret.setTradingPropertyMapDataVector(TradingPropertyMapDataAccess.select(conn,mapDbc));
                return ret;
            } else {
                log.error("Could not find TradingProfileConfigData.");
                return null;
            }
        } catch (NamingException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getOutboundTradingProfileConfig() Naming Exception happened. " +
                                      exc.getMessage());
        }
         catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getOutboundTradingProfileConfig() SQL Exception happened. " +
                                      exc.getMessage());
        } finally {
        	closeConnection(conn);
        }
    }

    /**takes in a OrderDataVector and finds all of the associated data necessary
    *for outbound 850 type transactions (pos,850s,xml,etc.)
    *@param ignoreStatus should almst certainly be false.  This would be true only if you wanted to grab transactions
    *	regardless of the status (for example if don't care if you have sent the order before)
    */
    public OutboundEDIRequestDataVector
        populateOutboundTransactionDataFromOrderDataVector
        (OrderDataVector orderDV,String erpNum,
         Connection conn,String setType, boolean ignoreStatus)
        throws SQLException,RemoteException{  //hello

                HashMap storeMap = new HashMap();
                HashMap cache = new HashMap();
                DBCriteria crit = new DBCriteria();
                crit.addEqualTo(BusEntityDataAccess.ERP_NUM,erpNum);
                crit.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD,
                    RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);

                BusEntityData dist = Utility.getBestbusEntityData(BusEntityDataAccess.select(conn,crit));
                String distCompCo = null;
                String distributorName = null;
                if(dist != null){
                	distributorName = dist.getShortDesc();
                    PropertyUtil pru = new PropertyUtil(conn);
                    try{
                        distCompCo = pru.fetchValue(0,dist.getBusEntityId(), RefCodeNames.PROPERTY_TYPE_CD.DISTRIBUTORS_COMPANY_CODE);
                    }catch(DataNotFoundException e){
                        //it will remain null
                    }
                }

                TreeMap sorted850Order = new TreeMap();
                log.debug("orderDV.size()::"+orderDV.size());
                boolean limitItemsByDistributor = true;
                if(setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT) ||
                    setType.equals(RefCodeNames.EDI_TYPE_CD.TPUNCH_OUT_ORDER_OUT) ||
                    setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_SEND_TO_EXT_CUST_SYS)||
                    setType.equals(RefCodeNames.EDI_TYPE_CD.T856_SENT) ){
                    limitItemsByDistributor = false;
                }
                //cache for lookup of dist ref info
                HashMap<String, String> distCustomerRefCode = new HashMap();

                for (int i = 0; i < orderDV.size(); i++) {


                    OrderData order = (OrderData)orderDV.get(i);
                    log.debug("populating order::"+i+"::"+order.getOrderId());

                    //get site data
                    int siteId = order.getSiteId();
                    DBCriteria spropCrit = new DBCriteria();
                    spropCrit.addEqualTo(
                        PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                    spropCrit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,siteId);
                    PropertyDataVector siteProperties = PropertyDataAccess.select(conn,spropCrit);

                    //get the item data
                    int orderId = order.getOrderId();
                    DBCriteria dbc = new DBCriteria();
                    if(!limitItemsByDistributor){
                        dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, orderId);
                        if(setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT) || setType.equals(RefCodeNames.EDI_TYPE_CD.TPUNCH_OUT_ORDER_OUT)){
                            dbc.addCondition(Utility.getGoodOrderItemsCondition());
                        }
                    }else{
                        dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, orderId);
                        if(Utility.isSet(erpNum)){
                            dbc.addEqualTo(OrderItemDataAccess.DIST_ERP_NUM, erpNum);
                        }
                        //ignore the line status.  If this is set we are not doing state managment of the order item.
                        if(ignoreStatus){
                            dbc.addCondition(Utility.getGoodOrderItemsCondition());
                        }else{
                            dbc.addEqualTo(OrderItemDataAccess.ORDER_ITEM_STATUS_CD,RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT);
                        }
                        dbc.addOrderBy(OrderItemDataAccess.ERP_PO_LINE_NUM);
                    }
                    OrderItemDataVector tempItemDV = OrderItemDataAccess.select(conn, dbc);

                    log.debug(OrderItemDataAccess.getSqlSelectIdOnly("*", dbc));
                    log.debug("tempItemDV.size()::"+tempItemDV.size());

                    if(!limitItemsByDistributor && tempItemDV.isEmpty()){
                        log.debug(OrderItemDataAccess.getSqlSelectIdOnly("*", dbc));
                        log.debug("Not processing orderId: "+orderId);
                    }

                    if (tempItemDV.size() > 0) {

                        HashMap</*distibutor erp number*/String, /*distributor id*/Integer> distIdForDistErpNum = new HashMap();
                        HashMap</*distibutor erp number*/String, /*cumulative discount*/BigDecimal> discountForDistErpNum = new HashMap();
                        HashMap</*distibutor erp number*/String, /*cumulative item price*/BigDecimal> itemPriceForDistErpNum = new HashMap();
                        HashMap</*contract id*/Integer, /*catalog id*/Integer> catalogIdForContract = new HashMap();

                        OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();

                        //get dist cust ref code
                        for(int t=0; t<tempItemDV.size(); t++){

                            OrderItemData oid = (OrderItemData)tempItemDV.get(t);
                            String distErpNum = oid.getDistErpNum();
                            String custRefCode="";
                            if(distCustomerRefCode.containsKey(distErpNum)){
                                custRefCode = distCustomerRefCode.get(distErpNum);
                                ///
                                BigDecimal itemsPrice = itemPriceForDistErpNum.get(distErpNum);
                                //log.info("***SVC: itemsPrice = " + itemsPrice);
                                //if (oid.getDistItemCost() != null) { // was here before
                                if (oid.getDistItemCost() != null && itemsPrice != null) { //added by SVC
                                	//log.info("*****SVC: oid.getDistItemCost() = " + oid.getDistItemCost());
                                    itemsPrice = itemsPrice.add(oid.getDistItemCost());
                                    itemPriceForDistErpNum.put(distErpNum, itemsPrice);
                                }
                            }else{
                                DBCriteria dCrit = new DBCriteria();
                                dCrit.addOneOf(BusEntityDataAccess.ERP_NUM, "'"+distErpNum+"'");
                                dCrit.addContains(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
                                //String distId = BusEntityDataAccess.getSqlSelectIdOnly(BusEntityDataAccess.BUS_ENTITY_ID, dCrit);
                                IdVector distributorIds = BusEntityDataAccess.selectIdOnly(conn, dCrit);

                                int itemDistributrId = ((Integer)distributorIds.get(0)).intValue();
                                String distId = distributorIds.get(0).toString();

                                if(distId.length()!=0 || distId != null){

                                    dCrit = new DBCriteria();
                                    dCrit.addOneOf(PropertyDataAccess.BUS_ENTITY_ID, distId);
                                    dCrit.addLikeIgnoreCase(PropertyDataAccess.SHORT_DESC, RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_REFERENCE_CODE);

                                    //String custRefCode = PropertyDataAccess.getSqlSelectIdOnly(PropertyDataAccess.CLW_VALUE, dCrit);
                                    PropertyDataVector propsDV = PropertyDataAccess.select(conn, dCrit);
                                    for(int x=0; x<propsDV.size(); x++){
                                        PropertyData prop = (PropertyData)propsDV.get(x);
                                        custRefCode = prop.getValue();

                                    }

                                }
                                distCustomerRefCode.put(distErpNum, custRefCode);

                                ///
                                distIdForDistErpNum.put(distErpNum, new Integer(itemDistributrId));

                                ///
                                discountForDistErpNum.put(distErpNum, new BigDecimal(0));

                                ///
                                BigDecimal itemPrice = new BigDecimal(0);
                                if (oid.getDistItemCost() != null) {
                                    itemPrice = itemPrice.add(oid.getDistItemCost());
                                }
                                itemPriceForDistErpNum.put(distErpNum, itemPrice);
                            }
                            reqData.setDistributorCustomerReferenceCode(custRefCode);
                        }
                        
                        if (setType.equals(RefCodeNames.EDI_TYPE_CD.TPUNCH_OUT_ORDER_OUT)){
                        	Map genericMap = new HashMap();
                        	reqData.setGenericMap(genericMap);
                        	for(int t=0; t<tempItemDV.size(); t++){
                                OrderItemData oid = (OrderItemData)tempItemDV.get(t);
	                        	DBCriteria itemMetaDbc = new DBCriteria();
	                            itemMetaDbc.addEqualTo(ItemMetaDataAccess.ITEM_ID, oid.getItemId());
	                            itemMetaDbc.addEqualTo(ItemMetaDataAccess.NAME_VALUE, "UNSPSC_CD");
	                            ItemMetaDataVector itemMetaDataVector = ItemMetaDataAccess.select(conn, itemMetaDbc);
	                            if (itemMetaDataVector != null && itemMetaDataVector.size() > 0) {
	                                ItemMetaData itemMetaData = (ItemMetaData)itemMetaDataVector.get(0);
	                                genericMap.put("UNSPSC_CD"+":" + oid.getItemId(), itemMetaData.getValue());
	                            }
                        	}
                        }

                        /// To calculate discounts and fuel surcharges
                        log.info("*** Calculating Discounts and Fuel Surcharges ");
                        if (itemPriceForDistErpNum.size() > 0) {
                        	try{
                        		APIAccess mApiAccess = new APIAccess();
	                        	Distributor distEjb = mApiAccess.getDistributorAPI();
	                        	BigDecimal superTotalDiscount = new BigDecimal(0);
	                         	BigDecimal superTotalFuelSurcharge = new BigDecimal(0);
	                         	BigDecimal smallOrderFeeTotal = new BigDecimal(0);

	                            Iterator it = itemPriceForDistErpNum.keySet().iterator();
	                            while (it.hasNext()) {
	                                String distErpNumKey = (String)it.next();
	                                Integer distributorIdObj = (Integer)distIdForDistErpNum.get(distErpNumKey);

	                                OrderAddOnChargeDataVector addOnCharges = distEjb.getOrderAddOnCharges(
	                                		distributorIdObj.intValue(), orderId);
	                                if(addOnCharges!=null && addOnCharges.size()>0){
	                            		for(int k=0; k<addOnCharges.size(); k++){
	                            			OrderAddOnChargeData charge = (OrderAddOnChargeData)addOnCharges.get(k);
	                            			String chargeType = charge.getDistFeeChargeCd();
	                            			BigDecimal amount = charge.getAmount();
	                            			if (chargeType.equals(RefCodeNames.CHARGE_CD.DISCOUNT)){
	                            				superTotalDiscount = Utility.addAmt(superTotalDiscount, amount);
	                            			}
	                             			if (chargeType.equals(RefCodeNames.CHARGE_CD.FUEL_SURCHARGE)){
	                            				superTotalFuelSurcharge = Utility.addAmt(superTotalFuelSurcharge, amount);
	                            			}
	                             			if (chargeType.equals(RefCodeNames.CHARGE_CD.SMALL_ORDER_FEE)){
	                             				smallOrderFeeTotal = Utility.addAmt(smallOrderFeeTotal, amount);
	                            			}
	                            		}
	                            	}


	                            }
	                            reqData.setFuelSurcharge(superTotalFuelSurcharge);
	                            reqData.setDiscount(superTotalDiscount);
	                            reqData.setSmallOrderFee(smallOrderFeeTotal);

                            }catch(Exception e){
                        		log.error("ERROR:  " + e);
                        	}
                        }

                        /// Calculation of UPC-values for items
                        if (order.getContractId() > 0) {
                            Integer orderContractIdObj = new Integer(order.getContractId());
                            if (catalogIdForContract.containsKey(orderContractIdObj)) {
                                int itemCatalogId = ((Integer)catalogIdForContract.get(orderContractIdObj)).intValue();
                                for (int t = 0; t < tempItemDV.size(); ++t) {
                                    OrderItemData orderItemData = (OrderItemData)tempItemDV.get(t);
                                    String upcValue = null;
                                    ///
                                    DBCriteria itemMetaDbc = new DBCriteria();
                                    itemMetaDbc.addEqualTo(ItemMetaDataAccess.ITEM_ID, orderItemData.getItemId());
                                    itemMetaDbc.addEqualTo(ItemMetaDataAccess.NAME_VALUE, "UPC_NUM");
                                    ItemMetaDataVector itemMetaDataVector = ItemMetaDataAccess.select(conn, itemMetaDbc);
                                    if (itemMetaDataVector != null && itemMetaDataVector.size() > 0) {
                                        ItemMetaData itemMetaData = (ItemMetaData)itemMetaDataVector.get(0);
                                        upcValue = itemMetaData.getValue();
                                    }
                                    ///
                                    if (upcValue != null) {
                                        orderItemData.setManuItemUpcNum(upcValue);
                                    }
                                }
                            }
                        }

                        //get store type
                        int storeId = order.getStoreId();
                        Integer storeKey = new Integer(storeId);
                        String storeType = (String) storeMap.get(storeKey);
                        if(storeType != null){
                            reqData.setStoreTypeCd(storeType);
                        }else{
                            String val = null;
                            //dont use prop util as it will not find the store type cd property
                            DBCriteria lCrit = new DBCriteria();
                            lCrit.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,RefCodeNames.PROPERTY_TYPE_CD.STORE_TYPE);
                            lCrit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,storeId);
                            lCrit.addEqualTo(PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                            PropertyDataVector pdv = PropertyDataAccess.select(conn,lCrit);
                            if(!pdv.isEmpty()){
                                val = ((PropertyData)pdv.get(0)).getValue();
                            }
                            storeMap.put(storeKey,val);
                            log.debug(order.getOrderId()+"::"+order.getStoreId());
                            reqData.setStoreTypeCd(val);
                        }

                        ///
                        reqData.setOrderD(order);
                        reqData.setSiteProperties(siteProperties);
                        String erpPoNum = ((OrderItemData)tempItemDV.get(0)).getErpPoNum();
                        int thisOrderId = order.getOrderId();

                        if(order.getAccountId() > 0){
                            PropertyUtil pru = new PropertyUtil(conn);
                            String val = null;
                            val = pru.fetchValueIgnoreMissing(0,order.getAccountId(),RefCodeNames.PROPERTY_TYPE_CD.PURCHASE_ORDER_ACCOUNT_NAME);
                            if(!Utility.isSet(val)){
                                try{
                                    BusEntityData acct = BusEntityDataAccess.select(conn,order.getAccountId());
                                    if(acct != null){
                                        val = acct.getShortDesc();
                                    }
                                }catch(DataNotFoundException e){
                                	log.error("ERROR: Could not find account id "+order.getAccountId() + " for order id "+order.getOrderId());
                                    reqData.setAccountName(null);
                                }
                            }

						    else {
							// This account has a specific
							// name set up to send in the
							// outbound 850 records.
							reqData.setPoAccountName(val);
						    }
                            reqData.setAccountName(val);

                            DBCriteria aSubCrit = new DBCriteria();
                            aSubCrit.addEqualTo(PhoneDataAccess.BUS_ENTITY_ID,order.getAccountId());
                            aSubCrit.addEqualTo(PhoneDataAccess.PHONE_TYPE_CD,RefCodeNames.PHONE_TYPE_CD.POFAX);
                            PhoneDataVector pvd = PhoneDataAccess.select(conn,aSubCrit);
                            if(pvd.size() == 1){
                                reqData.setFaxBackConfirmNumber((PhoneData) pvd.get(0));
                            }if(pvd.size() > 1){
                                throw new RemoteException("Multiple fax back confirm numbers for account id "+order.getAccountId());
                            }
                        }

                        if (Utility.isSet(erpPoNum)) {

                            //
                            // find the purchase order for this
                            // po number.  provide the order id
                            // to pick out the unique entry.
                            //
                            // the self serve store po numbers
                            // would collide without the order id.
                            //
                            //
                            dbc = new DBCriteria();
                            dbc.addEqualTo(PurchaseOrderDataAccess.ERP_PO_NUM,
                                           erpPoNum);
                            dbc.addEqualTo(PurchaseOrderDataAccess.ORDER_ID,
                                           thisOrderId);


                            PurchaseOrderDataVector poVec =
                                    PurchaseOrderDataAccess.select(conn, dbc);

                            if (poVec.size() != 1) {
                                throw new RemoteException("found " +
                                                          poVec.size() +
                                                          " clw_purchase_order_records expected 1 for erp po num: " + erpPoNum);
                            }

                            PurchaseOrderData po = (PurchaseOrderData)poVec.get(
                                                           0);
                            reqData.setPurchaseOrderD(po);
                        } else {
                            //this is only an error if outbound tansaction is not TORDER_PROCESSING_OUT
                            //which would indicate it has not been processed by erp yet.
                            if(limitItemsByDistributor){
                                throw new RemoteException("erp po number was unexpectedly null for order id "+reqData.getOrderD().getOrderId());
                            }
                        }

                        // get shipto address id prefix (usually customer account id)
                        int accountId = reqData.getOrderD().getAccountId();

                        DBCriteria acctPropDbc = new DBCriteria();
                        acctPropDbc.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,accountId);
                        PropertyDataVector acctPropDV =
                            PropertyDataAccess.select(conn,acctPropDbc);
                        reqData.setAccountProperties(acctPropDV);

                        if (reqData.getOrderPropertyDV() == null) {
                        	List propertyTypes = new ArrayList();
                        	propertyTypes.add(RefCodeNames.ORDER_PROPERTY_TYPE_CD.CUSTOMER_PO_NUM);
                        	propertyTypes.add(RefCodeNames.ORDER_PROPERTY_TYPE_CD.CUSTOMER_ORDER_DATE);
                        	propertyTypes.add(RefCodeNames.ORDER_PROPERTY_TYPE_CD.CHECKOUT_FIELD_CD);
                        	propertyTypes.add(RefCodeNames.ORDER_PROPERTY_TYPE_CD.REBILL_ORDER);
                        	DBCriteria crOrderProperty = new DBCriteria();
                            crOrderProperty.addEqualTo(OrderPropertyDataAccess.ORDER_ID, orderId);
                            crOrderProperty.addOneOf(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD, propertyTypes);
                            OrderPropertyDataVector orderPropDV =OrderPropertyDataAccess.select(conn, crOrderProperty);

                            OrderPropertyDataVector opdv = orderPropDV;
                            reqData.setOrderPropertyDV(opdv);
                        }
                        //dbc = new DBCriteria();
                        //dbc.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,
                        //          RefCodeNames.PROPERTY_TYPE_CD.EDI_SHIP_TO_PREFIX);
                        //dbc.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,accountId);
                        //PropertyDataVector prefixV = PropertyDataAccess.select(conn,dbc);
                        String prefix = "";
                        for(int ii=0; ii<acctPropDV.size(); ii++) {
                          PropertyData prefixProp = (PropertyData) acctPropDV.get(ii);
                          if(!RefCodeNames.PROPERTY_TYPE_CD.EDI_SHIP_TO_PREFIX.
                              equals(prefixProp.getPropertyTypeCd())) {
                              continue;
                          }
                          String val = prefixProp.getValue();
                          if(val!=null) {
                            if(prefix.length()==0) {
                              prefix=val;
                            } else {
                              if(!prefix.equals(val)){
                                throw new RemoteException
                                  ("Multiple properties EDI_SHIP_TO_PREFIX for account "+accountId);
                              }
                            }
                          }
                        }
                        if(prefix.length()==0) prefix += accountId;

                        reqData.setAccountIdentifier(prefix);
                        reqData.setSiteIdentifier(Integer.toString(reqData.getOrderD().getSiteId()));
                        reqData.setDistributorName(distributorName);
                        reqData.setDistributorCompanyCode(distCompCo);

                        reqData.setOrderItemDV(tempItemDV);
                        fillAdditionalInfo(reqData, conn);
                        reqData.setShipAddr(getOrderAddress(orderId,
                                                            RefCodeNames.ADDRESS_TYPE_CD.SHIPPING,
                                                            conn));
                        if(RefCodeNames.EDI_TYPE_CD.T850.equals(setType)){
                        	//!!!Note may get overwritten by cc info later
                            if(RefCodeNames.STORE_TYPE_CD.MLA.equals(reqData.getStoreType())){
                                reqData.setBillAddr(getStoreAddressAsOrderAddress(conn,storeId,cache));
                                log.debug("Billing address: "+reqData.getBillAddr());
                            }else{
                                reqData.setBillAddr(getOrderAddress(orderId,
                                                            RefCodeNames.ADDRESS_TYPE_CD.BILLING,
                                                            conn));
                            }
                        }

                        //for mla stores the CC is charged by the store owner.
                        //if(!RefCodeNames.STORE_TYPE_CD.MLA.equals(reqData.getStoreType())){
	                        DBCriteria ccCrit = new DBCriteria();
	                        ccCrit.addEqualTo(OrderCreditCardDataAccess.ORDER_ID, orderId);
	                        OrderCreditCardDataVector occdv = OrderCreditCardDataAccess.select(conn,ccCrit);
	                        if ( null == occdv || occdv.size() == 0) {
	                        	log.debug("Failed to get Credit Card number for order id " + orderId);
	                        }else{
	                	    	OrderCreditCardData occd = (OrderCreditCardData)occdv.get(0);
	                	    	reqData.setCreditCardNumber(occd.getEncryptedCreditCardNumber());
	                	    	reqData.setCreditCardExpDate(occd.getExpYear()+"-"+Utility.padLeft((occd.getExpMonth()+1), '0', 2));
	                            reqData.setOrderCreditCard(occd);
	                	    	//overwrite address data from above
	            	    		/*reqData.setBillAddr(OrderAddressData.createValue());
	            	    		reqData.getBillAddr().setShortDesc(occd.getName());
	                	    	reqData.getBillAddr().setAddress1(occd.getAddress1());
	                	    	reqData.getBillAddr().setAddress2(occd.getAddress2());
	                	    	reqData.getBillAddr().setAddress3(occd.getAddress3());
	                	    	reqData.getBillAddr().setAddress4(occd.getAddress4());
	                	    	reqData.getBillAddr().setCity(occd.getCity());
	                	    	reqData.getBillAddr().setCountryCd(occd.getCountryCd());
	                	    	reqData.getBillAddr().setPostalCode(occd.getPostalCode());
	                	    	reqData.getBillAddr().setStateProvinceCd(occd.getStateProvinceCd());*/
	                        }
                        //}


                        int fhid = Utility.pickOutFreightHandler(tempItemDV);

                        if(fhid > 0 ) {
                            // The group of items in this PO
                            // have been sent to a freight handler.
                            // Get the ship via data.
                            try {
                            FreightHandlerView fh =
                                BusEntityDAO.getFreightHandler(conn, fhid);
                            reqData.setShipVia(fh);
                            }
                            catch (Exception e) {
                            processException(e);
                            }
                        }

                        //Get any freight criteria
                        log.info("***Getting Freight and Handling Charges for the Order");
                        OrderFreightDataVector orderFrt;
                        if(dist == null){
                            orderFrt = new OrderFreightDataVector();
                        }else{
                            DBCriteria orderFrtCrit = new DBCriteria();
                            orderFrtCrit.addEqualTo(OrderFreightDataAccess.ORDER_ID,orderId);
                            orderFrtCrit.addEqualTo(OrderFreightDataAccess.BUS_ENTITY_ID,dist.getBusEntityId());
                            orderFrt = OrderFreightDataAccess.select(conn,orderFrtCrit);
                        }
                        log.info("***ABC: orderFrt = " + orderFrt);
                        Iterator it = orderFrt.iterator();
                        while(it.hasNext()){
                            OrderFreightData frt = (OrderFreightData) it.next();
                            reqData.setFreightInfo(frt); //new line of code
                            if(frt.getFreightHandlerId() > 0){
                                try{
                                    if(reqData.getShipVia() != null && reqData.getShipVia().getBusEntityData() != null){
                                        int fh1 = reqData.getShipVia().getBusEntityData().getBusEntityId();
                                        int fh2 = frt.getFreightHandlerId();
                                        //its okay if they are the same id.
                                        if(fh1 != fh2){
                                            log.debug("fhid: "+reqData.getShipVia().getBusEntityData().getBusEntityId());
                                            log.debug("multi="+frt.getFreightHandlerId());
                                            //throw new RemoteException("Multiple freight handlers found for this order (possibly routing and user selcted/implied) only 1 expected: "+frt.getOrderId());
                                        }
                                    }
                                    FreightHandlerView fh =BusEntityDAO.getFreightHandler(conn, frt.getFreightHandlerId());
                                    reqData.setShipVia(fh);
                                    //reqData.setFreightInfo(frt); //old line of code
                                }catch(Exception e){
                                    throw processException(e);
                                }
                            }
                        }

                        // Add the meta data for the order.
                        reqData.setOrderMetaDV
                            (OrderDAO.getOrderMetaDV(conn, orderId));

                        if(((OrderItemData)tempItemDV.get(0)).getErpPoNum() == null){
                            sorted850Order.put(Integer.toString(((OrderItemData)tempItemDV.get(0)).getOrderId()), reqData);
                        }else{
                            sorted850Order.put(((OrderItemData)tempItemDV.get(0)).getErpPoNum(), reqData);
                        }
                    }
                }

                OutboundEDIRequestDataVector outboundEDIReqDV = new OutboundEDIRequestDataVector();
                outboundEDIReqDV.addAll(sorted850Order.values());
                log.debug("X5: orderDV: " + orderDV.toString());
                return outboundEDIReqDV;
    }

    private OrderAddressData getStoreAddressAsOrderAddress(Connection conn, int storeId, HashMap cache)
    throws RemoteException, SQLException{
        String key="getStoreAddressAsOrderAddress::"+storeId;
        if(!cache.containsKey(key)){
            try{
                AddressData addr = BusEntityDAO.getPrimaryStoreAddressData(conn,storeId);
                PropertyUtil pr = new PropertyUtil(conn);
                String storeName = pr.fetchValueIgnoreMissing(0,storeId,RefCodeNames.PROPERTY_TYPE_CD.STORE_BUSINESS_NAME);
                if(!Utility.isSet(storeName)){
                    storeName = BusEntityDataAccess.select(conn,storeId).getShortDesc();
                }
                OrderAddressData oa = Utility.toOrderAddress(addr);
                oa.setShortDesc(storeName);
                 cache.put(key,oa);
            }catch(DataNotFoundException e){
                throw new RemoteException(e.getMessage());
            }
        }
        return (OrderAddressData) cache.get(key);
    }


    /**
     *When a transaction is made between a client and server the orders are set to
     *a pending state (sending to lawson).  These orders should then be processed
     *in whatever manner is appropriate (EDI file out as in JWP, etc.) and when
     *the client has succesfully processed them it will notify the server which should
     *then update them to the proper state.
     *@param orderIdVector all the order ids that should be acknowledged as being succesfully processed
     *@throws RemoteException if there were any problems (most likely due to database connectivity)
     */
    public void acknowledgeOrderTransaction(IdVector orderIdVector)
    throws RemoteException{
        Connection conn = null;
        try{
            conn = getConnection();
            for (int i=0,len=orderIdVector.size();i<len;i++){
                try{
                    OrderData od = OrderDataAccess.select(conn,((Integer)orderIdVector.get(i)).intValue());
                    od.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.PROCESS_ERP_PO);
                    OrderDataAccess.update(conn, od);
                }catch (DataNotFoundException e){
                    log.error("Could not find order id: " + orderIdVector.get(i) + " to acknowledge");
                }catch (Exception e){
                    e.printStackTrace();
                    log.error(e.getMessage());
                }
            }
        }catch (Exception e){
            throw new RemoteException(e.getMessage());
        }finally{
            closeConnection(conn);
        }
    }

    private boolean orderIsReadyToBeSent(OrderData od, Connection conn) throws Exception {
	    if(od.getStoreId() != 1){return true;}
    	// is this a credit card transaction
        DBCriteria ccCrit = new DBCriteria();
        ccCrit.addEqualTo(OrderCreditCardDataAccess.ORDER_ID, od.getOrderId());
        OrderCreditCardDataVector occdv = OrderCreditCardDataAccess.select(conn,ccCrit);
        if ( null == occdv || occdv.size() == 0) {
        	log.debug("NOT A CC order id " + od.getOrderId());
        	return true;
        }
    	// is there a valid authorization
        log.debug("IS A CC order id " + od.getOrderId());
        for ( int i = 0 ; i < occdv.size(); i++ ) {
        	OrderCreditCardData occd = (OrderCreditCardData)occdv.get(i);
        	if ( null == occd.getAuthStatusCd()) continue;
        	if ( RefCodeNames.CREDIT_CARD_AUTH_STATUS.AUTH_SUCCESS.equals(occd.getAuthStatusCd())) {
                log.debug("IS A CC order id " + od.getOrderId() + " IS AUTHORIZED");
        		return true;
        	}
        }
        log.debug("IS A CC order id " + od.getOrderId() + " NOT AUTHORIZED YET");
        return false;
    }

    private OrderDataVector pickOutOrdersReadyToBeSent(OrderDataVector orderDV, Connection conn)
    throws Exception {
    	OrderDataVector ordersThatAreReady = new OrderDataVector();
    	for ( int i = 0; i < orderDV.size(); i++) {
    		OrderData od = (OrderData)orderDV.get(i);
    		if ( orderIsReadyToBeSent(od, conn)) {
    			ordersThatAreReady.add(od);
    		}
    	}
    	return ordersThatAreReady;
    }

    // Get all the order objects that ready to create outbound transaction of
    // EDI type setType for partner with erp num = erpNum (could be distributor
    // erp number if it is a distributor or account number if it is a customer
    // The return list could contain list of order, order item, customer invoice,
    // customer invoice item and list of incomming profile id that involved the
    // order
    public OutboundEDIRequestDataVector getEDIOrdersByErpNumAndSetType(String erpNum,
                                                                       String setType,
                                                                       int busEntityId)
        throws RemoteException
{
            log.debug("ItegrationServiceBean IIIIIIIIIIIIIIIIIIIIIIIIIII getEDIOrdersByErpNumAndSetType("+erpNum+","+setType+")");
            log.info("***SVC: ItegrationServiceBean getEDIOrdersByErpNumAndSetType("+erpNum+","+setType+")");
        Connection conn = null;
        OutboundEDIRequestDataVector outboundEDIReqDV = new OutboundEDIRequestDataVector();
	String progressString = "";
	    try {
            boolean strictValidation = true;
            conn = getConnection();
            BusEntityData busEnt = null;
            BusEntityData storeEnt = null;
            String storeType=null;
            if(busEntityId > 0){
            	 busEnt = BusEntityDataAccess.select(conn,busEntityId);
                if(busEnt != null){
                    erpNum = busEnt.getErpNum();
                }
                //find the store
                DBCriteria stoCrit = new DBCriteria();
                stoCrit.addJoinTableEqualTo(BusEntityDataAccess.CLW_BUS_ENTITY,BusEntityDataAccess.BUS_ENTITY_TYPE_CD,RefCodeNames.BUS_ENTITY_TYPE_CD.STORE);
                stoCrit.addJoinCondition(BusEntityDataAccess.CLW_BUS_ENTITY,BusEntityDataAccess.BUS_ENTITY_ID,
                        BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC, BusEntityAssocDataAccess.BUS_ENTITY2_ID);
                stoCrit.addJoinTableEqualTo(BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC, BusEntityAssocDataAccess.BUS_ENTITY1_ID,busEntityId);
                IdVector stoIdv = JoinDataAccess.selectIdOnly(conn, BusEntityDataAccess.CLW_BUS_ENTITY, BusEntityDataAccess.BUS_ENTITY_ID, stoCrit, 1);
                int stoId=0;
                if(stoIdv.isEmpty()){
                	  //check if the passed in id happens to be a store id
                    BusEntityData bed = BusEntityDataAccess.select(conn,busEntityId);
                    if(RefCodeNames.BUS_ENTITY_TYPE_CD.STORE.equals(bed.getBusEntityTypeCd())){
                        stoId = busEntityId;
                    }
                }else{
                	  stoId = ((Integer) stoIdv.get(0)).intValue();
                }
                if(stoId > 0){
                    PropertyUtil pru = new PropertyUtil(conn);
                    storeType = pru.fetchValueIgnoreMissing(0, stoId, RefCodeNames.PROPERTY_TYPE_CD.STORE_TYPE);
                    storeEnt = BusEntityDataAccess.select(conn,stoId);
                }

            }
            if(storeType==null){
                //Thread.currentThread().dumpStack();
                storeType = RefCodeNames.STORE_TYPE_CD.MLA;
            }

            //determine the bus entity type by the setType asked for
            String entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT;
            if (setType.equals(RefCodeNames.EDI_TYPE_CD.T850)) {
                entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR;
            }

            if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_SEND_TO_EXT_CUST_SYS)) {
                entityType = RefCodeNames.BUS_ENTITY_TYPE_CD.STORE;
            }

            // get trading partner id
            int partnerId;
            if(setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT)||
            setType.equals(RefCodeNames.EDI_TYPE_CD.TMANIFEST_OUT)) {
                entityType = null;
                partnerId = getPartnerId(erpNum, busEntityId, entityType, conn, true,null,true,setType);
            }else{
                partnerId = getPartnerId(erpNum, busEntityId, entityType, conn, false,null,true,setType);
            }
             ArrayList setTypes;
            TradingPartnerInfo tpInfo = null;
            if(partnerId != 0){
                tpInfo = getTradingPartnerInfo(partnerId,null);
                // check to see if current set type is supported by trading partner
                setTypes = getEDITypeSupportedByPartner(partnerId, conn);
                if (tpInfo.getTradingPartnerData().getTradingTypeCd().equals(RefCodeNames.TRADING_TYPE_CD.EDI)) {
                    if (!setTypes.contains(setType)) {
                        log.error("Set type " + setType + " is not supported for Trading Partner Id: " +partnerId);
                        return outboundEDIReqDV;
                    }
                }
            }else{
                setTypes = new ArrayList();
                setTypes.add(RefCodeNames.EDI_TYPE_CD.T810);
                setTypes.add(RefCodeNames.EDI_TYPE_CD.T850);
            }

            log.debug(" --- ISB: processing set: " + setType);

            DBCriteria dbc = new DBCriteria();

            if (setType.equals(RefCodeNames.EDI_TYPE_CD.T850)) {

                // get list of order ids that status is not all PENDING_FULFILLMENT and CANCELED
                List status = new ArrayList();
                status.add(RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT);
                status.add(RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED);
                dbc.addEqualTo(OrderItemDataAccess.DIST_ERP_NUM, erpNum);
                dbc.addNotOneOf(OrderItemDataAccess.ORDER_ITEM_STATUS_CD,
                                status);

                String sqlStr = OrderItemDataAccess.getSqlSelectIdOnly(
                                        OrderItemDataAccess.ORDER_ID, dbc);

                // get a list of order ids that order is ready for sending to Distributor
                dbc = new DBCriteria();
                dbc.addEqualTo(OrderItemDataAccess.DIST_ERP_NUM, erpNum);
                dbc.addEqualTo(OrderItemDataAccess.ORDER_ITEM_STATUS_CD,
                               RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT);
                dbc.addNotOneOf(OrderItemDataAccess.ORDER_ID, sqlStr);
                sqlStr = OrderItemDataAccess.getSqlSelectIdOnly(
                                 OrderItemDataAccess.ORDER_ID, dbc);

                // get list of order that has order status = ERP_RELEASED
                // and distributor's erp number = :erpNum
                // and all the line item has status = PENDING_FULFILLMENT or CANCELED
                dbc = new DBCriteria();
                dbc.addEqualTo(OrderDataAccess.ORDER_STATUS_CD,
                               RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED);

                dbc.addOneOf(OrderDataAccess.ORDER_ID, sqlStr);

                //dbc.addOrderBy(OrderDataAccess.INCOMING_TRADING_PROFILE_ID);
                log.debug(OrderDataAccess.getSqlSelectIdOnly("*",dbc));
                OrderDataVector orderDV = OrderDataAccess.select(conn, dbc);

                log.debug("X4 getSqlClause: " +OrderDataAccess.getSqlSelectIdOnly(OrderDataAccess.ORDER_ID, dbc));

                orderDV = pickOutOrdersReadyToBeSent(orderDV,conn);
                //SVC: stmt below can produce Java exception
                log.info("***SVC: calling populateOutboundTransactionDataFromOrderDataVector");
                log.info("***SVC: orderDV = " + orderDV);
                log.info("***SVC: erpNum = " + erpNum);
                log.info("***SVC: setType = " + setType);
                outboundEDIReqDV.addAll(populateOutboundTransactionDataFromOrderDataVector(orderDV,erpNum,conn,setType,false));

                log.debug("SIZE:"+outboundEDIReqDV.size());
                Iterator it = outboundEDIReqDV.iterator();
                StringBuffer purchaseOrderIds = new StringBuffer();
                while(it.hasNext()){
                	OutboundEDIRequestData edi = (OutboundEDIRequestData)it.next();
                	purchaseOrderIds.append(edi.getPurchaseOrderD().getPurchaseOrderId());
                	if(it.hasNext()){
                		purchaseOrderIds.append(",");
                	}
                }

                if(!outboundEDIReqDV.isEmpty()){
	                String upd1 = "Update "+OrderItemDataAccess.CLW_ORDER_ITEM+" set "+OrderItemDataAccess.ORDER_ITEM_STATUS_CD+" = '"+RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT_PROCESSING+"'" +
	                		" where "+OrderItemDataAccess.PURCHASE_ORDER_ID+" IN ("+purchaseOrderIds+") and "+OrderItemDataAccess.ORDER_ITEM_STATUS_CD+" = '"+RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT+"'";
	                String upd2 = "Update "+PurchaseOrderDataAccess.CLW_PURCHASE_ORDER+" set "+PurchaseOrderDataAccess.PURCHASE_ORDER_STATUS_CD+" = '"+RefCodeNames.PURCHASE_ORDER_STATUS_CD.PENDING_FULFILLMENT_PROCESSING+"'" +
	        				" where "+PurchaseOrderDataAccess.PURCHASE_ORDER_ID+" IN ("+purchaseOrderIds+")";

	                Statement stmt = conn.createStatement();
	                log.debug("Executing: "+upd1);
	                stmt.executeUpdate(upd1);
	                log.debug("Executing: "+upd2);
	                stmt.executeUpdate(upd2);
	                stmt.close();
                }

            } else if (setType.equals(RefCodeNames.EDI_TYPE_CD.T855)) {

                // get list of order ids that status is ERP_RELEASED,CANCELLED,
                List status = new ArrayList();
                status.add(RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED);
                status.add(RefCodeNames.ORDER_STATUS_CD.CANCELLED);
                status.add(RefCodeNames.ORDER_STATUS_CD.REJECTED);

                String sql = "SELECT IA.ORDER_ID, IA.ORDER_ITEM_ID, IA.ORDER_ITEM_ACTION_ID " +
                		"FROM CLW_ORDER O, CLW_ORDER_ITEM I, CLW_ORDER_ITEM_ACTION IA " +
                		"WHERE O.ORDER_ID = I.ORDER_ID " +
                		"AND O.ORDER_ID = IA.ORDER_ID " +
                		"AND I.ORDER_ITEM_ID = IA.ORDER_ITEM_ID " +
                		//"AND O.ACCOUNT_ERP_NUM = '" + erpNum + "' " +
                		"AND O.ACCOUNT_ERP_NUM = ? " +
                		"AND O.ORDER_STATUS_CD IN (" + Utility.toCommaSting(status, '\'') + ") " +
                		"AND IA.ACTION_CD like 'ACK %' " +
                		"AND IA.STATUS IS NULL " +
                		"ORDER BY O.ORDER_ID, I.CUST_LINE_NUM";

                PreparedStatement stmt = conn.prepareStatement(sql);
                stmt.setString(1, erpNum);
                ResultSet rs = stmt.executeQuery();
                
                int preOrderId = 0;
                OutboundEDIRequestData reqData = null;
                OrderData orderD = null;
                while (rs.next()){
                	int orderId = rs.getInt("ORDER_ID");
                	int orderItemId = rs.getInt("ORDER_ITEM_ID");
                	int orderItemActionId = rs.getInt("ORDER_ITEM_ACTION_ID");
                	if (orderId != preOrderId){
                		orderD = OrderDataAccess.select(conn, orderId);
                		reqData = OutboundEDIRequestData.createValue();
                        outboundEDIReqDV.add(reqData);
                        reqData.setOrderD(orderD);
                        reqData.setOrderItemDV(new OrderItemDataVector());
                        reqData.setOrderItemActionDV(new OrderItemActionDataVector());
                        preOrderId = orderId;
                        reqData.setStoreTypeCd(storeType);             
                	}
                	OrderItemData orderItemD = OrderItemDataAccess.select(conn, orderItemId);
                	reqData.getOrderItemDV().add(orderItemD);
                	OrderItemActionData orderItemActionD = OrderItemActionDataAccess.select(conn, orderItemActionId);
                	reqData.getOrderItemActionDV().add(orderItemActionD);
                }

                for (int i = 0; i < outboundEDIReqDV.size(); i++){
                	reqData = (OutboundEDIRequestData) outboundEDIReqDV.get(i);
                	int orderId = reqData.getOrderD().getOrderId();
                    fillAdditionalInfo(reqData, conn);
                    String originalDateOrdered = getOriginalDateOrdered(orderId, conn);

                    if (!Utility.isSet(originalDateOrdered)) {
                        SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyyMMdd");
                        originalDateOrdered = dateFormatter.format(reqData.getOrderD().getOriginalOrderDate());
                    }
                    log.debug("X1.1 originalDateOrdered: " +originalDateOrdered );
                    reqData.setOriginalDateOrdered(originalDateOrdered);

                    reqData.setCustomerBillingUnit(getCustomerBillingUnit(orderId, conn));

                    OrderAddressData custShipAddr = getOrderAddress(
                                                            orderId,
                                                            RefCodeNames.ADDRESS_TYPE_CD.CUSTOMER_SHIPPING,
                                                            conn);

                    if (custShipAddr == null) {
                        custShipAddr = getOrderAddress(orderId,
                                                       RefCodeNames.ADDRESS_TYPE_CD.SHIPPING,
                                                       conn);
                    }

                    reqData.setCustShipAddr(custShipAddr);
                }
            } else if (setType.equals(RefCodeNames.EDI_TYPE_CD.T856) ||
		       setType.equals(RefCodeNames.EDI_TYPE_CD.T810)) {

                if(busEntityId == 0){
                    log.error("ERROR busEntityId was 0.  This functionality is deprecated, do not use ERPNum anymore, use busEntityId, assuming account type for lookup");
                    DBCriteria crit = new DBCriteria();
                    crit.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
                    crit.addEqualTo(BusEntityDataAccess.ERP_NUM,erpNum);
                    BusEntityDataVector bedv = BusEntityDataAccess.select(conn,crit);
                    if(bedv.size() == 1){
                        BusEntityData bed = (BusEntityData) bedv.get(0);
                        busEntityId = bed.getBusEntityId();
                    }else if(bedv.size() == 0){
                        throw new RemoteException("No accounts found for ERP Number: "+erpNum);
                    }else{
                        throw new RemoteException(bedv.size()+" accounts found for ERP Number: "+erpNum);
                    }

                }
                List invoiceDV;
                int storeId = 0;
                if(storeEnt != null){
                	 storeId = storeEnt.getBusEntityId();
                }
                invoiceDV = getOutboundInvoicesAndShippingNoticesToSend(tpInfo, setTypes, conn,busEntityId, setType,storeType, false,storeId);
                if(!RefCodeNames.STORE_TYPE_CD.MLA.equals(storeType)){
                    strictValidation = false;
                }
                log.info("X11 got " + invoiceDV.size() + " clw_invoice_cust records ");
                TreeMap sortedOrder = new TreeMap();
                HashMap paramMap = new HashMap();
                for (int i = 0; i < invoiceDV.size(); i++) {
                	 int invoiceId = ((Integer)invoiceDV.get(i)).intValue();  //may be distributor or customer invoice id!!
                    OutboundEDIRequestData reqData;
                    reqData = populateOutBoundInvoiceAndShippingNotice(invoiceId, storeType, conn, setType, false, paramMap);
                    sortedOrder.put(reqData.getInvoiceData().getInvoiceNum(), reqData);
                    reqData.setStoreTypeCd(storeType);
                }
                outboundEDIReqDV.addAll(sortedOrder.values());
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT)) {
                OrderDataVector orders = getAPIAccess().getOrderAPI().getApprovedOrders();
                //orders must be in order by account for JD store.  This also makes this list
                //easier to process.
                Collections.sort(orders,ORDER_ACCOUNT_COMPARE);
                log.debug(">>>>>X11a orders.size="+orders.size());
                outboundEDIReqDV.addAll(populateOutboundTransactionDataFromOrderDataVector(orders,null,conn,setType,false));
                log.debug("X11a outboundEDIReqDV.size="+outboundEDIReqDV.size());
                //update the orders to be in a state of being processed (sending to erp)
                //this is in case something goes wrong during the process we can find it quickly
                for(int i=0,len=orders.size();i<len;i++){
                    OrderData od = (OrderData) orders.get(i);
                    od.setOrderStatusCd(RefCodeNames.ORDER_STATUS_CD.SENDING_TO_ERP);
                    OrderDataAccess.update(conn,od);
                }
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TPUNCH_OUT_ORDER_OUT)){
                log.debug("Getting Outbound Punch Out Orders");
                DBCriteria crit = new DBCriteria();
                crit.addEqualTo(OrderDataAccess.ORDER_STATUS_CD,RefCodeNames.ORDER_STATUS_CD.READY_TO_SEND_TO_CUST_SYS);
                crit.addEqualTo(OrderDataAccess.ACCOUNT_ERP_NUM,erpNum);
                log.debug("SQL:>>"+OrderDataAccess.getSqlSelectIdOnly("*", crit));
                OrderDataVector orderDV = OrderDataAccess.select(conn,crit);
                outboundEDIReqDV.addAll(populateOutboundTransactionDataFromOrderDataVector(orderDV,erpNum,conn,setType,false));
                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TMANIFEST_OUT)) {
                DBCriteria crit = new DBCriteria();
                crit.addEqualTo(ManifestItemDataAccess.MANIFEST_ITEM_STATUS_CD,RefCodeNames.MANIFEST_ITEM_STATUS_CD.READY_TO_SEND);
                ManifestItemDataVector mans = ManifestItemDataAccess.select(conn,crit);
                HashMap postalCdMap = new HashMap();
                Iterator it = mans.iterator();
                while(it.hasNext()){
                    OutboundEDIRequestData o = OutboundEDIRequestData.createValue();
                    ManifestItemData man = (ManifestItemData) it.next();
                    ManifestItemView manView = ManifestItemView.createValue();
                    manView.setManifestItem(man);

                    //get the zipcode
                    Integer key = new Integer(man.getPurchaseOrderId());
                    if(postalCdMap.containsKey(key)){
                        log.debug("Setting from cached values");
                        manView.setShipToPostalCode((String) postalCdMap.get(key));
                    }else{
                        StringBuffer sqlBuf = new StringBuffer();
                        sqlBuf.append("SELECT ");
                        sqlBuf.append(OrderAddressDataAccess.POSTAL_CODE);
                        sqlBuf.append(" FROM ");
                        sqlBuf.append(OrderAddressDataAccess.CLW_ORDER_ADDRESS);
                        sqlBuf.append(" oa, ");
                        sqlBuf.append(PurchaseOrderDataAccess.CLW_PURCHASE_ORDER);
                        sqlBuf.append(" po WHERE po.");
                        sqlBuf.append(PurchaseOrderDataAccess.PURCHASE_ORDER_ID);
                        sqlBuf.append("=");
                        sqlBuf.append(man.getPurchaseOrderId());
                        sqlBuf.append(" AND po.");
                        sqlBuf.append(PurchaseOrderDataAccess.ORDER_ID);
                        sqlBuf.append("=oa.");
                        sqlBuf.append(OrderAddressDataAccess.ORDER_ID);
                        sqlBuf.append(" AND oa.");
                        sqlBuf.append(OrderAddressDataAccess.ADDRESS_TYPE_CD);
                        sqlBuf.append("=");
                        sqlBuf.append("'"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"'");

                        log.debug(sqlBuf);
                        ResultSet rs = conn.createStatement().executeQuery(sqlBuf.toString());
                        HashSet zips = new HashSet();
                        while(rs.next()){
                            zips.add(rs.getString(OrderAddressDataAccess.POSTAL_CODE));
                        }
                        if(zips.size() != 1){
                            throw new RemoteException("Found " + zips.size() +
                                " for shipping addresses, Expecting 1.  Purchase Order Id: " + man.getPurchaseOrderId() +
                                ".  ManifestItemId: " + man.getManifestItemId());
                        }
                        String zip = (String) zips.iterator().next();
                        postalCdMap.put(key,zip);
                        manView.setShipToPostalCode(zip);
                    }
                    //end get zipcode
                    o.setManifestItemView(manView);
                    o.setIncomingTradingProfileId(partnerId);
                    outboundEDIReqDV.add(o);
                }
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_REPORT_XML_OUT)) {
            	int storeId = 0;
            	String note = "Sent to FBG";

                if(storeEnt != null){
                    storeId = storeEnt.getBusEntityId();
                }
            	String sql = "select distinct o.order_id " +
            			"from clw_order o, clw_order_property p " +
            			//"where store_id = " + storeId + " " +
            			"where store_id = ? "  +
            			//"and o.order_Status_cd = '" + RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED + "' " +
            			"and o.order_Status_cd = ? " +
            			"and o.order_id = p.order_id(+) " +
            			//"and p.clw_value(+) = '" + note + "' " +
            			"and p.clw_value(+) = ? " +
            			"and p.clw_value is null";

            	PreparedStatement stmt = conn.prepareStatement(sql);
                log.debug("Executing: "+sql);
                stmt.setInt(1, storeId);
                stmt.setString(2, RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED);
                stmt.setString(3, note);
                ResultSet rs = stmt.executeQuery();
                IdVector orderIds = new IdVector();
                while (rs.next()){
                	int oId = rs.getInt(1);
                	orderIds.add(new Integer(oId));
                }

                if (orderIds.size() > 0){
                    OrderDataVector orderDV = OrderDataAccess.select(conn, orderIds);
                    log.debug("SIZE:"+outboundEDIReqDV.size());

                    for (int i = 0; i < orderDV.size(); i++){
                    	OrderData order = (OrderData)orderDV.get(i);
                    	OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
                        reqData.setOrderD(order);
                        outboundEDIReqDV.add(reqData);
                    }
                }
                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_SEND_TO_EXT_CUST_SYS)) {
            	int storeId = 0;
            	String note = "Sent to Customer System";

                if(storeEnt != null){
                    storeId = storeEnt.getBusEntityId();
                }
                if(storeId == 0){
                	//get fromerp number....
                	 DBCriteria crit = new DBCriteria();
                	 crit.addContains(BusEntityDataAccess.ERP_NUM, erpNum);
                	 BusEntityDataVector storeDataV = BusEntityDataAccess.select(conn, crit);
                	 for(int s=0; s<storeDataV.size(); s++){
                		 BusEntityData sD = (BusEntityData)storeDataV.get(s);
                		 storeId = sD.getBusEntityId();
                	 }

                }
                if(storeId <= 0){
                	//throw someerror
                	log.debug("IntergrationServicesBean TORDER_SEND_TO_EXT_CUST_SYS:: No Storeid found ");
                }

            	String sql = "select distinct o.order_id " +
            			"from clw_order o, clw_order_property p " +
            			"where store_id = " + storeId + " " +
            			"and o.order_Status_cd = '" + RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED + "' " +
            			"and o.order_source_cd not in ('EDI') " + // This is to ensure that we do not resend the orders sent by customer system
            			"and o.order_id = p.order_id(+) " +
            			"and p.short_desc (+) = '" + RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_SENT_TO_EXTERNAL_SYS + "' "+
            			"and p.clw_value is null";

            	Statement stmt = conn.createStatement();
                log.debug("Executing: "+sql);
                ResultSet rs = stmt.executeQuery(sql);
                IdVector orderIds = new IdVector();
                while (rs.next()){
                	int oId = rs.getInt(1);
                	orderIds.add(new Integer(oId));
                }


                if (orderIds.size() > 0){
                    OrderDataVector orderDV = OrderDataAccess.select(conn, orderIds);
                    outboundEDIReqDV = populateOutboundTransactionDataFromOrderDataVector(orderDV, erpNum, conn, setType,false);

                }
                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.T856_SENT)) {
            	int storeId = 0;

                if(storeEnt != null){
                    storeId = storeEnt.getBusEntityId();
                }
            	String sql = "select distinct o.order_id, oia.order_item_action_id " +
            			"from clw_order o, clw_order_item_action oia " +
            			"where o.store_id = " + storeId + " " +
            			"and o.order_Status_cd = '" + RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED + "' " +
            			"and o.order_id = oia.order_id " +
            			"and oia.action_cd = '" +RefCodeNames.ORDER_ITEM_DETAIL_ACTION_CD.DIST_SHIPPED + "' " +
            			//"and oia.status(+)= '" + RefCodeNames.EDI_TYPE_CD.T856_SENT + "' " +
            			"and oia.status is null";

            	Statement stmt = conn.createStatement();
                log.debug("Executing: "+sql);
                ResultSet rs = stmt.executeQuery(sql);
                IdVector orderIds = new IdVector();
                IdVector orderItemActionIds = new IdVector();
                while (rs.next()){
                	int oId = rs.getInt(1);
                	orderIds.add(new Integer(oId));
                	int oiaId = rs.getInt(2);
                	orderItemActionIds.add(new Integer(oiaId));
                }

                if (orderIds.size() > 0){
                    OrderDataVector orderDV = OrderDataAccess.select(conn, orderIds);
                    OrderItemActionDataVector orderItemActionDV = OrderItemActionDataAccess.select(conn, orderItemActionIds);
                    // change this to populate the EDIRequestData with order_item_action_data
                    //outboundEDIReqDV = populateOutboundTransactionDataFromOrderDataVector(orderDV, erpNum, conn, setType,false);
                    log.debug("SIZE:"+orderDV.size());

                    for (int i = 0; i < orderDV.size(); i++){
                    	OrderData order = (OrderData)orderDV.get(i);
                    	int thisOrderId = order.getOrderId();
                    	log.debug("OOOOOOOOOOOOOOOOO Order id "+thisOrderId);

                    	// get site data
                        int siteId = order.getSiteId();
                        DBCriteria spropCrit = new DBCriteria();
                        spropCrit.addEqualTo(
                            PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                        spropCrit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,siteId);
                        PropertyDataVector siteProperties = PropertyDataAccess.select(conn,spropCrit);

                    	// get po data
                    	DBCriteria poCrit = new DBCriteria();

                        //poCrit.addEqualTo(PurchaseOrderDataAccess.ERP_PO_NUM, erpNum);
                        poCrit.addEqualTo(PurchaseOrderDataAccess.ORDER_ID,thisOrderId);

                        PurchaseOrderDataVector poVec =
                                PurchaseOrderDataAccess.select(conn, poCrit);

                        /*if (poVec.size() != 1) {
                            throw new RemoteException("found " +
                                                      poVec.size() +
                                                      " clw_purchase_order_records expected 1 for erp po num: " + erpNum);
                        }*/
                        log.debug("************ po "+poVec.size());

                        // Create outboundReq for each PO and each item with action dist shipped
                        for(int p=0; p<poVec.size(); p++){

                        PurchaseOrderData po = (PurchaseOrderData)poVec.get(p);
                        log.debug("********* "+po.getErpPoNum()+","+po.getOrderId());

                    	OrderItemActionDataVector oiaDV = new OrderItemActionDataVector();
                    	OrderItemDataVector oiDV = new OrderItemDataVector();
                    	IdVector items = new IdVector();
                    	String vendorNum = "";

                    	for(int j=0; j< orderItemActionDV.size(); j++){

                    		OrderItemActionData orderItemAction = (OrderItemActionData)orderItemActionDV.get(j);
                    		int thisOiaId = orderItemAction.getOrderItemActionId();


                    		// get orderItemActionDV
                    		DBCriteria crit = new DBCriteria();
                    		crit.addEqualTo(OrderItemActionDataAccess.ORDER_ID, thisOrderId);
                    		crit.addEqualTo(OrderItemActionDataAccess.ORDER_ITEM_ACTION_ID, thisOiaId);
                    		OrderItemActionDataVector vec1 =  OrderItemActionDataAccess.select(conn, crit);

                    		// populate orderItemDV with only items with matching orderItemAction
                    		crit = new DBCriteria();
                    		int thisItem = orderItemAction.getOrderItemId();
                    		crit.addEqualTo(OrderItemDataAccess.ORDER_ITEM_ID, thisItem);
                    		crit.addEqualTo(OrderItemDataAccess.ORDER_ID, thisOrderId);
                    		//items.add(new Integer(item));
                    		OrderItemDataVector vec2 = OrderItemDataAccess.select(conn, crit);

                    		if(vec1.size() != 0 && !vec1.isEmpty()){
                    			log.debug("OOOOOOOOOOOOOOOOO thisOiaId "+thisOiaId);
                    			oiaDV.add((OrderItemActionData)vec1.get(0));
                    		}
                    		if(vec2.size() != 0 && !vec2.isEmpty()){
                    			log.debug("OOOOOOOOOOOOOOOOO thisitem "+thisItem);
                    			oiDV.add((OrderItemData)vec2.get(0));

                    			//get the customer ref code (vendor num)
                        		String distErpNum = ((OrderItemData)vec2.get(0)).getDistErpNum();

                        		DBCriteria pCrit = new DBCriteria();
                        		pCrit.addOneOf(BusEntityDataAccess.ERP_NUM, "'"+distErpNum+"'");
                            	pCrit.addContains(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
                        		//String distId = BusEntityDataAccess.getSqlSelectIdOnly(BusEntityDataAccess.BUS_ENTITY_ID, pCrit);
                        		IdVector distributorIds = BusEntityDataAccess.selectIdOnly(conn, pCrit);
                        		String distId = distributorIds.get(0).toString();

                        		pCrit = new DBCriteria();
                        		pCrit.addOneOf(PropertyDataAccess.BUS_ENTITY_ID, distId);
                        		pCrit.addLikeIgnoreCase(PropertyDataAccess.SHORT_DESC,
                        				RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_REFERENCE_CODE);
                        		//vendorNum = PropertyDataAccess.getSqlSelectIdOnly(PropertyDataAccess.CLW_VALUE, pCrit);
                        		PropertyDataVector propsDV = PropertyDataAccess.select(conn, pCrit);

                        		for(int x=0; x<propsDV.size(); x++){
                        			PropertyData prop = (PropertyData)propsDV.get(x);
                        			vendorNum = prop.getValue();
                        		}
                    		}




                    	}
                    	OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
                        reqData.setOrderD(order);
                        reqData.setSiteProperties(siteProperties);
                        reqData.setDistributorCustomerReferenceCode(vendorNum);
                        reqData.setPurchaseOrderD(po);
                        reqData.setOrderItemDV(oiDV);
                        reqData.setOrderItemActionDV(oiaDV);
                        log.debug("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ "+oiaDV.size()+", "+oiDV.size());
                        outboundEDIReqDV.add(reqData);

                        }
                    }
                }

                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TINVOICE_REPORT_XML_OUT)) {
            	int storeId = 0;
            	String note = "Sent to FBG";

                if(storeEnt != null){
                    storeId = storeEnt.getBusEntityId();
                }
            	String sql = "select distinct i.invoice_dist_id from clw_order o, clw_invoice_dist i, clw_order_property p " +
				"where o.order_id = i.order_id " +
				//"and o.STORE_ID = " + storeId + " " +
				"and o.STORE_ID = ? " +
				//"and o.order_Status_cd = '" + RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED + "' " +
				//"and i.invoice_status_cd = '" + RefCodeNames.INVOICE_STATUS_CD.CLW_ERP_PROCESSED + "' " +
				"and i.invoice_status_cd = ? " +
				"and i.order_id = p.order_id(+) " +
    			//"and p.clw_value(+) = '" + note + "' " +
    			"and p.clw_value(+) = ? " +
    			"and p.invoice_dist_id(+) = i.invoice_dist_id " +
    			"and p.clw_value is null";

            	PreparedStatement stmt = conn.prepareStatement(sql);
                log.debug("Executing: "+sql);
                stmt.setInt(1, storeId);
                stmt.setString(2, RefCodeNames.INVOICE_STATUS_CD.CLW_ERP_PROCESSED);
                stmt.setString(3, note);
                ResultSet rs = stmt.executeQuery();
                IdVector invoiceIds = new IdVector();
                while (rs.next()){
                	int iId = rs.getInt(1);
                	invoiceIds.add(new Integer(iId));
                }

                if (invoiceIds.size() > 0){
                    InvoiceDistDataVector invoiceDV = InvoiceDistDataAccess.select(conn, invoiceIds);
                    log.debug("SIZE:"+outboundEDIReqDV.size());

                    for (int i = 0; i < invoiceDV.size(); i++){
                    	InvoiceDistData invoice = (InvoiceDistData)invoiceDV.get(i);
                    	OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
                        reqData.setInvoiceDistD(invoice);
                        outboundEDIReqDV.add(reqData);
                    }
                }
                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.T867)) {
                DBCriteria crit = new DBCriteria();
                DBCriteria orCrit=new DBCriteria();
                orCrit.addJoinTableEqualTo(InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL,
                    InvoiceCustDetailDataAccess.REBATE_STATUS_CD,
                    RefCodeNames.REBATE_STATUS_CD.PENDING);
                DBCriteria rebCon2 = new DBCriteria();
                rebCon2.addJoinTableIsNull(InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL,
                    InvoiceCustDetailDataAccess.REBATE_STATUS_CD);
                orCrit.addOrCriteria(rebCon2);

                crit.addIsolatedCriterita(orCrit);

                crit.addJoinCondition(InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL,
                    InvoiceCustDetailDataAccess.ORDER_ITEM_ID,
                    OrderItemDataAccess.CLW_ORDER_ITEM,
                    OrderItemDataAccess.ORDER_ITEM_ID);
                crit.addJoinCondition(InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL,
                    InvoiceCustDetailDataAccess.INVOICE_CUST_ID,
                    InvoiceCustDataAccess.CLW_INVOICE_CUST,
                    InvoiceCustDataAccess.INVOICE_CUST_ID);
                crit.addJoinCondition(ItemMappingDataAccess.CLW_ITEM_MAPPING,
                    ItemMappingDataAccess.ITEM_ID,
                    OrderItemDataAccess.CLW_ORDER_ITEM,
                    OrderItemDataAccess.ITEM_ID);
                crit.addJoinTableEqualTo(ItemMappingDataAccess.CLW_ITEM_MAPPING,
                    ItemMappingDataAccess.ITEM_MAPPING_CD,
                    RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER);
                crit.addJoinTableEqualTo(ItemMappingDataAccess.CLW_ITEM_MAPPING,
                    ItemMappingDataAccess.BUS_ENTITY_ID,
                    Integer.toString(busEntityId));
                crit.addJoinTableOrderBy(InvoiceCustDataAccess.CLW_INVOICE_CUST,InvoiceCustDataAccess.INVOICE_CUST_ID);
                crit.addJoinTableOrderBy(OrderItemDataAccess.CLW_ORDER_ITEM,OrderItemDataAccess.DIST_ERP_NUM);

                crit.addDataAccessForJoin(new InvoiceCustDataAccess());
                crit.addDataAccessForJoin(new InvoiceCustDetailDataAccess());
                crit.addDataAccessForJoin(new OrderItemDataAccess());
                int lastInvoiceCustId=-1;

                log.debug(crit.getWhereClause());
                List rows = JoinDataAccess.select(conn, crit);
                log.debug("****************************************><><><><><><><><><> Found: "+rows.size());

                Iterator it = rows.iterator();
                OutboundEDIRequestData o = null;
                HashMap accountPropMap = new HashMap();
                HashMap distMap = new HashMap();
                String lastDistName="-1";
                while(it.hasNext()){
                    List l = (List) it.next();
                    InvoiceCustData icd = (InvoiceCustData) l.get(0);
                    InvoiceCustDetailData icdd = (InvoiceCustDetailData) l.get(1);
                    OrderItemData oid = (OrderItemData) l.get(2);
                    String distName = "";
                    int distId = 0;
                    if(Utility.isSet(oid.getDistErpNum())){
                        BusEntityData dist = Utility.getDistBusEntityByErpNumber(conn, oid.getDistErpNum(), distMap);
                        if(dist != null){
                            distName = dist.getShortDesc();
                            distId = dist.getBusEntityId();
                        }
                    }

                    if(lastInvoiceCustId != icd.getInvoiceCustId() || !lastDistName.equals(distName)){
                        lastDistName = distName;
                        o = OutboundEDIRequestData.createValue();
                        o.setDistributorName(distName);
                        if(distId != 0){
                            PropertyUtil pru = new PropertyUtil(conn);
                            try{
                            	String distCustRefCd = pru.fetchValue(0,distId, RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_REFERENCE_CODE);
                            	o.setDistributorCustomerReferenceCode(distCustRefCd);
                            }catch(DataNotFoundException e){
                                //it will remain null
                            }
                        }


                        o.setDistributorId(distId);
                        o.setIncomingTradingProfileId(partnerId);
                        o.setInvoiceData(icd);
                        o.setInvoiceCustDetailViewDV(new InvoiceCustDetailViewVector());
                        Integer key = new Integer(icd.getAccountId());
                        if(accountPropMap.containsKey(key)){
                            PropertyDataVector acctP = (PropertyDataVector)accountPropMap.get(key);
                            PropertyData pd = Utility.getProperty(acctP, RefCodeNames.PROPERTY_TYPE_CD.EDI_SHIP_TO_PREFIX);
                            String value = null;
                            if(pd != null){
                                value = pd.getValue();
                            }
                            if(!Utility.isSet(value)){
                                value = Integer.toString(icd.getAccountId());
                            }
                            o.setAccountIdentifier(value);
                            o.setAccountProperties(acctP);
                        }else{
                            DBCriteria apcrit = new DBCriteria();
                            apcrit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,
                                              icd.getAccountId());
                            log.debug("Gettting account props for account: " + icd.getAccountId());
                            PropertyDataVector acctP = PropertyDataAccess.select(conn,apcrit);
                            PropertyData pd = Utility.getProperty(acctP, RefCodeNames.PROPERTY_TYPE_CD.EDI_SHIP_TO_PREFIX);
                            String value = null;
                            if(pd != null){
                                value = pd.getValue();
                            }
                            if(!Utility.isSet(value)){
                                value = Integer.toString(icd.getAccountId());
                            }
                            o.setAccountIdentifier(value);
                            o.setAccountProperties(acctP);
                            accountPropMap.put(key,acctP);
                        }

                        outboundEDIReqDV.add(o);
                    }


                    InvoiceCustDetailView vw = InvoiceCustDetailView.createValue();
                    vw.setOrderItemData(oid);
                    vw.setInvoiceCustDetailData(icdd);
                    o.getInvoiceCustDetailViewDV().add(vw);

                }

                return outboundEDIReqDV;
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.T850_REBATE)) {
            	Connection rebateConn = null;

            	try{
            		String dataSource = getTradingPropertyValue(partnerId, setType, "OUT", "DATA_SOURCE");

	            	rebateConn = getJDIntegrationConnection();
	            	String sql = "SELECT * FROM PRI_TRANS_REBATE_APPROVED " +
	            			"WHERE CONNECTION_STATUS = 'PENDING' ";
	            	if (dataSource == null){
	            		sql += "AND DATA_SOURCE = 'JDE' ";
	            	}else {
	            		sql += "AND DATA_SOURCE = '" + dataSource + "' ";
	            	}
	            	sql += "ORDER BY REBATE_ID, CONTRACT_NUMBER, PRODUCT_SKU";

	            	Statement stmt = rebateConn.createStatement();
	            	PreparedStatement pstmt = rebateConn.prepareStatement("UPDATE PRI_TRANS_REBATE_APPROVED SET CONNECTION_STATUS = 'PENDING_PROCESSING', MODIFIED_DATE = SYSDATE WHERE TRANS_REBATE_APPROVED_ID = ?");
	                log.debug("Executing: "+sql);
	                ResultSet rs = stmt.executeQuery(sql);
	                String prevTransactionKey = null;
	                String prevRebateNumber = null;
	                TransRebateApprovedViewVector currRebateItems = null;

	                while (rs.next()){
	                	int rebateId = rs.getInt("REBATE_ID");
	                	String contractNum = rs.getString("CONTRACT_NUMBER");
	                	String transactionKey = rebateId + ":" + contractNum;

	                	if (!transactionKey.equals(prevTransactionKey)){
	                		currRebateItems = new TransRebateApprovedViewVector();
	                		OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
	                        reqData.setTransRebateApprovedDV(currRebateItems);
	                        outboundEDIReqDV.add(reqData);
	                        prevTransactionKey = transactionKey;
	                	}
	                	TransRebateApprovedView transRebateData = new TransRebateApprovedView();
	                	currRebateItems.add(transRebateData);
	                	transRebateData.setTransRebateApprovedId(rs.getInt("TRANS_REBATE_APPROVED_ID"));
	                	transRebateData.setRebateNumber(rs.getString("REBATE_NUMBER"));
	                	transRebateData.setDistributorNumber(rs.getString("DISTRIBUTOR_NUMBER"));
	                	transRebateData.setContractNumber(rs.getString("CONTRACT_NUMBER"));
	                	transRebateData.setContractDesc(rs.getString("CONTRACT_DESC"));
	                	transRebateData.setProductSku(rs.getString("PRODUCT_SKU"));
	                	transRebateData.setProductDesc(rs.getString("PRODUCT_DESC"));
	                	transRebateData.setQuantity(rs.getString("QUANTITY"));
	                	transRebateData.setUom(rs.getString("UOM"));
	                	transRebateData.setRbtAmountAdj(rs.getBigDecimal("RBT_AMOUNT_ADJ"));
	                	transRebateData.setRebateTypeCode(rs.getString("REBATE_TYPE_CD"));
	                	transRebateData.setRebateDate(rs.getTimestamp("REBATE_DATE"));
	                	transRebateData.setSalesOrg(rs.getString("SALES_ORG"));
	                	transRebateData.setDistChannel(rs.getString("DIST_CHANNEL"));
	                	transRebateData.setDivision(rs.getString("DIVISION"));
	                	transRebateData.setReason(rs.getString("REASON"));
	                	transRebateData.setUnitPrice(rs.getBigDecimal("UNIT_PRICE"));
	                	transRebateData.setDistProductSku(rs.getString("DIST_PRODUCT_SKU"));
	                	pstmt.setInt(1, transRebateData.getTransRebateApprovedId());
	                	pstmt.execute();
	                }
	                pstmt.close();
	                return outboundEDIReqDV;
            	}finally{
            		closeConnection(rebateConn);
            	}
            }else if (setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_TOTALS_OUT) ||
            		setType.equals(RefCodeNames.EDI_TYPE_CD.TACCOUNT_OUT) ||
            		setType.equals(RefCodeNames.EDI_TYPE_CD.TSITE_OUT) ||
            		setType.equals(RefCodeNames.EDI_TYPE_CD.TON_HAND_VALUE_OUT)){
            	OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
            	Map genericMap = new HashMap();
            	genericMap.put("STORE_ID", new Integer(busEntityId));
            	reqData.setGenericMap(genericMap);
                outboundEDIReqDV.add(reqData);
                return outboundEDIReqDV;
            }

	    progressString = " X12 > ";
            log.debug("X12 getValidOutboundEDIOrders");
            outboundEDIReqDV = getValidOutboundEDIOrders(outboundEDIReqDV,
                                                         setType, tpInfo,
                                                         erpNum, strictValidation, conn);
	    progressString = " < X13 ";
            log.debug("X13 getValidOutboundEDIOrders got " +outboundEDIReqDV.size() + " orders to process" +" for erpNum=" + erpNum +" and setType=" + setType);

            return outboundEDIReqDV;
        } catch (Exception exc) {
            String em = "Error. IntegrationServicesBean.getEDIOrdersByErpNumAndSetType: Exception at: " +
		progressString + " Message: " +
                 exc.getMessage();
            log.error(em);
	    exc.printStackTrace();

            throw new RemoteException(em);
        } finally {
	    closeConnection(conn);
        }
    }

    private OutboundEDIRequestDataVector getValidOutboundEDIOrders
	(OutboundEDIRequestDataVector pOutboundEDIReqDV,
	 String setType,
	 TradingPartnerInfo tpInfo,
	 String erpNum,
         boolean strictValidation,
	 Connection conn)
        throws RemoteException, SQLException {

        if (pOutboundEDIReqDV.size() == 0) {

            return pOutboundEDIReqDV;
        }

        //XXX build validation
        if(setType.equals(RefCodeNames.EDI_TYPE_CD.TMANIFEST_OUT)){
            return pOutboundEDIReqDV;
        }

        OutboundEDIRequestDataVector tempReqDV =
	    new OutboundEDIRequestDataVector();

        for (int i = 0; i < pOutboundEDIReqDV.size(); i++) {

            OutboundEDIRequestData reqData = (OutboundEDIRequestData)pOutboundEDIReqDV.get(i);
            OrderData currOrder = reqData.getOrderD();
            OrderAddressData shipAddr = reqData.getShipAddr();
            OrderAddressData custShipAddr = reqData.getCustShipAddr();
            OrderItemDataVector items = reqData.getOrderItemDV();
            InvoiceAbstractionView currCustInvoice = reqData.getInvoiceCustD();
            String freightChargeType = reqData.getFreightChargeType();
            List reqInvoiceDetailDV = reqData.getInvoiceDetailDV();
            InvoiceDistData currDistInvoice = reqData.getInvoiceDistD();
            OrderPropertyDataVector orderPropDV = reqData.getOrderPropertyDV();
            String logString = "";
            int invoiceDistId = 0;
            int invoiceCustId = 0;
            int orderAddressId = 0;
            boolean exceptionFlag = false;

            if(currOrder != null){

	            // validate fields for all the transaction sets
	            if (!Utility.isSet(currOrder.getRequestPoNum())) {

	                if (RefCodeNames.ORDER_SOURCE_CD.EDI_850.equals(currOrder.getOrderSourceCd()) 
	                		&& !RefCodeNames.ORDER_TYPE_CD.BATCH_ORDER.equals(currOrder.getOrderTypeCd())) {
	                    logString += "REQUEST_PO_NUM in table CLW_ORDER can't be null for EDI order\r\n";
	                }
	                /*
	                else {
	                    currOrder.setRequestPoNum("N/A");
	                }
	                */
	            }

	            if (!Utility.isSet(currOrder.getOrderNum())) {
	                logString += "ORDER_NUM in table CLW_ORDER is null\r\n";
	            }

	            if (!Utility.isSet(currOrder.getOrderSiteName())) {
	                logString += "ORDER_SITE_NAME in table CLW_ORDER is null\r\n";
	            }

	            if (!Utility.isSet(currOrder.getOrderSourceCd())) {
	                logString += "ORDER_SOURCE_CD in table CLW_ORDER is null\r\n";
	            }

            }//end currOrder not null check

            if (shipAddr != null && RefCodeNames.ADDRESS_COUNTRY_CD.UNITED_STATES.equals(shipAddr.getCountryCd())) {
                orderAddressId = shipAddr.getOrderAddressId();

                if (!Utility.isSet(shipAddr.getShortDesc())) {
                    logString += "SHORT_DESC in table CLW_ORDER_ADDRESS for shipping is null\r\n";
                }

                if (!Utility.isSet(shipAddr.getCity())) {
                    logString += "CITY in table CLW_ORDER_ADDRESS for shipping is null\r\n";
                }

                if (!Utility.isSet(shipAddr.getStateProvinceCd())) {
                    logString += "STATE_PROVINCE_CD in table CLW_ORDER_ADDRESS for shipping is null\r\n";
                }

                if (!Utility.isSet(shipAddr.getPostalCode())) {
                    logString += "POSTAL_CODE in table CLW_ORDER_ADDRESS for shipping is null\r\n";
                }
            }

            if (items != null) {

                for (int j = 0; j < items.size(); j++) {

                    OrderItemData currItem = (OrderItemData)items.get(j);
                    String itemLogString = "";

                    if (!setType.equals("855") && !setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT)) {

                        if (!Utility.isSet(currItem.getErpPoNum())) {
                            itemLogString += "ERP_PO_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }

                        if (currItem.getErpPoDate() == null) {
                            itemLogString += "ERP_PO_DATE in table CLW_ORDER_ITEM is null\r\n";
                        }

                        if (currItem.getErpPoLineNum() == 0) {
                            itemLogString += "ERP_PO_LINE_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }
                    }

                    if (currItem.getTotalQuantityOrdered() == 0) {
                        itemLogString += "TOTAL_QUANTITY_ORDERED in table CLW_ORDER_ITEM is null\r\n";
                    }

                    if(!setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT)){
                        if (currItem.getCustLineNum() == 0) {
                            itemLogString += "CUST_LINE_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }

                        if (!setType.equals("855")){
                            if (!Utility.isSet(currItem.getDistItemCost())) {
                                itemLogString += "DIST_ITEM_COST in table CLW_ORDER_ITEM is null\n currItem=" + currItem;
                            }

                            if (!Utility.isSet(currItem.getDistItemSkuNum())) {
                                itemLogString += "DIST_ITEM_SKU_NUM in table CLW_ORDER_ITEM is null\n currItem=" + currItem;
                            }
                        }
                    }

                    if(setType.equals("855") && tpInfo.getTradingPartnerData().getSkuTypeCd().equals(RefCodeNames.SKU_TYPE_CD.CUSTOMER)){
                        if (!Utility.isSet(currItem.getCustItemSkuNum())) {
                            itemLogString += "CUST_ITEM_SKU_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }

                        //if (!Utility.isSet(currItem.getCustItemShortDesc())) {
                        //    itemLogString += "CUST_ITEM_SHORT_DESC in table CLW_ORDER_ITEM is null\r\n";
                        //}

                        if (!Utility.isSet(currItem.getCustItemUom())) {
                            itemLogString += "CUST_ITEM_UOM in table CLW_ORDER_ITEM is null\r\n";
                        }
                    }else{
                        if (currItem.getItemSkuNum() == 0) {
                            itemLogString += "ITEM_SKU_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }

                        //if (!Utility.isSet(currItem.getItemShortDesc())) {
                        //    itemLogString += "ITEM_SHORT_DESC in table CLW_ORDER_ITEM is null\r\n";
                        //}

                        if (!Utility.isSet(currItem.getItemUom())) {
                            itemLogString += "ITEM_UOM in table CLW_ORDER_ITEM is null\r\n";
                        }
                    }
                    if(setType.equals("855")) {
log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIII validate 855");
                        //Check quantity change
                      int oldQtyChg = 0;
                      int newQtyChg = 0;
                      int qty855 = currItem.getItemQty855();
                      int currQty = currItem.getTotalQuantityOrdered();
                      int orderItemId = currItem.getOrderItemId();
                      if(orderPropDV!=null) {
                        for(int ii=0; ii<orderPropDV.size(); ii++) {
                          OrderPropertyData prop = (OrderPropertyData) orderPropDV.get(ii);
                          if(orderItemId != prop.getOrderItemId()) continue;
                          if(!(RefCodeNames.ORDER_PROPERTY_TYPE_CD.QUANTITY_UPDATE.
                              equals(prop.getOrderPropertyTypeCd()))) continue;
                          String valS = prop.getValue();
                          try {
                            int val = Integer.parseInt(valS);
                            if(RefCodeNames.ORDER_PROPERTY_STATUS_CD.INACTIVE.
                               equals(prop.getOrderPropertyStatusCd())) {
                               oldQtyChg += val;
                            } else {
                               newQtyChg += val;
                            }
                          } catch (Exception exc) {
                            if(!(RefCodeNames.ORDER_PROPERTY_STATUS_CD.INACTIVE.
                               equals(prop.getOrderPropertyStatusCd()))) {
                              itemLogString += "Active QUANTITY_UPDATE property value has wrong format: "+valS+"\r\n";
                            }
                          }
                        }
                      }
                      if(newQtyChg<0) {
                        if(qty855!=0 ||
                            RefCodeNames.ORDER_SOURCE_CD.EDI_850.
                               equals(currOrder.getOrderSourceCd()))
                           itemLogString += "Wrong request to increase item qutantity. Change quantity: "+newQtyChg+"\r\n";
                      }
                      if(qty855!=0 &&
                         oldQtyChg + newQtyChg + currQty != qty855) {
                          itemLogString += "Inconsistent request to change item qutantity. Change quantity: "+newQtyChg+"\r\n";
                      }
                      if(qty855==0 &&
                         oldQtyChg !=0 ) {
                         itemLogString += "Inconsitency in item 855 parameters. Qty855 =0 but already sent quantiy = "+
                                     oldQtyChg+"\r\n";

                      }
                      if(qty855==0 && newQtyChg>currQty) {
                          itemLogString += "Inconsitency in item 855 parameters. Requested quantiy change ("+
                                         newQtyChg+") is bigger than quantity ordered ("+currQty+")"+"\r\n";
                      }
                      if(oldQtyChg !=0 && newQtyChg==0 &&
                         !RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED.
                                          equals(currItem.getOrderItemStatusCd())) {
                            itemLogString += "Requested 855 resending after quatnity was modified";
                      }
                    }
                    if (Utility.isSet(itemLogString)) {
                        OrderDAO.enterOrderProperty(conn,
                                           RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                           "Outbound EDI " + setType +
                                           " Exception", itemLogString,
                                           currOrder.getOrderId(),
                                           currItem.getOrderItemId(), 0, 0, 0,
                                           0, 0, "system 18");
                        exceptionFlag = true;
                        log.error("X14: Outbound EDI " + setType +" Exception: " + itemLogString);
                    }
                }
            }

            if (custShipAddr != null && strictValidation) {
                orderAddressId = custShipAddr.getOrderAddressId();

                String temp = " in table CLW_ORDER_ADDRESS for " +
                              custShipAddr.getAddressTypeCd() +
                              " is null\r\n";

                if (!Utility.isSet(custShipAddr.getCity())) {
                    logString += "CITY" + temp;
                }

                if (!Utility.isSet(custShipAddr.getStateProvinceCd())) {
                    logString += "STATE_PROVINCE_CD" + temp;
                }

                if (!Utility.isSet(custShipAddr.getPostalCode())) {
                    logString += "POSTAL_CODE" + temp;
                }

                if (!Utility.isSet(custShipAddr.getAddress1())) {
                    logString += "ADDRESS1" + temp;
                }

                if (!Utility.isSet(custShipAddr.getAddress4())) {

                    if (!Utility.isStreetAddress(custShipAddr.getAddress2())) {

                        if (!Utility.isStreetAddress(custShipAddr.getAddress3())) {

                            if (!Utility.isStreetAddress(custShipAddr.getAddress1())) {
                                logString += "Street Address is missing" + temp
				    + " address: " + custShipAddr;
                            }
                        }
                    }
                }
            }

            if (currDistInvoice != null) {
                invoiceDistId = currDistInvoice.getInvoiceDistId();
            }

            if (currCustInvoice != null) {
                if(reqData.getInvoiceCustD().isInvoiceCust()){
                    invoiceCustId = currCustInvoice.getInvoiceId();
                }else{
                    invoiceDistId = currCustInvoice.getInvoiceId();
                }


                if (!Utility.isSet(currCustInvoice.getInvoiceNum())) {
                    logString += "INVOICE_NUM in table CLW_INVOICE_CUST is null\r\n";
                }

                if (currCustInvoice.getInvoiceDate() == null) {
                    logString += "INVOICE_DATE in table CLW_INVOICE_CUST is null\r\n";
                }

                if (strictValidation && currOrder.getOrderStatusCd().equals(
                            RefCodeNames.ORDER_STATUS_CD.CANCELLED)) {
                    logString += "Order has been canceled\r\n";
                }

                if (RefCodeNames.INVOICE_TYPE_CD.CR.equals(currCustInvoice.getInvoiceType())) {

                    if (strictValidation && currCustInvoice.getOriginalInvoiceNum() == null) {
                        logString += "ORIGINAL_INVOICE_NUM in table CLW_INVOICE_CUST is null for a credit\r\n";
                    }
                }
            }

            if (reqInvoiceDetailDV != null) {

                for (int j = 0; j < reqInvoiceDetailDV.size(); j++) {

                    InvoiceCustDetailRequestData reqDetail =
                            (InvoiceCustDetailRequestData)reqInvoiceDetailDV.get(
                                    j);
                    InvoiceAbstractionDetailView currInvoiceItem =
                            reqDetail.getInvoiceDetailD();
                    OrderItemData currOrderItem = reqDetail.getOrderItemD();
                    int orderItemId = 0;
                    String itemLogString = "";

                    if (currOrderItem == null && strictValidation) {
                        itemLogString += "Order item not found for order item id = " + currInvoiceItem.getOrderItemId() + "\r\n";
                    } else if(strictValidation) {
                        if(currOrderItem != null){
                            orderItemId = currOrderItem.getOrderItemId();
                        }

                        if (currOrderItem!= null && RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED.equals(currOrderItem.getOrderItemStatusCd())) {
                            itemLogString += "Order item has been canceled\r\n";
                        }

                        if (strictValidation && currOrderItem.getCustLineNum() == 0) {
                            itemLogString += "CUST_LINE_NUM in table CLW_ORDER_ITEM is null\r\n";
                        }

                        if (tpInfo != null &&
                            tpInfo.isValidateCustomerSkuNum()) {

                            if (!Utility.isSet(currOrderItem.getCustItemSkuNum())) {
                                itemLogString += "CUST_ITEM_SKU_NUM in table CLW_ORDER_ITEM is null\r\n";
                            }

                            if (!Utility.isSet(currOrderItem.getCustItemShortDesc())) {
                                itemLogString += "CUST_ITEM_SHORT_DESC in table CLW_ORDER_ITEM is null\r\n";
                            }
                        }

                        // Check Sku
                        int sku = currInvoiceItem.getItemSkuNum();


                        if (strictValidation) {
                            int skuMatch = currOrderItem.getItemSkuNum();
                            if(sku != skuMatch){
                                itemLogString += "SKU in invoice (" + sku + ") doesn't match " + " value in order item status record (" + skuMatch + ")";
                            }
                        }

                        // Check UOM
                        String v = currInvoiceItem.getItemUom();

                        if (v != null) {
                            currInvoiceItem.setItemUom(v.trim());
                        } else {
                            log.error("null for currInvoiceItem.getItemUom");
                            currInvoiceItem.setItemUom("---");
                        }

                        if(currOrderItem != null){
                            String v2 = currOrderItem.getItemUom();
                            if (v2 != null) {
                                currOrderItem.setItemUom(v2.trim());
                            } else {
                                log.error("null for currOrderItem.getItemUom");
                                currOrderItem.setItemUom("--");
                            }
                        }

                        if(strictValidation){
                            String uom = currInvoiceItem.getItemUom();
                            String uomMatch = currOrderItem.getItemUom();

                            if (!Utility.matchUOM(uom, uomMatch)) {
                                itemLogString += "UOM in invoice (" + uom + ") doesn't match " + " value in order item status record (" + uomMatch + ")";
                            }
                        }

                        // Check that sum of quantity invoiced doesn't exceed quantity ordered
                        if(strictValidation){

                            int quantityInvoiced = getQuantityInvoicedByOrderItemId(currOrderItem.getOrderItemId(),
                                                                                    conn);
                            int quantityOrdered = currOrderItem.getTotalQuantityOrdered();

                            if (quantityOrdered < quantityInvoiced) {
                                itemLogString += "Sum of quantity invoiced (" + quantityInvoiced + ") exceeds quantity ordered (" + quantityOrdered + ")\r\n";
                            }
                        }
                    }

                    if (currInvoiceItem.getLineNumber() == 0 && strictValidation) {
                        itemLogString += "LINE_NUMBER in table CLW_INVOICE_CUST_DETAIL is null\r\n";
                    }

                    if (currInvoiceItem.getItemSkuNum() == 0 && strictValidation) {
                        itemLogString += "ITEM_SKU_NUM in table CLW_INVOICE_CUST_DETAIL is null\r\n";
                    }

                    if (currInvoiceItem.getItemQuantity() == 0) {
                        itemLogString += "ITEM_QUANTITY in table CLW_INVOICE_CUST_DETAIL is null\r\n";
                    }

                     if (!Utility.isSet(currInvoiceItem.getItemUom()) && strictValidation) {
                        itemLogString += "ITEM_UOM in table CLW_INVOICE_CUST_DETAIL is null\r\n";
                    }

                    if (currInvoiceItem.getCustContractPrice() == null && strictValidation) {
                        itemLogString += "CUST_CONTRACT_PRICE in table CLW_INVOICE_CUST_DETAIL is null\r\n";
                    }

                    if (Utility.isSet(itemLogString)) {
                        if(currInvoiceItem.isInvoiceCust()){
                            OrderDAO.enterOrderProperty(conn,
                                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                               "Outbound EDI " + setType +
                                               " Exception", itemLogString,
                                               currOrder.getOrderId(), orderItemId,
                                               invoiceDistId, 0, invoiceCustId,
                                               currInvoiceItem.getInvoiceDetailId(),
                                               0, "system 19");
                        }else{
                            OrderDAO.enterOrderProperty(conn,
                                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                               "Outbound EDI " + setType +
                                               " Exception", itemLogString,
                                               currOrder.getOrderId(), orderItemId,
                                               invoiceDistId, currInvoiceItem.getInvoiceDetailId(), invoiceCustId,
                                               0,
                                               0, "system 19");
                        }
                        exceptionFlag = true;
                        log.error("X15: Outbound EDI " + setType +" Exception: " + itemLogString);
                    }
                }
            }

            if (setType.equals("850")) {


                if (!Utility.isSet(reqData.getAccountIdentifier())) {
                    logString += "Unable to get account identifier (account Id) for SITE_ERP_NUM = " + currOrder.getSiteErpNum() + "\r\n";
                }
                if (!Utility.isSet(reqData.getSiteIdentifier())) {
                    logString += "Unable to get site identifier for SITE_ERP_NUM = " + currOrder.getSiteErpNum() + "\r\n";
                }

                if (shipAddr == null) {
                    logString += "Unable to get shipping address from table CLW_ORDER_ADDRESS\r\n";
                }

                if (items == null || items.size() == 0) {
                    logString += "Unable to get order item from table CLW_ORDER_ITEM\r\n";
                }
            } else if (setType.equals("855")) {

                /*if (!Utility.isSet(currOrder.getOrderContactName())){
                  logString  +=  "ORDER_CONTACT_NAME in table CLW_ORDER is null\r\n";
                }
                if (!Utility.isSet(currOrder.getOrderContactPhoneNum())){
                  logString  +=  "ORDER_CONTACT_PHONE_NUM in table CLW_ORDER is null\r\n";
                }*/
                if (custShipAddr == null) {
                    logString += "Unable to get customer shipping address from table CLW_ORDER_ADDRESS\r\n";
                }

                if (items == null || items.size() == 0) {
                    logString += "Unable to get order item from table CLW_ORDER_ITEM\r\n";
                }
            } else if (setType.equals("856")) {

                if (custShipAddr == null) {
                    logString += "Unable to get customer shipping address from table CLW_ORDER_ADDRESS\r\n";
                }

                /*if (currDistInvoice == null){
                  logString  += "Unable to get distributor invoice from table CLW_INVOICE_DIST\r\n";
                }*/
                if (currCustInvoice == null) {
                    logString += "Unable to get customer invoice from table CLW_INVOICE_CUST\r\n";
                }

                if (reqInvoiceDetailDV == null ||
                    reqInvoiceDetailDV.size() == 0) {
                    logString += "Unable to get invoice detail from table CLW_INVOICE_CUST_DETAIL\r\n";
                }
            } else if (setType.equals("810")) {

                if (tpInfo != null && tpInfo.isValidateRefOrderNum()) {

                    if (currOrder!=null && !Utility.isSet(currOrder.getRefOrderNum())) {
                        logString += "REF_ORDER_NUM in table CLW_ORDER is null\r\n";
                    }
                }

                if (custShipAddr == null) {
                    logString += "Unable to get customer shipping address from table CLW_ORDER_ADDRESS\r\n";
                }

                if (currCustInvoice == null) {
                    logString += "Unable to get customer invoice from table CLW_INVOICE_CUST\r\n";
                } else {

                    if (currCustInvoice.getNetDue() == null) {
                        logString += "NET_DUE in table CLW_INVOICE_CUST is null\r\n";
                    }
                }

                if ((reqInvoiceDetailDV == null ||
                    reqInvoiceDetailDV.size() == 0) && strictValidation) {
                    logString += "Unable to get invoice detail from table CLW_INVOICE_CUST_DETAIL\r\n";
                }

            }

            if (Utility.isSet(logString) && currOrder != null) {

                OrderDAO.enterOrderProperty(conn,
                                   RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                                   "Outbound EDI " + setType + " Exception",
                                   logString, currOrder.getOrderId(), 0,
                                   invoiceDistId, 0, invoiceCustId, 0,
                                   orderAddressId, "system 20");
                exceptionFlag = true;
                log.error("X16: Outbound EDI " + setType + " Exception: " +logString);
            }

            if (!exceptionFlag) {
                tempReqDV.add(reqData);
            } else {

                if (setType.equals("850")) {
                    reqData.getPurchaseOrderD().setPurchaseOrderStatusCd(
                            RefCodeNames.ORDER_ITEM_STATUS_CD.SENT_TO_DISTRIBUTOR_FAILED);

                    for (int j = 0; j < items.size(); j++) {

                        OrderItemData currItem = (OrderItemData)items.get(j);
                        currItem.setOrderItemStatusCd(
                                RefCodeNames.ORDER_ITEM_STATUS_CD.SENT_TO_DISTRIBUTOR_FAILED);
                        OrderItemDataAccess.update(conn, currItem);
                    }
                } else if (setType.equals("855")) {

                    for (int j = 0; j < items.size(); j++) {

                        OrderItemData currItem = (OrderItemData)items.get(j);
			String oistatus = currItem.getOrderItemStatusCd();
			if ( null == oistatus ) {
			    oistatus = "";
			}
                        if (RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED.equals
			    (oistatus)
			    ) {
                            currItem.setAckStatusCd
				(RefCodeNames.ACK_STATUS_CD.CANCELLED_ACK_FAILED);
                        } else {
                            currItem.setAckStatusCd
				(RefCodeNames.ACK_STATUS_CD.CUST_ACK_FAILED);
                        }

                        OrderItemDataAccess.update(conn, currItem);
                    }
                } else if (setType.equals("856")) {

                    for (int j = 0; j < reqInvoiceDetailDV.size(); j++) {

                        InvoiceCustDetailRequestData reqDetail =
                                (InvoiceCustDetailRequestData)reqInvoiceDetailDV.get(
                                        j);
                        InvoiceAbstractionDetailView currInvoiceItem =
                                reqDetail.getInvoiceDetailD();
                        currInvoiceItem.setShipStatusCd(
                                RefCodeNames.SHIP_STATUS_CD.FAILED);
                        if(currInvoiceItem.getInvoiceCustDetailData()!=null){
                            InvoiceCustDetailDataAccess.update(conn, currInvoiceItem.getInvoiceCustDetailData());
                        }else if(currInvoiceItem.getInvoiceDistDetailData()!=null){
                            InvoiceDistDetailDataAccess.update(conn, currInvoiceItem.getInvoiceDistDetailData());
                        }
                    }
                } else if (setType.equals("810")) {currCustInvoice.setInvoiceStatusCd(
                                RefCodeNames.INVOICE_STATUS_CD.CUST_INVOICED_FAILED);

                    if(currCustInvoice.isInvoiceCust()){
                        InvoiceCustDataAccess.update(conn, currCustInvoice.getInvoiceCustData());
                    }else if(currCustInvoice.isInvoiceDist()){
                        InvoiceDistDataAccess.update(conn, currCustInvoice.getInvoiceDistData());
                    }
                }
            }
        }

        return tempReqDV;
    }


    /**
     *Populates the outbound invoice request.  Does some magic around the abstraction of the invoice object based off the store
     *type...that is MLA stores deal with invoice_cust objects and other stores deal with invoice_dist objects.  @see getOutboundInvoicesAndShippingNoticesToSend
     */
    private OutboundEDIRequestData populateOutBoundInvoiceAndShippingNotice(int invoiceId, String storeType,
            Connection conn, String setType,boolean retrivalForFactor, Map paramMap)
    throws Exception{

        log.info("populateOutBoundInvoiceAndShippingNotice. invoiceId:"+invoiceId+ "store type: "+storeType);

        CatalogInformationBean cataInf=null;
        OutboundEDIRequestData reqData = OutboundEDIRequestData.createValue();
        OrderData orderD;
        List invoiceItemDV;
        if(RefCodeNames.STORE_TYPE_CD.MLA.equals(storeType)){
            InvoiceCustData invoiceCustD = InvoiceCustDataAccess.select(conn,invoiceId);
            reqData.setInvoiceData(invoiceCustD);
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceCustDetailDataAccess.INVOICE_CUST_ID, invoiceCustD.getInvoiceCustId());
            if (setType.equals(RefCodeNames.EDI_TYPE_CD.T856)) {
                dbc.addEqualTo(InvoiceCustDetailDataAccess.SHIP_STATUS_CD, RefCodeNames.SHIP_STATUS_CD.PENDING);
            }
            dbc.addOrderBy(InvoiceCustDetailDataAccess.LINE_NUMBER);
            invoiceItemDV = InvoiceCustDetailDataAccess.select(conn, dbc);
            orderD = OrderDataAccess.select(conn, invoiceCustD.getOrderId());
            if (retrivalForFactor) {
                PropertyUtil pru = new PropertyUtil(conn);
                String freightChargeType = pru.fetchValueIgnoreMissing(0, invoiceCustD.getAccountId(), RefCodeNames.PROPERTY_TYPE_CD.FREIGHT_CHARGE_TYPE);
                reqData.setFreightChargeType(freightChargeType);
            }
        }else{
            InvoiceDistData invoiceDistD = InvoiceDistDataAccess.select(conn,invoiceId);
            reqData.setInvoiceData(invoiceDistD);
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceDistDetailDataAccess.INVOICE_DIST_ID, invoiceDistD.getInvoiceDistId());
            dbc.addOrderBy(InvoiceDistDetailDataAccess.ERP_PO_LINE_NUM);
            if(invoiceDistD.getBusEntityId() > 0){
                DistributorData dist = getDistributorData(conn, invoiceDistD.getBusEntityId(), null, paramMap);
                reqData.setDistributorCompanyCode(dist.getDistributorsCompanyCode());
                reqData.setDistributorName(dist.getBusEntity().getShortDesc());
                reqData.setDistributorCustomerReferenceCode(dist.getCustomerReferenceCode());
            }
            invoiceItemDV = InvoiceDistDetailDataAccess.select(conn, dbc);
            try{
                orderD = OrderDataAccess.select(conn, invoiceDistD.getOrderId());
            }catch(Exception e){
                orderD = null;
            }
        }



            List invoiceDetailRequests = new ArrayList();
            reqData.setInvoiceDetailDV(invoiceDetailRequests);


            int orderId = 0;
            if(orderD != null){
                orderId = orderD.getOrderId();
            }
            reqData.setOrderD(orderD);

            DBCriteria crit = new DBCriteria();
            if(orderD != null){
                crit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,orderD.getSiteId());
                crit.addEqualTo(PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                reqData.setSiteProperties(PropertyDataAccess.select(conn,crit));

                String acctKey = "accountProperites::"+orderD.getAccountId();
                if(paramMap.containsKey(acctKey)){
                	PropertyDataVector acctP = (PropertyDataVector) paramMap.get(acctKey);
	                reqData.setAccountProperties(acctP);
                }else{
	                crit = new DBCriteria();
	                PropertyDataVector acctP;
	                if(orderD.getAccountId() == 0){
	                	acctP = new PropertyDataVector();
	                }else{
	                	crit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,orderD.getAccountId());
	                	acctP = PropertyDataAccess.select(conn,crit);
	                }
	                reqData.setAccountProperties(acctP);
	                paramMap.put(acctKey,acctP);
                }
            }

            if(orderId > 0){
                OrderAddressData custShipAddr = getOrderAddress(orderId, RefCodeNames.ADDRESS_TYPE_CD.CUSTOMER_SHIPPING, conn);
                if (custShipAddr == null) {
                    custShipAddr = getOrderAddress(orderId, RefCodeNames.ADDRESS_TYPE_CD.SHIPPING, conn);
                }
                reqData.setCustShipAddr(custShipAddr);
                OrderAddressData custBillAddr = getOrderAddress(orderId, RefCodeNames.ADDRESS_TYPE_CD.CUSTOMER_BILLING, conn);
                //customers like to see back exactly what they sent, so use the customers shipping address if they
                //did not supply a billing address
                if(custBillAddr==null){
                    custBillAddr = custShipAddr;
                }
                reqData.setCustBillAddr(custBillAddr);
                reqData.setCustomerBillingUnit(getCustomerBillingUnit(orderId, conn));
            }


            if (setType.equals("856")) {
                reqData.setInvoiceDistD(getInvoiceDistByOrderId(orderId, conn));
            } else {
                if(orderId > 0){
                    String originalDateOrdered = getOriginalDateOrdered(orderId, conn);

                    if (!Utility.isSet(originalDateOrdered)) {

                        SimpleDateFormat dateFormatter = new SimpleDateFormat("yyyyMMdd");
                        originalDateOrdered = dateFormatter.format(orderD.getOriginalOrderDate());
                    }

                    reqData.setOriginalDateOrdered(originalDateOrdered);
                }
            }

	    IdVector itemsList = new IdVector();
	    OrderItemDataVector orderItemsVector = new OrderItemDataVector();

	    OrderItemData currOrderItem = null;
            for (int j = 0; j < invoiceItemDV.size(); j++) {
            	InvoiceCustDetailRequestData invoiceDet = null;
                if(RefCodeNames.STORE_TYPE_CD.MLA.equals(storeType)){
                    InvoiceCustDetailData temp2 = (InvoiceCustDetailData)invoiceItemDV.get(j);
                    InvoiceCustDetailRequestData temp3 = InvoiceCustDetailRequestData.createValue();
                    temp3.setInvoiceDetailD(temp2);

                    OrderItemData temp4 = null;

                    try {
                        temp4 = OrderItemDataAccess.select(conn, temp2.getOrderItemId());
			currOrderItem = temp4;;
                    } catch (Exception e) {
                        e.printStackTrace();
                        log.error(" -- 99: " + e);
                    }

                    temp3.setOrderItemD(temp4);
                    invoiceDetailRequests.add(temp3);
                    invoiceDet = temp3;
                }else{
                    InvoiceDistDetailData invoiceDistDetail = (InvoiceDistDetailData)invoiceItemDV.get(j);
                    if(invoiceDistDetail.getDistItemQuantity() != 0){
                    	invoiceDet = InvoiceCustDetailRequestData.createValue();
                    	invoiceDet.setInvoiceDetailD(invoiceDistDetail);
                        OrderItemData orderItem = null;
                        try {
                            orderItem = OrderItemDataAccess.select(conn, invoiceDistDetail.getOrderItemId());
			    currOrderItem = orderItem;
                        } catch (Exception e) {
                        	log.debug(" -- 99: " +invoiceDistDetail.getInvoiceDistDetailId()+"::"+ e);
                        }

                        invoiceDet.setOrderItemD(orderItem);
                        invoiceDetailRequests.add(invoiceDet);
                    }
                }


                if(currOrderItem != null){
                	if(invoiceDet != null){
	                	int itemId =  currOrderItem.getItemId();
	                	if(cataInf==null){
	                		cataInf = new CatalogInformationBean();
	                	}
	                	CatalogCategoryDataVector categs = cataInf.getStoreProduct(reqData.getInvoiceData().getStoreId(), itemId,conn).getCatalogCategories();
	                	if(categs != null && !categs.isEmpty()){
	                		CatalogCategoryData firstCat = (CatalogCategoryData)categs.get(0);
	                		invoiceDet.setStoreCategory(firstCat.getCatalogCategoryShortDesc());
	                	}
                	}

					// Set the manifest information if any is available.
					reqData.setManifestItemView(getLatestManifestInfo(conn,currOrderItem));
					itemsList.add(new Integer(currOrderItem.getItemId()));
					orderItemsVector.add(currOrderItem);
                }
            }

            // the other piece of info needed is the weight of all items
            // in the invoice.
            crit = new DBCriteria();
            crit.addOneOf(ItemMetaDataAccess.ITEM_ID, itemsList);
            crit.addEqualTo(ItemMetaDataAccess.NAME_VALUE,
			    ProductData.SHIP_WEIGHT);
            ItemMetaDataVector imdv = ItemMetaDataAccess.select(conn,crit);
	    int totalWeight = 0;
            if ( null != imdv && imdv.size() > 0 ) {
                ItemMetaData imd = (ItemMetaData)imdv.get(0);
		for ( int j = 0; j < orderItemsVector.size(); j++) {
		    OrderItemData oid = (OrderItemData)orderItemsVector.get(j);
		    if ( imd.getItemId() == oid.getItemId() ) {
			// finaly we get to the weight of the item
			// times the number of these items in the
			// invoice being processed.
			totalWeight +=
			    (
			     howManyInTheInvoices
			     (oid.getOrderItemId(), invoiceItemDV)
			     *
			     ProductData.extractWeightValueInLbs
			     (imd.getValue())
			     );
		    }
		}

            }

	    if ( reqData.getManifestItemView() != null ) {
		reqData.getManifestItemView().setWeightString
		    (String.valueOf(totalWeight));
		log.debug("totalWeight=" + totalWeight);
	    }

        return reqData;
    }

    private int howManyInTheInvoices(int pOrderItemId, List invoiceItemDV) {
	int totalItemQty = 0;
	for (int j = 0; j < invoiceItemDV.size(); j++) {
	    if ( invoiceItemDV.get(j) instanceof InvoiceCustDetailData ) {
		InvoiceCustDetailData invd =
		    (InvoiceCustDetailData)invoiceItemDV.get(j);
		if ( invd.getOrderItemId() == pOrderItemId) {
		    totalItemQty += invd.getItemQuantity();
		}
	    } else {
		InvoiceDistDetailData invd =
		    (InvoiceDistDetailData)invoiceItemDV.get(j);
		if ( invd.getOrderItemId() == pOrderItemId) {
		    totalItemQty += invd.getItemQuantity();
		}
	    }
	}
	log.debug("pOrderItemId="+pOrderItemId+ " totalItemQty=" +totalItemQty);
	return totalItemQty;
    }

    private  ManifestItemView getLatestManifestInfo
	(Connection conn, OrderItemData pOrderItem)
    throws Exception{

	ManifestItemView manView = null;
	DBCriteria crit = new DBCriteria();
	crit.addEqualTo(ManifestItemDataAccess.PURCHASE_ORDER_ID,pOrderItem.getPurchaseOrderId());
	boolean ascendingOrder = false;
	crit.addOrderBy(ManifestItemDataAccess.ADD_DATE, ascendingOrder);
	ManifestItemDataVector mans = ManifestItemDataAccess.select(conn,crit);
	if ( null != mans && mans.size() >0 ) {
	    manView = ManifestItemView.createValue();
	    manView.setManifestItem((ManifestItemData)mans.get(0));

        }

	log.debug( " getLatestManifestInfo returning manView=" + manView+ " for pOrderItem=" + pOrderItem);
	return manView;
    }


    /**
     *Returns the 856 and 810 like transactions that are ready to be sent out.  Will figure out based off
     *the supplied store type which ones to get (distributor or customer facing invoices).  Encapsulates all of
     *the logic around ASNs versus the invoices, makes sure to only grab invoices after the 855 is sent etc.  Some of
     *this logic only applies for MLA stores.
     */
    private List getOutboundInvoicesAndShippingNoticesToSend(TradingPartnerInfo tpInfo, List setTypes,
            Connection conn, int busEntityId,String setType, String storeType, boolean retrivalForFactor, int storeId)
    throws Exception{
        log.info("getOutboundInvoicesAndShippingNoticesToSend.store type: "+storeType);
        String noCCSql=OrderCreditCardDataAccess.getSqlSelectIdOnly(OrderCreditCardDataAccess.ORDER_ID, new DBCriteria());
        if(RefCodeNames.STORE_TYPE_CD.MLA.equals(storeType)){
            IdVector invoiceCustIds;
            log.debug(" --- ISB: processing busEntityId: " + busEntityId);

            if (retrivalForFactor) {

                List status = new ArrayList();
                status.add(RefCodeNames.INVOICE_STATUS_CD.ERP_RELEASED);
                status.add(RefCodeNames.INVOICE_STATUS_CD.CUST_INVOICED);
                DBCriteria dbc = new DBCriteria();
                dbc.addNotOneOf(InvoiceCustDataAccess.ORDER_ID,noCCSql);
                dbc.addEqualTo(InvoiceCustDataAccess.CIT_STATUS_CD,
                               RefCodeNames.CIT_STATUS_CD.PENDING);

                //                    dbc.addIsNotNull(InvoiceCustDataAccess.ACCOUNT_ID);
                dbc.addOneOf(InvoiceCustDataAccess.INVOICE_STATUS_CD,
                             status);
                invoiceCustIds = InvoiceCustDataAccess.selectIdOnly(conn,
                                                                    dbc);
                log.debug("X9 sql: " + dbc.getSqlClause() +" got ids: " + invoiceCustIds);
            } else {

                String orderTable = OrderDataAccess.CLW_ORDER + ".";
                String invoiceTable = InvoiceCustDataAccess.CLW_INVOICE_CUST +
                                      ".";
                String itemTable = OrderItemDataAccess.CLW_ORDER_ITEM +
                                   ".";
                String invoiceDetailTable = InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL +
                                            ".";
                String ORDER_ID = OrderDataAccess.ORDER_ID;
                String INVOICE_CUST_ID = InvoiceCustDataAccess.INVOICE_CUST_ID;
                String ORDER_ITEM_ID = OrderItemDataAccess.ORDER_ITEM_ID;
                String ACCOUNT_ID = OrderDataAccess.CLW_ORDER + "."
			+ OrderDataAccess.ACCOUNT_ID;
                String SHIP_STATUS_CD = InvoiceCustDetailDataAccess.SHIP_STATUS_CD;
                String INVOICE_STATUS_CD = InvoiceCustDataAccess.INVOICE_STATUS_CD;
                String ORDER_STATUS_CD = OrderDataAccess.ORDER_STATUS_CD;
                String ACK_STATUS_CD = OrderItemDataAccess.ACK_STATUS_CD;
                String INVOICE_CUST_DETAIL_ID = InvoiceCustDetailDataAccess.INVOICE_CUST_DETAIL_ID;
                String ERP_Released = RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED;
                String SUCCESS = RefCodeNames.SHIP_STATUS_CD.SUCCESS;
                String ERP_RELEASED = RefCodeNames.INVOICE_STATUS_CD.ERP_RELEASED;
                String CUST_ACK_SUCCESS = RefCodeNames.ACK_STATUS_CD.CUST_ACK_SUCCESS;
                String query = "SELECT distinct " + invoiceTable +
                               InvoiceCustDataAccess.INVOICE_CUST_ID +
                               " FROM CLW_ORDER, CLW_INVOICE_CUST," +
                               " CLW_INVOICE_CUST_DETAIL, CLW_ORDER_ITEM" +
                               " WHERE " + orderTable + ORDER_ID +
                               " = " + invoiceTable + ORDER_ID +
                               " AND " + invoiceTable + INVOICE_CUST_ID +
                               " = " + invoiceDetailTable +
                               INVOICE_CUST_ID + " AND " +
                               invoiceDetailTable + ORDER_ITEM_ID +
                               " = " + itemTable + ORDER_ITEM_ID;
                DBCriteria dbc = new DBCriteria();
                dbc.addEqualTo(ACCOUNT_ID, busEntityId);
                dbc.addEqualTo(INVOICE_STATUS_CD, ERP_RELEASED);
                //if 810 pickup everything in case it is a credit
                if(!setType.equals(RefCodeNames.EDI_TYPE_CD.T810)){
                    dbc.addEqualTo(ORDER_STATUS_CD, ERP_Released);
                }

                if(setType.equals(RefCodeNames.EDI_TYPE_CD.T810)){
		    // Do not send $0 dollar invoices.
                    dbc.addNotEqualTo(InvoiceCustDataAccess.NET_DUE, 0);
                }

                if (setTypes.contains(RefCodeNames.EDI_TYPE_CD.T855)) { // USPS
                    dbc.addEqualTo(ACK_STATUS_CD, CUST_ACK_SUCCESS);
                }

                if (setType.equals(RefCodeNames.EDI_TYPE_CD.T856)) {
                    dbc.addEqualTo(SHIP_STATUS_CD,
                                   RefCodeNames.SHIP_STATUS_CD.PENDING);

                    // do not include the credit
                    dbc.addEqualTo(InvoiceCustDataAccess.INVOICE_TYPE,
                                   RefCodeNames.INVOICE_TYPE_CD.IN);
                    query += " AND " + dbc.getWhereClause();
                } else {

                    // check if customer want to receive the credit
                    if (tpInfo != null &&
                        !tpInfo.isProcessInvoiceCredit()) {
                        dbc.addEqualTo(InvoiceCustDataAccess.INVOICE_TYPE,
                                       RefCodeNames.INVOICE_TYPE_CD.IN);
                    }

                    query += " AND " + dbc.getWhereClause();

                    if (setTypes.contains(RefCodeNames.EDI_TYPE_CD.T855)) { // USPS
                        dbc.addEqualTo(SHIP_STATUS_CD, SUCCESS);
                        query += " AND (INVOICE_TYPE = 'CR' OR ((SELECT COUNT(" + INVOICE_CUST_DETAIL_ID + ") FROM CLW_INVOICE_CUST_DETAIL" + " WHERE " + INVOICE_CUST_ID + " = " + invoiceTable + INVOICE_CUST_ID + " AND " + SHIP_STATUS_CD + " = '" + SUCCESS + "') = (SELECT COUNT(" + INVOICE_CUST_DETAIL_ID + ") FROM CLW_INVOICE_CUST_DETAIL" + " WHERE " + INVOICE_CUST_ID + " = " + invoiceTable + INVOICE_CUST_ID + ")))";
                    }
                }

                log.info("X10 query: " + query);

                Statement stmt = conn.createStatement();
                ResultSet rs = stmt.executeQuery(query);
                invoiceCustIds = new IdVector();

                while (rs.next()) {

                    int uid = rs.getInt(1);
                    invoiceCustIds.add(new Integer(uid));
                }

                stmt.close();
            }

            DBCriteria dbc = new DBCriteria();
            dbc.addNotOneOf(InvoiceCustDataAccess.ORDER_ID,noCCSql);
            dbc.addOneOf(InvoiceCustDataAccess.INVOICE_CUST_ID, invoiceCustIds);
            log.info(InvoiceCustDataAccess.getSqlSelectIdOnly("*",dbc));
            return InvoiceCustDataAccess.selectIdOnly(conn, dbc);
        }else{ ///end MLA store type

            if(retrivalForFactor){
                throw new RemoteException("retrival For Factor not supported for "+storeType+" stores");
            }

            //much simpler query as we are just going to blatently send them everything as
            //the transaction are not really supported in the same way
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceDistDataAccess.INVOICE_STATUS_CD,RefCodeNames.INVOICE_STATUS_CD.CLW_ERP_PROCESSED);
            if(storeId > 0){
                dbc.addEqualTo(InvoiceDistDataAccess.STORE_ID,storeId);
            }else{
                throw new RemoteException("store id was not set");
            }
            if (tpInfo != null && !tpInfo.isProcessInvoiceCredit()) {
                dbc.addGreaterOrEqual(InvoiceDistDataAccess.SUB_TOTAL,0);
            }


            //pull out shipping information based off the existence of an invoice
            if (setType.equals(RefCodeNames.EDI_TYPE_CD.T856)) {
            	DBCriteria inCrit = new DBCriteria();
            	inCrit.addEqualTo(InvoiceDistDetailDataAccess.SHIP_STATUS_CD, RefCodeNames.SHIP_STATUS_CD.PENDING);
            	DBCriteria orCrit = new DBCriteria();
            	orCrit.addIsNull(InvoiceDistDetailDataAccess.SHIP_STATUS_CD);
            	inCrit.addOrCriteria(orCrit);
            	//dbc.addCondition(InvoiceDistDetailDataAccess.SHIP_STATUS_CD + " IS NULL or " + InvoiceDistDetailDataAccess.SHIP_STATUS_CD+" = '"+RefCodeNames.SHIP_STATUS_CD.PENDING+"'");
            	dbc.addOneOf(InvoiceDistDataAccess.INVOICE_DIST_ID, InvoiceDistDetailDataAccess.getSqlSelectIdOnly(InvoiceDistDetailDataAccess.INVOICE_DIST_ID, inCrit));
		         // do not include the credits for 856s
            	 dbc.addGreaterOrEqual(InvoiceDistDataAccess.SUB_TOTAL,0);
            }

            //if trading partner type code is a customer type than restrict to that customer
            log.info("Trading type code="+tpInfo.getTradingPartnerData().getTradingPartnerTypeCd());
            if(RefCodeNames.TRADING_PARTNER_TYPE_CD.CUSTOMER.equals(tpInfo.getTradingPartnerData().getTradingPartnerTypeCd())){
            	log.info("restricting by account id: "+busEntityId);
            	DBCriteria inCrit = new DBCriteria();
            	String ordTab = OrderDataAccess.CLW_ORDER;
            	dbc.addJoinTable(ordTab);
            	dbc.addJoinCondition(InvoiceDistDataAccess.ORDER_ID, ordTab, OrderDataAccess.ORDER_ID);
            	dbc.addJoinTableEqualTo(ordTab, OrderDataAccess.ACCOUNT_ID, busEntityId);
            }if(RefCodeNames.TRADING_PARTNER_TYPE_CD.DISTRIBUTOR.equals(tpInfo.getTradingPartnerData().getTradingPartnerTypeCd())){
            	//This may be safly removed if it causes problems.  It should most likely be reserved for future use
            	//in the event we do need to do somthing special in this case and the busniess need is just not known yet
            	//6/7/2010 - Brook
            	throw new RemoteException("Cannot send invoices or 856s to distributor trading partner type code!");
            }

            //dbc.addNotOneOf(InvoiceDistDataAccess.ORDER_ID,noCCSql);

            log.info(InvoiceDistDataAccess.getSqlSelectIdOnly("*",dbc));
            return Utility.toIdVector(InvoiceDistDataAccess.select(conn, dbc));
        }

    }

    private OrderAddressData getOrderAddress(int pOrderId, String pAddrType,
                                             Connection conn)
                                      throws RemoteException {

        try {

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(OrderAddressDataAccess.ORDER_ID, pOrderId);
            dbc.addEqualTo(OrderAddressDataAccess.ADDRESS_TYPE_CD, pAddrType);

            OrderAddressDataVector orderAddrDV = OrderAddressDataAccess.select(
                                                         conn, dbc);

            if (orderAddrDV.size() >= 1) {

                return (OrderAddressData)orderAddrDV.get(0);
            } else {

                return null;
            }
        } catch (SQLException exc) {

            String em =
                "Error. IntegrationServicesBean.getOrderAddress() SQL Exception happened. " +
                 exc.getMessage();
            log.error(em);
            throw new RemoteException(em);
        }
    }

 /**
  * Gets OrderData object
  * @param pStoreId  the store identifier. If equals 0, picks up the firs one found by pErpNum
  * @param poNum the erp po number sent to distributor. By agreement shuld be unigue, so store id does not matter
  * @return  OrderData object
  * @throws  RemoteException
  */
    public PurchaseOrderData getPurchaseOrderByPoNum(String poNum, int tradingPartnerId, String siteKey, String accountKey, String poNumType)
    throws RemoteException {
        Connection conn = null;
        try {
            conn = getConnection();
            OrderData orderD = null;

            HashMap mTradPartnerAssoc = getAPIAccess().getTradingPartnerAPI().getMapTradingPartnerAssocIds(tradingPartnerId);

            IdVector accountIds     = (IdVector) mTradPartnerAssoc.get(RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
            IdVector storeIds       = (IdVector) mTradPartnerAssoc.get(RefCodeNames.BUS_ENTITY_TYPE_CD.STORE);
            IdVector distributorIds = (IdVector) mTradPartnerAssoc.get(RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);

            int accountId = 0;
            int siteId = 0;
            PurchaseOrderData po = null;

            if(siteKey != null){
            	BusEntityDataVector sites = this.getSitesFromEntityKey(siteKey, storeIds, accountIds, tradingPartnerId, conn);
        		if(sites.size() > 1){
        			throw new Exception("multiple sites found for site key: "+siteKey);
        		}else if (sites.size() == 1){
        			siteId = ((BusEntityData)sites.get(0)).getBusEntityId();
        		}
            }

            if (accountKey != null){
            	BusEntityDataVector accounts = getAccountsFromEntityKey(accountKey, storeIds, conn);

            	if(accounts.size() > 1){
        			throw new Exception("multiple sites found for site key: "+siteKey);
        		}else if (accounts.size() == 1){
        			accountId = ((BusEntityData)accounts.get(0)).getBusEntityId();
        		}
            }

            // Look system order.
            po = getOrderByPoNum(storeIds, distributorIds,poNum,siteId,accountId, conn, poNumType);


            return po;
        } catch (Exception exc) {
            throw processException(exc);
        } finally {
            closeConnection(conn);
        }
    }

    private boolean isCorrectTradingPartnerData(Connection pConn, OrderDataVector pOrderDV, int tradingPartnerId) throws SQLException, Exception{
        DBCriteria dbc = new DBCriteria();
        IdVector ids = new IdVector();
        Set orders = new HashSet();
        Set purchaseOrders =new HashSet();
        for (int i = 0; pOrderDV != null && i < pOrderDV.size(); i++) {
            OrderData item = (OrderData) pOrderDV.get(i);
            ids.add(new Integer(item.getOrderId()));
        }
        orders.addAll(ids);
        dbc.addOneOf(PurchaseOrderDataAccess.ORDER_ID, ids);
        PurchaseOrderDataVector podv =PurchaseOrderDataAccess.select(pConn, dbc);
        dbc = new DBCriteria();
        ids = new IdVector();
        for (int i = 0; podv != null && i < podv.size(); i++) {
            PurchaseOrderData item = (PurchaseOrderData) podv.get(i);
            String distErpNum = item.getDistErpNum();
            //if (distErpNum.startsWith("#"))
            //	distErpNum = distErpNum.substring(1);
            ids.add(distErpNum);
            purchaseOrders.add(new Integer(item.getOrderId()));
        }
        if (orders.containsAll(purchaseOrders) == false) {
            throw new Exception("Not found purchase order for one of " + orders + " orders!");
        }

        DBCriteria dbc1 = new DBCriteria();
        dbc1.addOneOf(BusEntityDataAccess.ERP_NUM, ids);
        dbc1.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);

        dbc.addOneOf(TradingPartnerAssocDataAccess.BUS_ENTITY_ID, BusEntityDataAccess.getSqlSelectIdOnly(BusEntityDataAccess.BUS_ENTITY_ID, dbc1));
        dbc.addEqualTo(TradingPartnerAssocDataAccess.TRADING_PARTNER_ID, tradingPartnerId);
        IdVector ids2 = TradingPartnerAssocDataAccess.selectIdOnly(pConn, dbc);
        if (ids2 == null || ids2.size() != 1) {
            return false;
        }
        return true;
    }

    private OrderDataVector getPossibleOrders(Connection pConn, OrderDataVector pData, String pDistType) throws SQLException {
        Map distTypes = getAccountDistributorTypes(pConn, pData);
        OrderDataVector result = new OrderDataVector();
        for (int i = 0; pData != null && i < pData.size(); i++) {
            OrderData order = (OrderData) pData.get(i);
            String value = (String) distTypes.get("" + order.getAccountId());
            if (pDistType.equals(RefCodeNames.DISTR_PO_TYPE.SYSTEM)) {
                if (RefCodeNames.DISTR_PO_TYPE.REQUEST.equals(value) == false
                        && RefCodeNames.DISTR_PO_TYPE.CUSTOMER.equals(value) == false) {
                    result.add(order);
                }
            } else if (pDistType.equals(value)) {
                result.add(order);
            }
        }
        return result;
    }
    private IdVector getOrderIds(Connection conn, String pErpPoNum) throws SQLException {
        DBCriteria dbc = new DBCriteria();
        dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC, RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_PO_NUM);
        dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD, RefCodeNames.PROPERTY_TYPE_CD.CUSTOMER_PO_NUM);
        dbc.addEqualTo(OrderPropertyDataAccess.CLW_VALUE, pErpPoNum);
        OrderPropertyDataVector props = OrderPropertyDataAccess.select(conn, dbc);
        IdVector ids = new IdVector();
        for (int i = 0; i < props.size(); i++) {
        	int orderId = ((OrderPropertyData)props.get(i)).getOrderId();
        	ids.add(new Integer(orderId));
		}
        return ids;
    }

//    private OrderDataVector getOrders(Connection conn, IdVector orderIds) throws SQLException {
//        DBCriteria dbc = new DBCriteria();
//        dbc.addOneOf(OrderDataAccess.ORDER_ID, orderIds);
//        return OrderDataAccess.select(conn, dbc);
//    }

    private Map getAccountDistributorTypes(Connection mConn, OrderDataVector mOrderDV) throws SQLException{
        DBCriteria dbc = new DBCriteria();
        IdVector ids = new IdVector();
        for (int i = 0; mOrderDV != null && i < mOrderDV.size(); i++) {
            OrderData item = (OrderData) mOrderDV.get(i);
            ids.add(new Integer(item.getAccountId()));
        }
        dbc.addOneOf(PropertyDataAccess.BUS_ENTITY_ID, ids);
        dbc.addEqualTo(PropertyDataAccess.SHORT_DESC, RefCodeNames.PROPERTY_TYPE_CD.DISTR_PO_TYPE);
        dbc.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD, RefCodeNames.PROPERTY_TYPE_CD.DISTR_PO_TYPE);
        PropertyDataVector pdv = PropertyDataAccess.select(mConn, dbc);
        Map map = new HashMap();
        for (int i = 0; pdv != null && i < pdv.size(); i++) {
            PropertyData item = (PropertyData) pdv.get(i);
            map.put("" + item.getBusEntityId(), item.getValue());
        }
        return map;
    }

    public OrderData getOrderDataByPoNum(String poNum, int tradingPartnerId, String siteKey, String accountKey, String poNumType)
    throws RemoteException {
    	Connection conn = null;
        try {
        	PurchaseOrderData po = getPurchaseOrderByPoNum(poNum, tradingPartnerId, siteKey, accountKey, poNumType);
            if (po != null) {
            	conn = getConnection();
                return OrderDataAccess.select(conn, po.getOrderId());
            }
            return null;
        } catch (Exception exc) {
            throw processException(exc);
        } finally {
            closeConnection(conn);
        }
    }

    private PurchaseOrderData getOrderByPoNum(IdVector pStoreIds, IdVector pDistributorId, String pPoNum, int siteId, int accountId, Connection conn, String poNumType)
    throws Exception {
        log.info("getOrderByPoNum.");

		ArrayList distributorErpNumList = new ArrayList();
		if (pDistributorId != null && pDistributorId.size() > 0)
        {
            DBCriteria subcrit = new DBCriteria();
            subcrit.addOneOf(BusEntityDataAccess.BUS_ENTITY_ID,IdVector.toCommaString(pDistributorId));
            BusEntityDataVector distV = BusEntityDataAccess.select(conn,subcrit);
            if (null != distV){
                Iterator dit = distV.iterator();
                while(dit.hasNext()){
                    BusEntityData distD = (BusEntityData)dit.next();
                    if(Utility.isSet(distD.getErpNum())){
                    	distributorErpNumList.add(distD.getErpNum().toUpperCase());
                    }
                }
            }
        }
		Map<Integer, String> insertionStringMap = new HashMap<Integer, String>();
		int insertionStringIndex = 1;
		StringBuilder sql = new StringBuilder(250);
		if (poNumType.equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.VENDOR_ORDER_NUM)){
			sql.append("select purchase_order_id from clw_order o, clw_purchase_order po ");
			sql.append("where o.order_id = po.order_id and o.ref_order_num = ? ");
			insertionStringMap.put(new Integer(insertionStringIndex++), pPoNum);
		}else if (poNumType.equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.STORE_ERP_PO_NUM)){
			sql.append("select po.purchase_order_id from clw_order o, clw_purchase_order po ");
			sql.append("where po.order_Id = o.order_id and po.erp_po_num = ? ");
			insertionStringMap.put(new Integer(insertionStringIndex++), pPoNum);
		}else{
			String poNum1 = (pPoNum.startsWith("#")) ? pPoNum.substring(1) : "#"+pPoNum;
			sql.append("select po.purchase_order_id from clw_purchase_order po, clw_order o ");
			sql.append("where po.order_Id = o.order_id and (po.OUTBOUND_PO_NUM = ? or po.OUTBOUND_PO_NUM = ? )");
			insertionStringMap.put(new Integer(insertionStringIndex++), poNum1);
			insertionStringMap.put(new Integer(insertionStringIndex++), pPoNum);
		}

		if (siteId > 0) {
			sql.append(" and o.site_id = ?");
			insertionStringMap.put(new Integer(insertionStringIndex++), siteId + "");
		}

		if (accountId > 0) {
			sql.append(" and o.account_id = ?");
			insertionStringMap.put(new Integer(insertionStringIndex++), accountId + "");
		}

		//add dist erp numbers
		if(distributorErpNumList.size() >0) {
        	sql.append(" and po.");
        	sql.append(PurchaseOrderDataAccess.DIST_ERP_NUM);
        	sql.append(" IN ");
        	sql.append(Utility.makeParameterList(distributorErpNumList.size()));
            Iterator erpIterator = distributorErpNumList.iterator();
            while (erpIterator.hasNext()) {
    			insertionStringMap.put(new Integer(insertionStringIndex++), (String)erpIterator.next());
        	}
        }

		//add store ids
		if (null != pStoreIds && pStoreIds.size() > 0) {
			sql.append(" and o.store_id in ");
        	sql.append(Utility.makeParameterList(pStoreIds.size()));
            Iterator storeIterator = pStoreIds.iterator();
            while (storeIterator.hasNext()) {
    			insertionStringMap.put(new Integer(insertionStringIndex++), storeIterator.next() + "");
        	}
		}
		sql.append(" order by po.po_date desc");

		log.info(sql.toString());

		ResultSet rs = null;
        PreparedStatement stmt = conn.prepareStatement(sql.toString());
		//Bind parameters to values according to key in map
        Iterator keyIterator = insertionStringMap.keySet().iterator();
        while (keyIterator.hasNext()) {
        	Integer key = (Integer)keyIterator.next();
            stmt.setString(key.intValue(), (String)insertionStringMap.get(key));
        }

		try{
			rs = stmt.executeQuery();
			if(rs.next()){
				int purchaseOrderId = rs.getInt("PURCHASE_ORDER_ID");
				log.info("Found purchase order id: "+purchaseOrderId);
				//when matching by the default po number rules FOR NOW need to decide what to do for post Caneel Bay release.
				if(!poNumType.equals(RefCodeNames.MATCH_PO_NUM_TYPE_CD.DEFAULT)){
					if (rs.next()){
						throw new RemoteException("Multiple purchase order found for erp_po_num:" + pPoNum + ", store_id:"
								+ IdVector.toCommaString(pStoreIds) + ", poNumType=" + poNumType);
					}
				}

				return PurchaseOrderDataAccess.select(conn, purchaseOrderId);
			}
		}finally{
			if(rs!=null){rs.close();}
			if(stmt!=null){stmt.close();}
		}

		return null;
    }

    public OrderData getOrderByPONum(String pCustPoNum) throws RemoteException {
    	OrderData oData = OrderData.createValue();
        Connection conn = null;
        try {
            conn = getConnection();
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(PurchaseOrderDataAccess.OUTBOUND_PO_NUM, pCustPoNum);
            PurchaseOrderDataVector poDV = PurchaseOrderDataAccess.select(conn, dbc);

            if(poDV!=null && poDV.size()>0){
            	PurchaseOrderData poD = (PurchaseOrderData)poDV.get(0);
            	int oId = poD.getOrderId();

            	oData = OrderDataAccess.select(conn, oId);
            }
        } catch (Exception exc) {
            log.error(exc);
            throw new RemoteException(exc.getMessage());
        } finally {
            closeConnection(conn);
        }
        return oData;

    }

    private OrderItemDataVector getOrderItemsByPoIdOrderId(int pOrderId,int pPoId, Connection conn) throws RemoteException {
		try {

			DBCriteria dbc = new DBCriteria();
			dbc.addEqualTo(OrderItemDataAccess.PURCHASE_ORDER_ID, pPoId);
			dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, pOrderId);//should be unnecessary
			return (OrderItemDataAccess.select(conn, dbc));
		} catch (SQLException exc) {
			String em = "Error. IntegrationServicesBean.getOrderItemsByPoIdOrderId() SQL Exception happened. "+ exc.getMessage();
			log.error(em);
			throw new RemoteException(em);
		}
	}

    private OrderItemDataVector getOrderItemsByOrderId(int pOrderId,Connection conn) throws RemoteException {
		try {
			DBCriteria dbc = new DBCriteria();
			dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, pOrderId);//should be unnecessary
			return (OrderItemDataAccess.select(conn, dbc));
		} catch (SQLException exc) {
			String em = "Error. IntegrationServicesBean.getOrderItemsByOrderId() SQL Exception happened. "+ exc.getMessage();
			log.error(em);
			throw new RemoteException(em);
		}
	}

    private boolean ExistingVendorOrderFound(int pOrderId,
                                             String pVendorOrderNum,
                                             Connection con)
                                      throws RemoteException {

        DBCriteria dbc;
	if(pVendorOrderNum == null || pVendorOrderNum.trim().length() == 0){
		return false;
	}

        try {
            dbc = new DBCriteria();
            dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID, pOrderId);
            dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD,
                           RefCodeNames.ORDER_PROPERTY_TYPE_CD.VENDOR_ORDER_NUMBER);
            dbc.addEqualTo(OrderPropertyDataAccess.CLW_VALUE, pVendorOrderNum);

            OrderPropertyDataVector orderPropertyDV = OrderPropertyDataAccess.select(
                                                              con, dbc);

            return (orderPropertyDV.size() >= 1);
        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. ExistingVendorOrderFound) SQL Exception happened. " +
                                      exc.getMessage());
        }
    }




    /**
     *Returns a list of all invoices that match the invoice number and po number passed in.  This takes
     *into account the distributor invoice number property, so if that prop is set to:
     * "*_UOM" and the passed in invoice num is ABC it will find invoice ABC, and ABC_UOM1 etc etc.
     */
    private InvoiceDistDataVector existingInvoiceFound(String pInvoiceNum, String pErpPoNum, int pStoreId,
    Connection con, List insertedInvoices)throws RemoteException {
        DistributorInvoiceNumTool distInvNumTool = new DistributorInvoiceNumTool();
        DistributorInvoiceNumTool.DistInvoiceModifierDefinition
         def = distInvNumTool.getDistInvoiceNumDef(con);
        boolean postfix = def.isPostfix();
        DBCriteria dbc;


        //strip requested invoice number of any modifier information
        pInvoiceNum = distInvNumTool.splitDistInvoiceIntoSuspectedParts(pInvoiceNum, def).getInvoiceBase();

        try {
            dbc = new DBCriteria();
            dbc.addNotEqualTo(InvoiceDistDataAccess.INVOICE_STATUS_CD,RefCodeNames.INVOICE_STATUS_CD.DUPLICATE);
            if(postfix){
                dbc.addLike(InvoiceDistDataAccess.INVOICE_NUM, pInvoiceNum + "%");
            }else{
                dbc.addLike("%" + InvoiceDistDataAccess.INVOICE_NUM, pInvoiceNum);
            }
            if(pStoreId > 0) {
                dbc.addEqualTo(InvoiceDistDataAccess.STORE_ID, pStoreId);
            }
            dbc.addLike(InvoiceDistDataAccess.ERP_PO_NUM, pErpPoNum + "%");
            InvoiceDistDataVector invoiceDV = InvoiceDistDataAccess.select(con,dbc);
            Iterator it = invoiceDV.iterator();
            while(it.hasNext()){
                InvoiceDistData idd = (InvoiceDistData) it.next();
                String checkInvoice = distInvNumTool.splitDistInvoiceIntoSuspectedParts(pInvoiceNum, def).getInvoiceBase();
                log.debug("Checking for duplicate: "+checkInvoice);
                boolean isKnown = false;
                Iterator it2 = insertedInvoices.iterator();
                while(it2.hasNext()){
                    InvoiceDistData idd2 = (InvoiceDistData) it2.next();
                    if(idd2.getInvoiceDistId() == idd.getInvoiceDistId()){
                        isKnown = true;
                        break;
                    }
                }

                if(isKnown){
                    it.remove();
                    continue;
                }
                if(checkInvoice.equals(pInvoiceNum)){
                    continue;
                }else{
                    it.remove();
                }
            }
            return invoiceDV;
        } catch (SQLException exc) {
            exc.printStackTrace();
            throw new RemoteException("Error. ExistingInvoiceFound) SQL Exception happened. " + exc.getMessage());
        }
    }

    private OrderItemDataVector getOrderItemByPoLineNumberAndSku(int poLineNumber,
                                                                 int cwSku,
                                                                 String vendorSku,
                                                                 OrderItemDataVector poItems) {

        OrderItemDataVector matchItems = new OrderItemDataVector();

        for (int i = 0; i < poItems.size(); i++) {

            OrderItemData itemD = (OrderItemData)poItems.get(i);

            if(poLineNumber != 0){
                if (poLineNumber == itemD.getErpPoLineNum() &&
                    (cwSku == itemD.getItemSkuNum() ||
                        Utility.stringMatch(vendorSku, itemD.getDistItemSkuNum(),0))) {
                    matchItems.add(itemD);
                }
            //if the erp po line is not supplied then rely on the sku data...This leads to
            //potentially more multiple matches but that is handled elsewhere.
            }else if(cwSku == itemD.getItemSkuNum() || Utility.stringMatch(vendorSku, itemD.getDistItemSkuNum(),0)) {
                    matchItems.add(itemD);
            }
        }

        return matchItems;
    }

    private OrderItemDataVector getOrderItemByPoLineNumber(int poLineNumber,
                                                           OrderItemDataVector poItems) {

        OrderItemDataVector matchItems = new OrderItemDataVector();

        for (int i = 0; i < poItems.size(); i++) {

            OrderItemData itemD = (OrderItemData)poItems.get(i);

            if (poLineNumber == itemD.getErpPoLineNum()) {
                matchItems.add(itemD);
            }
        }

        return matchItems;
    }

    private OrderItemDataVector getOrderItemBySku(int cwSku, String vendorSku,
                                                  OrderItemDataVector poItems) {

        OrderItemDataVector matchItems = new OrderItemDataVector();

        for (int i = 0; i < poItems.size(); i++) {

            OrderItemData itemD = (OrderItemData)poItems.get(i);

            if (cwSku == itemD.getItemSkuNum() ||
                Utility.stringMatch(vendorSku, itemD.getDistItemSkuNum(), 0)) {
                matchItems.add(itemD);
            }
        }

        return matchItems;
    }

    private boolean isApprovedSubWithItem(int contractId, int itemId,
                                          int cwSku, String vendorSku,
                                          Connection conn,Map paramMap)
                                   throws RemoteException {

        DBCriteria dbc;
        try {
            if (cwSku > 0) {
                String key = "mapToItemId" + cwSku + "::" + RefCodeNames.SKU_TYPE_CD.CLW;
                Integer cachedSubItemId = (Integer) paramMap.get(key);
                int subItemId;
                log.debug("key::"+key);
                if(cachedSubItemId == null){
                    log.debug("no cache found");
                    cachedSubItemId = new Integer(ItemSkuMapping.mapToItemId(conn, new String("" + cwSku), RefCodeNames.SKU_TYPE_CD.CLW, 0));
                    paramMap.put(key, cachedSubItemId);
                }
                subItemId = cachedSubItemId.intValue();

                if (subItemId > 0) {
                    dbc = new DBCriteria();
                    dbc.addEqualTo(ContractItemSubstDataAccess.ITEM_ID, itemId);
                    dbc.addEqualTo(ContractItemSubstDataAccess.SUBST_STATUS_CD,
                                   RefCodeNames.SUBST_STATUS_CD.ACTIVE);
                    key = ContractItemSubstDataAccess.getSqlSelectIdOnly("", dbc);
                    log.debug("key2::"+key);
                    ContractItemSubstDataVector itemSubs = (ContractItemSubstDataVector) paramMap.get(key);
                    if(itemSubs == null){
                        log.debug("no cache found2");
                        itemSubs = ContractItemSubstDataAccess.select(conn, dbc);
                        paramMap.put(key,itemSubs);
                    }

                    for (int i = 0; i < itemSubs.size(); i++) {
                        ContractItemSubstData itemSub=(ContractItemSubstData)itemSubs.get(i);
                        if (itemSub.getSubstItemId() == subItemId) {
                            return true;
                        }
                    }
                }
            }

            if (Utility.isSet(vendorSku)) {
                String key = "mapToItemId" + cwSku + "::" + RefCodeNames.SKU_TYPE_CD.DISTRIBUTOR;
                Integer cachedSubItemId = (Integer) paramMap.get(key);
                int subItemId;
                if(cachedSubItemId == null){
                    cachedSubItemId = new Integer(ItemSkuMapping.mapToItemId(conn, new String("" + cwSku), RefCodeNames.SKU_TYPE_CD.DISTRIBUTOR, 0));
                    paramMap.put(key, cachedSubItemId);
                }
                subItemId = cachedSubItemId.intValue();

                if (subItemId > 0) {
                    dbc = new DBCriteria();
                    dbc.addEqualTo(ContractItemSubstDataAccess.ITEM_ID, itemId);
                    dbc.addEqualTo(ContractItemSubstDataAccess.SUBST_STATUS_CD,
                                   RefCodeNames.SUBST_STATUS_CD.ACTIVE);
                    key = ContractItemSubstDataAccess.getSqlSelectIdOnly("",dbc);
                    ContractItemSubstDataVector itemSubs = (ContractItemSubstDataVector) paramMap.get(key);
                    if(itemSubs == null){
                        itemSubs = ContractItemSubstDataAccess.select(conn, dbc);
                        paramMap.put(key,itemSubs);
                    }
                    for (int i = 0; i < itemSubs.size(); i++) {
                        ContractItemSubstData itemSub=(ContractItemSubstData)itemSubs.get(i);
                        if (itemSub.getSubstItemId() == subItemId) {
                            return true;
                        }
                    }
                }
            }
        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. isApprovedSubWithItem) SQL Exception happened. " +
                                      exc.getMessage());
        }
         catch (Exception exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. isApprovedSubWithItem() Exception happened. " +
                                      exc.getMessage());
        }
        return false;
    }

    private OrderItemDataVector getApprovedSubstitutionItems(int contractId,
                                                             OrderItemDataVector poItems,
                                                             int cwSku,
                                                             String vendorSku,
                                                             Connection conn,
                                                             Map paramMap)
                                                      throws RemoteException {

        OrderItemDataVector itemDV = new OrderItemDataVector();
        for (int i = 0; i < poItems.size(); i++) {
            OrderItemData itemD = (OrderItemData)poItems.get(i);
            if (isApprovedSubWithItem(contractId, itemD.getItemId(), cwSku, vendorSku, conn,paramMap)) {
                itemDV.add(itemD);
            }
        }
        return itemDV;
    }

    private String getOriginalDateOrdered(int pOrderId, Connection pConn)
                                   throws RemoteException {

        try {

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID, pOrderId);
            dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD,
                           RefCodeNames.ORDER_PROPERTY_TYPE_CD.CUSTOMER_ORDER_DATE);

            OrderPropertyDataVector orderPropertyDV = OrderPropertyDataAccess.select(
                                                              pConn, dbc);

            if (orderPropertyDV.size() >= 1) {

                return (((OrderPropertyData)orderPropertyDV.get(0)).getValue());
            } else {

                return "";
            }
        } catch (SQLException exc) {

            String em =
                "Error. IntegrationServicesBean.getOriginalDateOrdered() SQL Exception happened. " +
                 exc.getMessage();
            log.error(em);
            throw new RemoteException(em);
        }
    }


    private String getCustomerBillingUnit(int pOrderId, Connection pConn)throws SQLException {
        DBCriteria dbc = new DBCriteria();
        dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID, pOrderId);
        dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD, RefCodeNames.ORDER_PROPERTY_TYPE_CD.CUSTOMER_BILLING_UNIT);
        dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_STATUS_CD, RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
        OrderPropertyDataVector orderPropertyDV = OrderPropertyDataAccess.select(pConn, dbc);
        if (orderPropertyDV.size() >= 1) {
            return (((OrderPropertyData)orderPropertyDV.get(0)).getValue());
        } else {
            return "";
        }
    }

    // get a list of distributor invoice related to order id: pOrderId
    private InvoiceDistData getInvoiceDistByOrderId(int pOrderId,
                                                    Connection pConn)
                                             throws RemoteException {

        try {

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceDistDataAccess.ORDER_ID, pOrderId);

            InvoiceDistDataVector invoiceDistDV = InvoiceDistDataAccess.select(
                                                          pConn, dbc);

            if (invoiceDistDV.size() >= 1)

                return (InvoiceDistData)invoiceDistDV.get(0);
            else

                return null;
        } catch (SQLException exc) {

            String em =
                "Error. IntegrationServicesBean.getInvoiceDistByOrderId() SQL Exception happened. " +
                 exc.getMessage();
            log.error(em);
            throw new RemoteException(em);
        }
    }

    private TradingPartnerInfo getTradingPartnerInfo(int partnerId, Map paramMap)
                                              throws Exception {
        String key = TradingPartnerInfo.class.getName()+partnerId;
        if(paramMap != null){
            TradingPartnerInfo tpi = (TradingPartnerInfo)
                paramMap.get(key);
            if(tpi != null){
                return tpi;
            }
        }
        APIAccess factory = getAPIAccess();
        TradingPartner tradingPartnerEjb = factory.getTradingPartnerAPI();
        TradingPartnerInfo tpInfo = tradingPartnerEjb.getTradingPartnerInfo(
                                            partnerId);
        if(paramMap != null){
            paramMap.put(key,tpInfo);
        }
        return tpInfo;
    }




    // Get a list of supported EDI Transaction supported by trading partner that
    // trading partner id = partnerId
    private ArrayList getEDITypeSupportedByPartner(int partnerId,
                                                   Connection conn)
                                            throws RemoteException {

        try {

            // get list of trading profile id that has trading partner id = partnerId
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(TradingProfileDataAccess.TRADING_PARTNER_ID, partnerId);

            IdVector profileIds = TradingProfileDataAccess.selectIdOnly(conn,
                                                                        TradingProfileDataAccess.TRADING_PROFILE_ID,
                                                                        dbc);
            log.debug("X17 profileIds: " + profileIds);

            // get a list of EDI transaction set type supported by partner = partnerId
            dbc = new DBCriteria();
            dbc.addOneOf(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, profileIds);

            TradingProfileConfigDataVector profileConfigDV =
                    TradingProfileConfigDataAccess.select(conn, dbc);
            ArrayList setTypes = new ArrayList();

            for (int i = 0; i < profileConfigDV.size(); i++) {
                setTypes.add(((TradingProfileConfigData)(profileConfigDV.get(i))).getSetType());
            }

            log.debug("X18: suported EDI set type: " + setTypes);

            return setTypes;
        } catch (SQLException exc) {

            String em =
                "Error. IntegrationServicesBean.getEDITypeSupportedByPartnerId() SQL Exception happened. " +
                 exc.getMessage();
            log.error(em);
            throw new RemoteException(em);
        }
    }

    static DistributorHome mDistributorHome;

    /**
     *Get all of the TradingPartners that have trading partners with a supplied tradingType
     *asociated with a given transaction type.  The EDI codes are used as the convention for
     *EDI and non EDI trading partners (850 = purchase order, 810 = invoice etc).
     */
    public List getOutboundBusEntityByTradingType(String tradingType,
                                                  String entityType)
                                           throws RemoteException {

        Connection conn = null;
        DBCriteria dbc;

        try {
            conn = getConnection();
            dbc = new DBCriteria();
            dbc.addEqualTo(TradingPartnerDataAccess.TRADING_PARTNER_TYPE_CD,
                           entityType);
            dbc.addEqualTo(TradingPartnerDataAccess.TRADING_TYPE_CD,
                           tradingType);
            dbc.addNotEqualTo(
                    TradingPartnerDataAccess.TRADING_PARTNER_STATUS_CD,
                    RefCodeNames.TRADING_PARTNER_STATUS_CD.INACTIVE);

            //first get all of the trading partners, then go and fetch the buisness entities
            TradingPartnerDataVector partners = TradingPartnerDataAccess.select(
                                                        conn, dbc);

            if (partners.size() == 0) {
                log.error("No Bus entity found for entityType = " +entityType + " and tradingType = " + tradingType);

                return null;
            }

            log.info("found: " + partners.size() +" trading partners with a trading type of " +tradingType);

            // Get a reference to the Integration Services Bean
            APIAccess factory = null;
            TradingPartner tradingPartnerEjb = null;

            try {
                factory = getAPIAccess();
                tradingPartnerEjb = factory.getTradingPartnerAPI();
            } catch (NamingException e) {
                log.error("Could not locate trading partner Nameing exception");
                throw e;
            }
             catch (APIServiceAccessException e) {
                log.error("Could not locate trading partner APIServiceAccessException exception");
                throw new RemoteException("Error. IntegrationServicesBean.getOutboundBusEntityByTradingType() APIServiceAccessException Exception happened. " +
                                          e.getMessage());
            }

            ArrayList tradParts = new ArrayList();

            for (int i = 0, len = partners.size(); i < len; i++) {

                TradingPartnerData partner = (TradingPartnerData)partners.get(
                                                     i);
                TradingPartnerInfo tpi = tradingPartnerEjb.getTradingPartnerInfo(partner.getTradingPartnerId());
                log.debug("fax number: " +tpi.getPurchaseOrderFaxNumber().getPhoneNum());
                tradParts.add(tpi);
            }

            return tradParts;
        } catch (NamingException e) {
            log.error(e.getMessage());
            e.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getOutboundBusEntityByTradingType() Nameing Exception happened. " +
                                      e.getMessage());
        }
         catch (SQLException e) {
            log.error(e.getMessage());
            e.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getOutboundBusEntityByTradingType() SQL Exception happened. " +
                                      e.getMessage());
        }
         catch (DataNotFoundException e) {
            log.error(e.getMessage());
            e.printStackTrace();
            throw new RemoteException("Error. IntegrationServicesBean.getOutboundBusEntityByTradingType() DataNotFoundException happened. " +
                                      e.getMessage());
        } finally {

        	closeConnection(conn);
        }
    }

    private ProcessOrderResultData p_checkOrderRequest(int pOrderId) {

        ProcessOrderResultData res = ProcessOrderResultData.createValue();
        res.setOKFlag(false);
        res.setOrderId(pOrderId);
	res.setOrderStatusCd
	    (RefCodeNames.ORDER_STATUS_CD.PENDING_REVIEW);
        Connection conn = null;

        // Find the order.
        try {
            conn = getConnection();

            OrderData od = OrderDataAccess.select(conn, pOrderId);
            res.setOrderDate(od.getOriginalOrderDate());
            res.setOrderStatusCd(od.getOrderStatusCd());
            res.setOrderNum(od.getOrderNum());

            if(RefCodeNames.ORDER_SOURCE_CD.EDI_850.equals(od.getOrderSourceCd())){
                if(duplicateOrder(od.getAccountErpNum(), od.getRequestPoNum(), od.getOrderSiteName(), conn, true)){
                    res.addResponseMsg("Duplicate EDI Order");
                    return res;
                }
            }

            // Check the site information.
            String siteName = od.getOrderSiteName();

            if (siteName == null || siteName.length() == 0) {
                res.addResponseMsg("No site name in the order.");

                return res;
            }

            int aid = od.getAccountId();
            //SiteData sD = getSite(od.getSiteId());

            //if (null == sD) {
            //    res.addResponseMsg("No site found for site name: " + siteName);
            //    return res;
            //}

            res.setSiteId(od.getSiteId());
            res.setAccountId(aid);

            // Check the account information.
            AccountBean acct = new AccountBean();
            int accountId = acct.getAccountIdForSiteLocal(conn,od.getSiteId());

            if (accountId!=od.getAccountId()) {
                res.addResponseMsg(
                        "This order was purchase with account: " +
                        od.getAccountId() +
                        " but the site is set up for account: " +
                        accountId);

                return res;
            }

            // Check the items.  At this point we have to make sure that the
            // items in the order exist in the the master catalog and that
            // each of the items has a distributor sku as well.
            ArrayList itemsResultMsgs = checkOrderItems(conn, pOrderId);

            if (itemsResultMsgs.size() > 0) {

                for (int mi = 0; mi < itemsResultMsgs.size(); mi++) {
                    res.addResponseMsg((String)itemsResultMsgs.get(mi));
                }

                log.debug("failed checkOrderItems 451");
                res.setOKFlag(false);

                return res;
            }

            res.setOKFlag(true);

            return res;
        } catch (SQLException e) {
            e.printStackTrace();
            String msg = "p_checkOrderRequest: sql error: " + e;
            log.error(msg);

            return res;
        }
         catch (Exception e) {

            String msg = "p_checkOrderRequest: error: " + e;
            log.error(msg);

            return res;
        } finally {

        	closeConnection(conn);
        }
    }

    public ProcessOrderResultData checkOrderRequest(int pOrderId)
                                             throws RemoteException {

        return p_checkOrderRequest(pOrderId);
    }

    public ProcessOrderResultData cancelOrderRequest(int pOrderId,
                                                     String pUser)
                                              throws RemoteException {
        log.debug("--- cancelOrderRequest");

        ProcessOrderResultData cancelRes = ProcessOrderResultData.createValue();
        cancelRes.setOKFlag(false);

        OrderBean ob = new OrderBean();
        Connection conn = null;

        try {
            conn = getConnection();

            OrderData orderD = OrderDataAccess.select(conn, pOrderId);
            String previousStatus = orderD.getOrderStatusCd();
            ob.updateOrderInfo(pOrderId,
                               RefCodeNames.ORDER_STATUS_CD.CANCELLED, pUser);

            String note = "The order was cancelled (status was " +
                          previousStatus + "): " + new Date();
            OrderDAO.enterOrderProperty(conn,
                               RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE,
                               "OrderCancelled", note, pOrderId, 0, 0, 0, 0, 0,
                               0, pUser);
            cancelRes.setOKFlag(true);
            cancelRes.addResponseMsg(note);
        } catch (Exception e) {

            String msg = "Cancel failed for order id: " + pOrderId;
            log.error(" 95.1  " + msg + "\n error: " + e);
            cancelRes.addResponseMsg(msg);
            throw new RemoteException(msg);
        } finally {

            try {

            	closeConnection(conn);
            } catch (Exception e) {
                throw new RemoteException(e.getMessage());
            }
        }

        return cancelRes;
    }

    public ProcessInvoiceResponseData checkDistInvoice(int pDistInvoiceId)
                                                throws RemoteException {
        log.debug("--- checkDistInvoice " + pDistInvoiceId);

        ProcessInvoiceResponseData res = ProcessInvoiceResponseData.createValue();
        res.setOKFlag(false);

        Connection conn = null;

        try {
            conn = getConnection();

            // Lookup the distributor invoice.
            InvoiceDistData idd = InvoiceDistDataAccess.select(conn,
                                                               pDistInvoiceId);
            String lponumv = idd.getErpPoNum();

            if (lponumv == null || lponumv.length() == 0) {

                String msg = "checkDistInvoice: error: " +
                             "no ERP PO number (ERP_PO_NUM) " +
                             "for invoice id: " + pDistInvoiceId;
                log.error(msg);
                res.addResponseMsg(msg);

                return res;
            }

            // Check all the items.
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceDistDetailDataAccess.INVOICE_DIST_ID,
                           pDistInvoiceId);

            InvoiceDistDetailDataVector idddv = InvoiceDistDetailDataAccess.select(
                                                        conn, dbc);

            if (idddv.size() <= 0) {

                String msg = "checkDistInvoice: error: " +
                             "no distributor invoice detail " +
                             "entries found for id: " + pDistInvoiceId;
                log.error(msg);
                res.addResponseMsg(msg);

                return res;
            }

            // Check all the item entries.
            for (int i = 0; i < idddv.size(); i++) {

                InvoiceDistDetailData det = (InvoiceDistDetailData)idddv.get(i);
                String v = det.getDistItemSkuNum();

                if (v == null || v.length() == 0) {

                    String msg = "checkDistInvoice: error: " +
                                 "no distributor sku (DIST_ITEM_SKU_NUM) " +
                                 "for invoice id: " + pDistInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceDistDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }

                v = det.getDistItemUom();

                if (v == null || v.length() == 0) {

                    String msg = "checkDistInvoice: error: " +
                                 "no distributor UOM (DIST_ITEM_UOM) " +
                                 "for invoice id: " + pDistInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceDistDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }

                v = det.getItemUom();

                if (v == null || v.length() == 0) {

                    String msg = "checkDistInvoice: error: " +
                                 "no item UOM (ITEM_UOM) " +
                                 "for invoice id: " + pDistInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceDistDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }

                int ival = det.getItemSkuNum();

                if (ival <= 0) {

                    String msg = "checkDistInvoice: error: " +
                                 "no item SKU (ITEM_SKU_NUM) " +
                                 "for invoice id: " + pDistInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceDistDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }
            }
        } catch (SQLException e) {

            String msg = "checkDistInvoice: sql error: " + e;
            log.error(msg);

            return res;
        }
         catch (Exception e) {

            String msg = "checkDistInvoice: error: " + e;
            log.error(msg);

            return res;
        } finally {

            try {

            	closeConnection(conn);
            } catch (Exception e) {
            }
        }

        res.setOKFlag(true);

        return res;
    }

    public ProcessInvoiceResponseData reprocessDistInvoice(int pDistInvoiceId)
                                                    throws RemoteException {
        log.debug("--- reprocessDistInvoice: " + pDistInvoiceId);

        ProcessInvoiceResponseData res = checkDistInvoice(pDistInvoiceId);

        if (res.isOK()) {

            Connection conn = null;

            try {
                conn = getConnection();

                // Set the Invoice status to DIST_SHIPPED
                InvoiceDistData idd = InvoiceDistDataAccess.select(conn,
                                                                   pDistInvoiceId);
                idd.setInvoiceStatusCd(
                        RefCodeNames.INVOICE_STATUS_CD.DIST_SHIPPED);
                InvoiceDistDataAccess.update(conn, idd);
            } catch (SQLException e) {

                String msg = "reprocessDistInvoice: sql error: " + e;
                log.error(msg);
                res.setOKFlag(false);

                return res;
            }
             catch (Exception e) {

                String msg = "reprocessDistInvoice: error: " + e;
                log.error(msg);
                res.setOKFlag(false);

                return res;
            } finally {

                try {

                	closeConnection(conn);
                } catch (Exception e) {
                }
            }
        }

        log.debug("--- END: reprocessDistInvoice: " + pDistInvoiceId);

        return res;
    }

    public ProcessInvoiceResponseData checkCustInvoice(int pCustInvoiceId)
                                                throws RemoteException {
        log.debug("--- checkCustInvoice: " + pCustInvoiceId);

        ProcessInvoiceResponseData res = ProcessInvoiceResponseData.createValue();
        res.setOKFlag(false);

        Connection conn = null;

        try {
            conn = getConnection();

            // Check all the items.
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(InvoiceCustDetailDataAccess.INVOICE_CUST_ID,
                           pCustInvoiceId);

            InvoiceCustDetailDataVector icddv = InvoiceCustDetailDataAccess.select(
                                                        conn, dbc);

            if (icddv.size() <= 0) {

                String msg = "checkCustInvoice: error: " +
                             "no customer invoice detail " +
                             "entries found for id: " + pCustInvoiceId;
                log.error(msg);
                res.addResponseMsg(msg);

                return res;
            }

            for (int i = 0; i < icddv.size(); i++) {

                InvoiceCustDetailData det = (InvoiceCustDetailData)icddv.get(i);
                String v = det.getItemUom();

                if (v == null || v.length() == 0) {

                    String msg = "checkCustInvoice: error: " +
                                 "no item UOM (ITEM_UOM) " +
                                 "for invoice id: " + pCustInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceCustDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }

                int ival = det.getItemSkuNum();

                if (ival <= 0) {

                    String msg = "checkCustInvoice: error: " +
                                 "no item SKU (ITEM_SKU_NUM) " +
                                 "for invoice id: " + pCustInvoiceId +
                                 "\ninvoice detail id: " +
                                 det.getInvoiceCustDetailId();
                    log.error(msg);
                    res.addResponseMsg(msg);

                    return res;
                }
            }
        } catch (SQLException e) {

            String msg = "checkCustInvoice: sql error: " + e;
            log.error(msg);

            return res;
        }
         catch (Exception e) {

            String msg = "checkCustInvoice: error: " + e;
            log.error(msg);

            return res;
        } finally {

        	closeConnection(conn);
        }

        res.setOKFlag(true);

        return res;
    }

    public ProcessInvoiceResponseData reprocessCustInvoice(InvoiceCustData pCustInvoice)
                                                    throws RemoteException {
        log.debug("--- reprocessCustInvoice: " +pCustInvoice.getInvoiceCustId());

        ProcessInvoiceResponseData res = checkCustInvoice(pCustInvoice.getInvoiceCustId());

        if (res.isOK()) {

            Connection conn = null;

            try {
                conn = getConnection();

                if (RefCodeNames.INVOICE_STATUS_CD.ERP_RELEASED_ERROR.equals(pCustInvoice.getInvoiceStatusCd())) {
                    pCustInvoice.setInvoiceStatusCd(
                            RefCodeNames.INVOICE_STATUS_CD.ERP_RELEASED);
                    InvoiceCustDataAccess.update(conn, pCustInvoice);
                } else if (RefCodeNames.INVOICE_STATUS_CD.ERP_GENERATED_ERROR.equals(pCustInvoice.getInvoiceStatusCd())) {
                    pCustInvoice.setInvoiceStatusCd(
                            RefCodeNames.INVOICE_STATUS_CD.ERP_GENERATED);
                    InvoiceCustDataAccess.update(conn, pCustInvoice);
                } else if (RefCodeNames.INVOICE_STATUS_CD.CUST_INVOICED_FAILED.equals(pCustInvoice.getInvoiceStatusCd())) {
                    pCustInvoice.setInvoiceStatusCd(
                            RefCodeNames.INVOICE_STATUS_CD.ERP_RELEASED);
                    InvoiceCustDataAccess.update(conn, pCustInvoice);
                } else if (RefCodeNames.CIT_STATUS_CD.FAILED.equals(pCustInvoice.getCitStatusCd()) ||
                           RefCodeNames.CIT_STATUS_CD.REJECTED.equals(pCustInvoice.getCitStatusCd())) {
                    pCustInvoice.setCitStatusCd(
                            RefCodeNames.CIT_STATUS_CD.PENDING);
                    InvoiceCustDataAccess.update(conn, pCustInvoice);
                } else {

                    DBCriteria dbc = new DBCriteria();
                    dbc.addEqualTo(InvoiceCustDataAccess.INVOICE_CUST_ID,
                                   pCustInvoice.getInvoiceCustId());

                    InvoiceCustDetailDataVector icddv = InvoiceCustDetailDataAccess.select(
                                                                conn, dbc);

                    for (int i = 0; i < icddv.size(); i++) {

                        InvoiceCustDetailData icdd = (InvoiceCustDetailData)icddv.get(
                                                             i);

                        // Now update the statuses in the invoice
                        // customer detail entries.
                        if (RefCodeNames.SHIP_STATUS_CD.FAILED.equals(icdd.getShipStatusCd())) {
                            icdd.setShipStatusCd(
                                    RefCodeNames.SHIP_STATUS_CD.PENDING);
                            InvoiceCustDetailDataAccess.update(conn, icdd);
                        }
                    }
                }
            } catch (SQLException e) {

                String msg = "reprocessCustInvoice: sql error: " + e;
                log.error(msg);
                res.setOKFlag(false);

                return res;
            }
             catch (Exception e) {

                String msg = "reprocessCustInvoice: error: " + e;
                log.error(msg);
                res.setOKFlag(false);

                return res;
            } finally {

            	closeConnection(conn);
            }
        }

        log.debug("--- END: reprocessCustInvoice: " +pCustInvoice.getInvoiceCustId());

        return res;
    }

    private ArrayList checkOrderItems(Connection pConn, int pOrderId)
                               throws SQLException {

        ArrayList msgs = new ArrayList();
        String sql = " select  " + OrderItemDataAccess.ITEM_ID + " , " +
                     OrderItemDataAccess.ITEM_SKU_NUM + " , " +
                     OrderItemDataAccess.DIST_ITEM_SKU_NUM + " , " +
                     OrderItemDataAccess.DIST_ITEM_UOM + " , " +
                     OrderItemDataAccess.DIST_ITEM_PACK + " , " +
                     OrderItemDataAccess.DIST_ITEM_COST + " from " +
                     OrderItemDataAccess.CLW_ORDER_ITEM + " where " +
                     OrderItemDataAccess.ORDER_ID + " =  " +  pOrderId +
                     " and " + OrderItemDataAccess.ORDER_ITEM_STATUS_CD +
                     " != '" + RefCodeNames.ORDER_ITEM_STATUS_CD.CANCELLED +"' "+
                     " and " + OrderItemDataAccess.TOTAL_QUANTITY_ORDERED +
                     " > 0 ";

        Statement stmt = pConn.createStatement();
	log.debug("SQL: " + sql);
        ResultSet rs = stmt.executeQuery(sql);

        while (rs.next()) {

            int itemid = rs.getInt(1);

            if (itemid <= 0) {

                String msg = "no item id for order: " + pOrderId;
                log.debug(msg);
                msgs.add(msg);
                stmt.close();

                return msgs;
            }

            int itemskunum = rs.getInt(2);

            if (itemskunum <= 0) {

                String msg = "No sku for clw_item.item_id: " + itemid;
                log.debug(msg);
                msgs.add(msg);

                continue;
            }

            String distSku = rs.getString(3);

            if (distSku == null || distSku.length() == 0) {

                String msg = "No distributor sku for CW.Sku: " + itemskunum;
                log.debug(msg);
                msgs.add(msg);

                continue;
            }

            String distUom = rs.getString(4);

            if (distUom == null || distUom.length() == 0) {

                String msg = "No distributor UOM for CW.Sku: " + itemskunum;
                log.debug(msg);
                msgs.add(msg);

                continue;
            }

            String distPack = rs.getString(5);

            if (distPack == null || distPack.length() == 0) {

                String msg = "No distributor Pack for CW.Sku: " +
                             itemskunum;
                log.debug(msg);
                msgs.add(msg);

                continue;
            }

            double distcost = rs.getDouble(6);

            if (distcost <= 0.0) {

                String msg = "No distributor cost for CW.Sku: " +
                             itemskunum;
                log.debug(msg);
                msgs.add(msg);

                continue;
            }
        }

        stmt.close();

        return msgs;
    }

    private int getOrderIdByOrderItemId(int orderItemId, Connection conn)
                                 throws RemoteException {

        try {

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(OrderItemDataAccess.ORDER_ITEM_ID, orderItemId);

            IdVector orderIds = OrderItemDataAccess.selectIdOnly(conn,
                                                                 OrderItemDataAccess.ORDER_ID,
                                                                 dbc);

            return (((Integer)(orderIds.get(0))).intValue());
        } catch (SQLException exc) {
            log.error("exc.getMessage");
            exc.printStackTrace();
            throw new RemoteException("Error. IntegrationService.getOrderIdByOrderItemId() SQLException happened. " +
                                      exc.getMessage());
        }
    }

    private int getQuantityInvoicedByOrderItemId(int pOrderItemId,
                                                 Connection conn)
                                          throws RemoteException {

        final String GENERATED = "'" +
                                 RefCodeNames.INVOICE_STATUS_CD.ERP_GENERATED +
                                 "'";
        final String GENERATED_ERROR = "'" +
                                       RefCodeNames.INVOICE_STATUS_CD.ERP_GENERATED_ERROR +
                                       "'";
        final String CANCELLED = "'" +
                                 RefCodeNames.INVOICE_STATUS_CD.CANCELLED +
                                 "'";

        try {

            Statement stmt = conn.createStatement();

            // Sum up all the quantity invoiced for the order item id = pOrderItemId
            // (excluding invoices in an unreleased state like generated or cancelled)
            String query = " SELECT SUM(" +
                           InvoiceCustDetailDataAccess.ITEM_QUANTITY +
                           ") from " +
                           InvoiceCustDetailDataAccess.CLW_INVOICE_CUST_DETAIL +
                           " a where a." +
                           InvoiceCustDetailDataAccess.ORDER_ITEM_ID +
                           " = " + pOrderItemId + " and a." +
                           InvoiceCustDetailDataAccess.INVOICE_CUST_ID +
                           " not in " + " (SELECT b." +
                           InvoiceCustDataAccess.INVOICE_CUST_ID + " from " +
                           InvoiceCustDataAccess.CLW_INVOICE_CUST +
                           " b where ( b." +
                           InvoiceCustDataAccess.INVOICE_STATUS_CD + " = " +
                           GENERATED + " or b." +
                           InvoiceCustDataAccess.INVOICE_STATUS_CD + " = " +
                           GENERATED_ERROR + " or b." +
                           InvoiceCustDataAccess.INVOICE_STATUS_CD + " = " +
                           CANCELLED + " ) and b." +
                           InvoiceCustDataAccess.INVOICE_CUST_ID + " = a." +
                           InvoiceCustDetailDataAccess.INVOICE_CUST_ID +
                           " )";
            log.debug("sum query: " + query);

            ResultSet rs = stmt.executeQuery(query);

            if (rs.next()) {

                int quantity = rs.getInt(1);
                stmt.close();

                return (quantity);
            }

            stmt.close();
        } catch (SQLException exc) {
            throw new RemoteException("Error. IntegrationService.getQuantityInvoicedByOrderItemId() SQLException happened. " +
                                      exc.getMessage());
        }

        return 0;
    }



    public void updateJanitorsCloset(OrderJoinData ojd)
	throws RemoteException {
 	updateJanitorsCloset( ojd, false);
    }

    public void updateJanitorsCloset(OrderJoinData ojd,
 				     boolean pMakeLedgerEntryFlag )
	throws RemoteException
    {

        Connection conn = null;

        try {
            conn = getConnection();

            APIAccess factory = new APIAccess();
            Order orderBean = factory.getOrderAPI();
            int orderId = ojd.getOrderId();
            OrderItemDataVector oidVec = orderBean.getOrderItemCollection(
                                                 orderId);
            OrderItemData oid = (OrderItemData)oidVec.get(0);
            int userId = ojd.getUserId();
            OrderData od = ojd.getOrderData();
            int siteId = od.getSiteId();
            saveToJanitorCloset(conn, oid, userId, siteId);
 	    if ( pMakeLedgerEntryFlag == true ) {
 		makeLedgerEntry(conn, od, siteId);
 	    }
        }
	catch (Exception e) {
 	    e.printStackTrace();
            throw new RemoteException
		("updateJanitorCloset: " + e.getMessage());
        }
	finally {
 	    closeConnection(conn);
        }
    }

    /**
    * Gets new value of Order nuber
    * @param pConn - the connection Stjohn database
    * @paran pStoreId - the store identifier
    * @return next order number for the store
    * @throws RemoteException, SQLException
    */
    public int getNextOrderNumber(Connection pConn, int pStoreId)
                           throws RemoteException, SQLException {
        return SequenceUtilDAO.getNextOrderNumber(pConn, pStoreId);
    }

    public int copyOrder(int pSourceOrderId)
                  throws RemoteException, SQLException {

        Connection conn = null;

        try {
            conn = getConnection();

            OrderData od = OrderDataAccess.select(conn, pSourceOrderId);
            log.debug("Source order: " + od);

            OrderData newOd = OrderDataAccess.insert(conn, od);
            log.debug("New order: " + newOd);

            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(OrderItemDataAccess.ORDER_ID, pSourceOrderId);

            OrderItemDataVector oidv = OrderItemDataAccess.select(conn, dbc);

            for (int i = 0; i < oidv.size(); i++) {

                OrderItemData oid = (OrderItemData)oidv.get(i);
                oid.setOrderId(newOd.getOrderId());

                OrderItemData newOid = OrderItemDataAccess.insert(conn, oid);
                log.debug("Added item: " + newOid);
            }

            OrderAddressDataVector oadv = OrderAddressDataAccess.select(conn,
                                                                        dbc);

            for (int i = 0; i < oadv.size(); i++) {

                OrderAddressData oad = (OrderAddressData)oadv.get(i);
                oad.setOrderId(newOd.getOrderId());

                OrderAddressData newOad = OrderAddressDataAccess.insert(conn,
                                                                        oad);
                log.debug("Added address: " + newOad);
            }

            log.debug("Returning new order id: " + newOd.getOrderId());

            return newOd.getOrderId();
        } catch (Exception e) {

            String msg = "Problem getting information for order id: " +
                         pSourceOrderId;
            log.error(" error: " + e + " " + msg);
            throw new RemoteException(msg);
        } finally {

            try {

            	closeConnection(conn);
            } catch (Exception e) {
            }
        }
    }



    /**
     *Jwp's edi file maintains the GSControl number on a per account basis.
     *@param erpAccountNumber the erp account number to use
     */
    public int getNextGSNumber(String erpAccountNumber) throws RemoteException{
        Connection con = null;
        log.debug("in getNextGSNumber");
        try{
            con = getConnection();
            DBCriteria crit = new DBCriteria();
            crit.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
            crit.addEqualTo(BusEntityDataAccess.ERP_NUM,erpAccountNumber);
            BusEntityDataVector bdv = BusEntityDataAccess.select(con,crit);
            if(bdv.size() == 0){
                throw new RemoteException("Could not find bus entity for account erp num: " + erpAccountNumber);
            }
            BusEntityData bd = null;
            if(bdv.size() > 1){
                java.util.Date curDate = new java.util.Date();
                for(int i=0;i<bdv.size();i++){
                    BusEntityData tmpbd = (BusEntityData) bdv.get(i);
                    java.util.Date effDate = tmpbd.getEffDate();
                    java.util.Date expDate = tmpbd.getExpDate();
                    if (tmpbd.getBusEntityStatusCd().equals(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE) &&
                        (effDate==null || !effDate.after(curDate)) &&
                        (expDate==null || !expDate.before(curDate))
                        ){
                        bd  = tmpbd;
                    }
                }
                if(bd == null){
                    throw new RemoteException("Could not find bus entity for account erp num: " + erpAccountNumber);
                }
            }
            if(bdv.size() == 1){
                bd = (BusEntityData) bdv.get(0);
            }



            crit = new DBCriteria();
            crit.addEqualTo(PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
            crit.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,RefCodeNames.PROPERTY_TYPE_CD.EDI_GS_NUMBER);
            crit.addEqualTo(PropertyDataAccess.BUS_ENTITY_ID,bd.getBusEntityId());
            log.debug(">>>>>>>>>>"+crit.getWhereClause());
            PropertyDataVector pdv = PropertyDataAccess.select(con,crit);
            if(pdv.size() == 0){
                PropertyData pd = PropertyData.createValue();
                pd.setBusEntityId(bd.getBusEntityId());
                pd.setAddBy("getNextGSNumber");
                pd.setModBy("getNextGSNumber");
                pd.setPropertyStatusCd(RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                pd.setPropertyTypeCd(RefCodeNames.PROPERTY_TYPE_CD.EDI_GS_NUMBER);
                pd.setShortDesc(RefCodeNames.PROPERTY_TYPE_CD.EDI_GS_NUMBER);
                pd.setValue("1");
                log.debug("inserting property edi gs num!");
                PropertyDataAccess.insert(con, pd);
                return 1;
            }else{
                //update the value, then read it in.  This assures us that we have a lock on
                //this row during this operation so we should be gaurunteed to get a unique value
                PropertyData pd = (PropertyData) pdv.get(0);
                try{
                    StringBuffer sqlBuf = new StringBuffer();
                    sqlBuf.append("UPDATE "+PropertyDataAccess.CLW_PROPERTY+" SET ");
                    sqlBuf.append(PropertyDataAccess.CLW_VALUE+" = "+PropertyDataAccess.CLW_VALUE+"+1");
                    sqlBuf.append(" WHERE "+PropertyDataAccess.PROPERTY_ID+"="+pd.getPropertyId());
                    log.debug("AAAAAAAgetNextGsNum: "+sqlBuf);
                    con.prepareStatement(sqlBuf.toString()).execute();
                }catch (SQLException e){
                    pd.setValue("1");
                    PropertyDataAccess.update(con,pd);
                }
                pd = PropertyDataAccess.select(con,pd.getPropertyId());
                return Integer.parseInt(pd.getValue());
            }
        }catch (Exception e){
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }finally{
            closeConnection(con);
        }
    }

    /**
     *Returns the email address to use for integration related messeges that need sending.
     */
    public String getIntegrationEmailAddress() throws RemoteException{
        try{
            return getAPIAccess().getEmailClientAPI().getDefaultEmailAddress();
        }catch(Exception e){
            throw new RemoteException(e.getMessage());
        }
    }


    /**
     *Returns a unique manifest id.  Will repeat only once it
     *reaches 8 digits (99,999,999)
     */
    public String getUniqueManifestId() throws RemoteException{
        Connection conn = null;
        try{
            conn = getConnection();
            DBCriteria crit = new DBCriteria();
            crit.addEqualTo(PropertyDataAccess.PROPERTY_TYPE_CD,RefCodeNames.PROPERTY_TYPE_CD.CURRENT_MANIFEST_ID);
            crit.addEqualTo(PropertyDataAccess.PROPERTY_STATUS_CD,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
            StringBuffer sqlBuf = new StringBuffer("UPDATE ");
            sqlBuf.append(PropertyDataAccess.CLW_PROPERTY);
            sqlBuf.append(" SET ");
            sqlBuf.append(PropertyDataAccess.CLW_VALUE);
            sqlBuf.append("=");
            sqlBuf.append(PropertyDataAccess.CLW_VALUE);
            sqlBuf.append("+1 WHERE ");
            sqlBuf.append(crit.getWhereClause());
            //sqlBuf.append(PropertyDataAccess.PROPERTY_STATUS_CD);
            //sqlBuf.append("=");
            //sqlBuf.append(RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
            //sqlBuf.append(" AND ");
            //sqlBuf.append(PropertyDataAccess.PROPERTY_TYPE_CD);
            //sqlBuf.append("=");
            //sqlBuf.append(RefCodeNames.PROPERTY_TYPE_CD.CURRENT_MANIFEST_ID);
            log.debug(">>>>>>>>>SQL: "+sqlBuf);
            Statement stmt = conn.createStatement();
            int updateRows = stmt.executeUpdate(sqlBuf.toString());
            String packageId = null;
            PropertyData pd = null;
            if(updateRows > 1){
                throw new RemoteException("Multiple properties found for: " + RefCodeNames.PROPERTY_TYPE_CD.CURRENT_MANIFEST_ID);
            }else if(updateRows == 0){
                //create the property
                pd = PropertyData.createValue();
                pd.setAddBy("System");
                pd.setModBy("System");
                pd.setPropertyStatusCd(RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);
                pd.setPropertyTypeCd(RefCodeNames.PROPERTY_TYPE_CD.CURRENT_MANIFEST_ID);
                packageId = "0";
                pd.setValue(packageId);
                PropertyDataAccess.insert(conn, pd);
            }else{
                //we know there is 1 and only 1 given the update count
                pd = (PropertyData) PropertyDataAccess.select(conn, crit).get(0);
                packageId = pd.getValue();
                if(packageId.length() > 6){
                    packageId = "0";
                    pd.setValue(packageId);
                    PropertyDataAccess.update(conn, pd);
                }
            }
            return packageId;
        }catch(Exception e){
            throw processException(e);
        }finally{
            closeConnection(conn);
        }
    }


    /** Saves reingneered customer invocies data to database
     *
     */
    public void reengineerCustInvoices(ArrayList pInvoices)
    throws RemoteException
    {
      Connection conn = null;
      DBCriteria dbc;
      try {
      conn = getConnection();
      String fileName = null;
      SimpleDateFormat sdf = new SimpleDateFormat ("yyyyMMdd");
      SimpleDateFormat sdf1 = new SimpleDateFormat ("yyMMdd");
      for(int ii=0; ii<pInvoices.size(); ii++) {
        HashMap invoice = (HashMap) pInvoices.get(ii);
        if(ii==0) {
          fileName = (String) invoice.get(VerifyCustInvoices.FILE_NAME);
        log.debug("IntegrationServicesBean IIIIIIIIIIIIIIIIIIIIIIIIIIIIII   fileName: "+fileName);
          dbc = new DBCriteria();
          dbc.addEqualTo(InvoiceCustReengDataAccess.FILE_NAME,fileName);
          InvoiceCustReengDataAccess.remove(conn,dbc);
        }
        String invoiceNum = (String) invoice.get(VerifyCustInvoices.INVOICE_NUM);
        if(invoiceNum==null || invoiceNum.trim().length()==0) continue;
        String invoiceType = (String) invoice.get(VerifyCustInvoices.INVOICE_TYPE);
        String refInvoiceNum = (String) invoice.get(VerifyCustInvoices.REF_INVOICE_NUM);
        String sender = (String) invoice.get(VerifyCustInvoices.SENDER);
        String receiver = (String) invoice.get(VerifyCustInvoices.RECEIVER);
        String setNum = (String)  invoice.get(VerifyCustInvoices.SET_NUM);
        Date invoiceDate = null;
        String invoiceDateS = (String) invoice.get(VerifyCustInvoices.INVOICE_DATE);
        try {
          invoiceDate = sdf.parse(invoiceDateS);
        }catch(Exception exc) {
          try {
           invoiceDate = sdf1.parse(invoiceDateS);
          }catch(Exception exc1) {}
        }
        ArrayList det = (ArrayList) invoice.get(VerifyCustInvoices.INVOICE_DETAIL);
        if(det!=null) {
          for(int jj=0; jj<det.size(); jj++) {
            InvoiceCustReengData invoiceDB = InvoiceCustReengData.createValue();
            invoiceDB.setFileName(fileName);
            invoiceDB.setSetNum(setNum);
            invoiceDB.setSender(sender);
            invoiceDB.setReceiver(receiver);
            invoiceDB.setInvoiceDate(invoiceDate);
            invoiceDB.setInvoiceNum(invoiceNum);
            invoiceDB.setInvoiceType(invoiceType);
            invoiceDB.setRefInvoiceNum(refInvoiceNum);
            HashMap invLine = (HashMap) det.get(jj);
            int lineNum = 0;
            try {
             String ss = (String) invLine.get(VerifyCustInvoices.LINE_NUM);
             lineNum = Integer.parseInt(ss);
            } catch(Exception exc){}
            invoiceDB.setLineNum(lineNum);
            String custSkuNum = (String) invLine.get(VerifyCustInvoices.CUST_SKU_NUM);
            invoiceDB.setCustSkuNum(custSkuNum);
            int cwSkuNum = 0;
            try {
              String ss = (String) invLine.get(VerifyCustInvoices.CW_SKU_NUM);
              cwSkuNum = Integer.parseInt(ss);
            }catch(Exception exc){}
            invoiceDB.setCwSkuNum(cwSkuNum);
            int qty = 0;
            try {
              String ss = (String) invLine.get(VerifyCustInvoices.ITEM_QTY);
              qty = Integer.parseInt(ss);
            }catch(Exception exc){}
            invoiceDB.setItemQty(qty);
            String chargeType = (String) invLine.get(VerifyCustInvoices.CHARGE_TYPE);
            invoiceDB.setChargeType(chargeType);
            BigDecimal price = new BigDecimal(0);
            try {
             String ss = (String) invLine.get(VerifyCustInvoices.ITEM_PRICE);
              price = new BigDecimal(ss);
            }catch(Exception exc){}
            invoiceDB.setItemPrice(price);
            String uom = (String) invLine.get(VerifyCustInvoices.ITEM_UOM);
            invoiceDB.setItemUom(uom);
            InvoiceCustReengDataAccess.insert(conn,invoiceDB);
        }
      } else { //No detail records
         InvoiceCustReengData invoiceDB = InvoiceCustReengData.createValue();
         invoiceDB.setFileName(fileName);
         invoiceDB.setSetNum(setNum);
         invoiceDB.setSender(sender);
         invoiceDB.setReceiver(receiver);
         invoiceDB.setInvoiceDate(invoiceDate);
         invoiceDB.setInvoiceNum(invoiceNum);
         invoiceDB.setRefInvoiceNum(refInvoiceNum);
         InvoiceCustReengDataAccess.insert(conn,invoiceDB);
      }
      }
    }catch(Exception e){
      throw processException(e);
    }finally{
      closeConnection(conn);
    }

    }

    /** Gets max add_date from clw_invoice_cust_reeng table
     *
     */
    public Date getInvoiceCustReengMaxDate()
    throws RemoteException
    {
      Connection conn = null;
      try {
      conn = getConnection();
      String query = "select max(add_date) max_date " +
 	    " from clw_invoice_cust_reeng ";
      Statement stmt = null;
      ResultSet rs = null;
      stmt = conn.createStatement();
      rs = stmt.executeQuery(query);
      Date date = null;
      while (rs.next()) {
        date = rs.getDate("max_date");
        break;
      }
      return date;
    }catch(Exception e){
      throw processException(e);
    }finally{
      closeConnection(conn);
    }

    }

    /**
     * Checks pending date orders and reprocesses ready ones
     */
    public void processPendingDateOrders()
            throws RemoteException
    {
        log.info("processPendingDateOrders.");
        Connection conn = null;
        DBCriteria dbc;

        try {
            conn = getConnection();

            dbc = new DBCriteria();
            dbc.addEqualTo(OrderDataAccess.ORDER_STATUS_CD, RefCodeNames.ORDER_STATUS_CD.PENDING_DATE);
            String orderIdReq = OrderDataAccess.getSqlSelectIdOnly(OrderDataAccess.ORDER_ID, dbc);

            dbc = new DBCriteria();
            dbc.addOneOf(OrderMetaDataAccess.ORDER_ID, orderIdReq);
            dbc.addEqualTo(OrderMetaDataAccess.NAME,RefCodeNames.ORDER_PROPERTY_TYPE_CD.PENDING_DATE);
            OrderMetaDataVector orderMetaDV = OrderMetaDataAccess.select(conn,dbc);

            SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
            Date currentDate = new Date();
            currentDate = sdf.parse(sdf.format(currentDate));

            for(int ii=0; ii<orderMetaDV.size(); ii++) {
                OrderMetaData omD = (OrderMetaData) orderMetaDV.get(ii);
                String dateS = omD.getValue();
                Date date;

                try {
                    date = sdf.parse(dateS);
                }catch(Exception exc) {
                    String errorMess = "Wrong order meta value. OrderMetaId="+omD.getOrderMetaId();
                    log.error(errorMess);
                    continue;
                }

                if(!currentDate.before(date)) {
                    //Clear workflow error if found
                    dbc = new DBCriteria();
                    dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID,omD.getOrderId());
                    dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC,"Workflow Note");
                    dbc.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD,
                            RefCodeNames.ORDER_PROPERTY_TYPE_CD.ORDER_NOTE);
                    dbc.addIsNull(OrderPropertyDataAccess.APPROVE_DATE);
                    OrderPropertyDataVector opDV = OrderPropertyDataAccess.select(conn,dbc);

                    Date currDate = new Date();
                    for(Iterator iter=opDV.iterator();iter.hasNext();) {
                        OrderPropertyData opD = (OrderPropertyData) iter.next();
                        opD.setApproveDate(currDate);
                        opD.setApproveUserId(0);
                        opD.setModBy("System");
                        OrderPropertyDataAccess.update(conn,opD);
                    }

                    int orderId = omD.getOrderId();
                    OrderData oD = OrderDataAccess.select(conn, orderId);

                    Date revDate = new Date();
                    oD.setRevisedOrderDate(revDate);
                    oD.setRevisedOrderTime(revDate);
                    oD.setModBy("System");
                    OrderDataAccess.update(conn,oD);

                    String orderStatusCode = RefCodeNames.ORDER_STATUS_CD.ORDERED;
                    reprocessOrderRequest(orderId, orderStatusCode, "System");
                }
            }


        }catch(Exception e){
            throw processException(e);
        }finally{
            closeConnection(conn);
            log("processPendingDateOrders() End");
        }

    }


    public UserAcessTokenViewData createAccessToken(LdapItemData pKey)
    throws RemoteException, InvalidLoginException{
    	return createAccessToken(pKey,true);
    }

    /**
     *Creates a valid access token.  An access toekn will allow a user to log into our site
     *without supplying a username and password, instead they supply the access token and
     *not supply the user name and password.  This method will validate the user name and
     *password that was supplied with the LdapItemData.
     */
    public UserAcessTokenViewData createAccessToken(LdapItemData pKey, boolean checkPwd)
    throws RemoteException, InvalidLoginException{
        try{
            return getAPIAccess().getUserAPI().createAccessToken(pKey,checkPwd);
        }catch(APIServiceAccessException e){
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }catch(NamingException e){
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }
    }


    /**
     *Returns a String representation of a file path which should be suitable for
     *new File(<String>).  This path is the location where files are stored when
     *an inline integration request is made, interface when something is run through
     *the translation logic that does not use files.
     *@throws RemoteException
     *@throws DataNotFoundException if the property has not been configured
     */
    public String getPathForArchiveIntegrationFiles()
    throws RemoteException{
        Connection con = null;
        try{
            con = getConnection();
            PropertyUtil p = new PropertyUtil(con);
            return System.getProperty("jboss.home") + "/" + p.fetchValue(0,0,RefCodeNames.PROPERTY_TYPE_CD.REL_PATH_FOR_ARCHIEVE_INT_FILE);
        }catch(Exception e){
            throw processException(e);
        }finally{
            closeConnection(con);
        }
    }


    /**
     *Returns a String representation of a file path which should be suitable for
     *new File(<String>).  This path is the location where failed files are stored when
     *an inline integration request is made, interface when something is run through
     *the translation logic that does not use files.
     *@throws RemoteException
     *@throws DataNotFoundException if the property has not been configured
     */
    public String getPathForArchiveFailedIntegrationFiles()
    throws RemoteException{
        Connection con = null;
        try{
            con = getConnection();
            PropertyUtil p = new PropertyUtil(con);
            return System.getProperty("jboss.home") + "/" + p.fetchValue(0,0,RefCodeNames.PROPERTY_TYPE_CD.REL_PATH_FOR_FAILED_INT_FILE);
        }catch(Exception e){
            throw processException(e);
        }finally{
            closeConnection(con);
        }
    }






    /********************START Sub System to deal with the loading of the parcel direct
     manifest reconciliation files*/

    private static HashMap distToGrpMapping = new HashMap();
    private static HashMap distToFileMapping = new HashMap();
    private static String defaultDistToGrpMapping  = "1127";
    static {
        //distToGrpMapping.put("", "1127"); //Lagasse leaves field blank
        distToGrpMapping.put("MA","1127"); //Lagasse is identified by the MA
        distToGrpMapping.put("WI","1127"); //Lagasse is identified by the WI
        distToGrpMapping.put("OH","1532"); //Kellermyer is identified by the OH
        distToGrpMapping.put("JANPAK","1318"); //Jan Pak TX is identified by the OH
        distToGrpMapping.put("NJ","1298"); //BUNZL
        distToFileMapping.put("TX","1318"); //Jan Pak TX is identified by the TX in the file name
        distToFileMapping.put("NJ","1298"); //BUNZL
        distToFileMapping.put("OH","1532"); //Kellermyer
    }

    static final String trackingNumSql =
        "SELECT max(oi."+OrderItemDataAccess.PURCHASE_ORDER_ID+") as purchase_order_id, "+
        "max(oi."+OrderItemDataAccess.FREIGHT_HANDLER_ID+") as fh_id, "+
        "count(distinct oi."+OrderItemDataAccess.PURCHASE_ORDER_ID+") as count, "+
        "id."+InvoiceDistDataAccess.TRACKING_NUM + " "+
        "FROM "+
        InvoiceDistDataAccess.CLW_INVOICE_DIST+" id, "+
        OrderItemDataAccess.CLW_ORDER_ITEM+" oi "+
        "WHERE " +
        "id."+InvoiceDistDataAccess.TRACKING_NUM+" like ? " +
        "and "+
        //" id."+InvoiceDistDataAccess.BUS_ENTITY_ID+"= ?"+
        " oi."+OrderItemDataAccess.ERP_PO_NUM + "(+)= id."+InvoiceDistDataAccess.ERP_PO_NUM + " "+
        "GROUP BY id."+InvoiceDistDataAccess.TRACKING_NUM;


    static final String zipcodeEstSqlStatic =
        "SELECT distinct oi."+OrderItemDataAccess.PURCHASE_ORDER_ID+", "+
        "oi."+OrderItemDataAccess.FREIGHT_HANDLER_ID+", "+
        "oi."+OrderItemDataAccess.ERP_PO_DATE+" "+
        "FROM "+
        OrderAddressDataAccess.CLW_ORDER_ADDRESS+" oa, "+
        OrderItemDataAccess.CLW_ORDER_ITEM+" oi "+
        "WHERE "+
        "oi."+OrderItemDataAccess.ORDER_ID + "= oa."+OrderAddressDataAccess.ORDER_ID+" AND "+
        "oa."+OrderAddressDataAccess.ADDRESS_TYPE_CD +"='"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING +"' AND "+
        "substr(oa."+OrderAddressDataAccess.POSTAL_CODE+",0,5) = ? AND " +
        "oi."+OrderItemDataAccess.DIST_ERP_NUM+" = ? AND "+
        "oi."+OrderItemDataAccess.ERP_PO_DATE+" BETWEEN ? AND ?";

    static final String custPrclIdSqlStatic =
        "Select count(*) from "+PdManifestDataAccess.CLW_PD_MANIFEST +" "+
        "Where "+PdManifestDataAccess.CUST_PRCL_ID+"=?";

     private static final int DAY_HINT_SPAN = 720; //number of days to assume for date of records. This is used
                                                     //when trying to "guess" a date so we can say for exacmple that
                                                     //(assuming 720 days, or 2 year as the hint)
                                                     //if today is 1/1/2004 any number starting with 200 *could* be a
                                                     //year string, likewise if today is 1/1/3011 then any number starting
                                                     //with either 300 or 301 *could* be a year string.

     private void processPdManifestData(PdManifestData pData,Connection pCon,Map paramMap)
     throws DataNotFoundException,SQLException{
    	 log.info("processPdManifestData.");
         HashMap distErpToId = new HashMap();
         pData.setAddBy("System");
         estimateDate(pData,pData.getCustManifestId());
         if(pData.getEstShipDate() == null){
             estimateDate(pData,pData.getSrcDoc());
         }
         String key = "processPdManifestData.freightHandlers";
         IdVector freightHandlers = (IdVector) paramMap.get(key);
         if(freightHandlers == null){
             //get the frieght handler ids we are interested in
             DBCriteria fhCrit = new DBCriteria();
             fhCrit.addLike(BusEntityDataAccess.SHORT_DESC,"Parcel Dir%");
             fhCrit.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD,RefCodeNames.BUS_ENTITY_TYPE_CD.FREIGHT_HANDLER);
             freightHandlers = BusEntityDataAccess.selectIdOnly(pCon,fhCrit);
             if(freightHandlers.isEmpty()){
                 throw new DataNotFoundException("Error: Could not find any Parcel Direct freight handlers!");
             }
             paramMap.put(key,freightHandlers);
         }

         key = "processPdManifestData.trackingNumStmt";
         PreparedStatement trackingNumStmt = (PreparedStatement) paramMap.get(key);
         if(trackingNumStmt == null){
             log.debug("trackingNumSql-->");
             log.debug(trackingNumSql);
             trackingNumStmt = pCon.prepareStatement(trackingNumSql);
             paramMap.put(key,trackingNumStmt);
         }

         key = "processPdManifestData.zipcodeEstStmt";
         PreparedStatement zipcodeEstStmt = (PreparedStatement) paramMap.get(key);
         if(zipcodeEstStmt == null){
             //String zipcodeEstSql = zipcodeEstSqlStatic + " AND oi."+OrderItemDataAccess.FREIGHT_HANDLER_ID+" IN ("+Utility.toCommaSting(freightHandlers)+")";
             String zipcodeEstSql = zipcodeEstSqlStatic;
             log.debug("zipcodeEstSql-->");
             log.debug(zipcodeEstSql);
             zipcodeEstStmt = pCon.prepareStatement(zipcodeEstSql);
             paramMap.put(key,zipcodeEstStmt);
         }

         key = "processPdManifestData.custPrclId";
         PreparedStatement custPrclIdStmt = (PreparedStatement) paramMap.get(key);
         if(custPrclIdStmt == null){
             log.debug("custPrclIdSqlStatic-->");
             log.debug(custPrclIdSqlStatic);
             custPrclIdStmt = pCon.prepareStatement(custPrclIdSqlStatic);
             paramMap.put(key,custPrclIdStmt);
         }


         //run the analysis on this record.
         String unTrimedTrackingNum = pData.getCustPrclId();
         String trackingNum;
         if(unTrimedTrackingNum != null && unTrimedTrackingNum.length() > 2){
             //XXX chop off the last 2 charachters...may need to switch this to count up to a set length
             //as opposed to moving down by 2...not really sure
             trackingNum = unTrimedTrackingNum.substring(0,unTrimedTrackingNum.length()-2);
         }else{
             trackingNum = unTrimedTrackingNum;
         }
         log.debug("Looking for tracking number: "+trackingNum);

         custPrclIdStmt.setString(1,unTrimedTrackingNum);
         ResultSet rs = custPrclIdStmt.executeQuery();
         if(rs.next() && rs.getInt(1) > 0){
             //more in depth checking maybe???
             log.debug("duplicate prcl id, not loading.");
             return;
         }




         trackingNumStmt.setString(1,"%"+trackingNum+"%");
         rs = trackingNumStmt.executeQuery();
         int count = 0;
         while(rs.next()){
            log.debug("Found a rs record!");
            String tracNums = rs.getString(4);
            StringTokenizer tok = new StringTokenizer(tracNums,",");
            while(tok.hasMoreTokens()){
                String aTracNum = tok.nextToken();
                log.debug("does: "+aTracNum + " startsWith "+ trackingNum + " and is "+aTracNum.length()+" + 2 "+(aTracNum.length()+2)+" <= "+ unTrimedTrackingNum.length());
                aTracNum = aTracNum.trim();
                if(aTracNum.startsWith(trackingNum) && (aTracNum.length() <= unTrimedTrackingNum.length())){
                    log.debug("yes");
                    //we will just set the po to the last match.
                    int poId = rs.getInt(1);
                    count = count + rs.getInt(3);
                    log.debug("count = "+count);
                    if(count > 0){
                        pData.setMatchType("Tracking Number");
                        pData.setPurchaseOrderId(poId);
                    }
                    break;
                }else{
                    log.debug("no");
                    if(!aTracNum.startsWith(trackingNum)){
                        log.debug("no start with");
                    }
                    if(!((aTracNum.length() + 2) <= unTrimedTrackingNum.length())){
                        log.debug("no length");
                    }

                }
            }

         }
         if(count > 0){
            pData.setMatchingRecords(count);
         }
         if(pData.getMatchingRecords() == 0){
             rs.close();
             //trackingNumStmt.close();

             String zip = pData.getDestSrcCd();
             if(zip != null && zip.length() > 5){
                 zip = zip.substring(0,5);
             }
             zipcodeEstStmt.setString(1, zip);
             String manGrpTxt = pData.getManifestGrpTxt();
             if(manGrpTxt == null){
                 manGrpTxt = "";
             }else{
                 manGrpTxt = manGrpTxt.trim();
             }
             String distNum = (String) distToGrpMapping.get(manGrpTxt);
             if(distNum == null){
                 distNum = (String) paramMap.get("processPdManifestData."+pData.getSrcDoc());
                 if(distNum == null){
                     Iterator it = distToFileMapping.keySet().iterator();
                     while(it.hasNext()){
                         String aKey = (String) it.next();
                         //if the key is contained in the file in a significant way, i.e.
                         //<path>/ma august 2004/<more path> use this as dist
                         String srcDoc = pData.getSrcDoc();
                         if(srcDoc != null){
                             srcDoc = srcDoc.toUpperCase();
                             if(srcDoc.indexOf("/"+aKey+" ") > 0 ||
                                srcDoc.indexOf(" "+aKey+" ") > 0 ||
                                srcDoc.indexOf(" "+aKey+"/") > 0){
                                    distNum = (String) distToFileMapping.get(aKey);
                                    paramMap.put("processPdManifestData."+pData.getSrcDoc(),distNum);
                                    break;
                             }
                         }
                    }
                 }
             }
             if(distNum == null){
                 distNum = defaultDistToGrpMapping;
             }
             Integer distId = null;
             if(distErpToId.containsKey(distNum)){
                 distId = (Integer) distErpToId.get(distNum);
             }else{
                 if(distNum != null){
                    DBCriteria crit = new DBCriteria();
                    crit.addEqualTo(BusEntityDataAccess.ERP_NUM,distNum);
                    crit.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD,RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
                    BusEntityData dist = Utility.getBestbusEntityData(BusEntityDataAccess.select(pCon,crit));
                    if(dist != null){
                        distId = new Integer(dist.getBusEntityId());
                    }else{
                        distId = new Integer(0);
                    }
                    distErpToId.put(distNum, distId);
                 }
             }
             if(distId == null){
                 distId = new Integer(0);
             }
             pData.setDistributorId(distId.intValue());
             if (pData.getEstShipDate() != null){
                 zipcodeEstStmt.setString(2, distNum);
                 Date esd = pData.getEstShipDate();
                 Calendar estShipDate = Calendar.getInstance();
                 estShipDate.setTime(esd);
                 //assume max of 30 days back to account for backorders
                 estShipDate.add(Calendar.DATE, -30);
                 java.sql.Date startPODate = new java.sql.Date(estShipDate.getTime().getTime()); //convert to java.sql.Date
                 estShipDate.setTime(esd);
                 //assume 3 days of future date slop
                 estShipDate.add(Calendar.DATE, +3);
                 java.sql.Date endPODate = new java.sql.Date(estShipDate.getTime().getTime()); //convert to java.sql.Date
                 zipcodeEstStmt.setDate(3,startPODate);//begin date
                 zipcodeEstStmt.setDate(4,endPODate);//end date
                 rs = zipcodeEstStmt.executeQuery();
                 int countFH = 0;
                 int countNonFh = 0;
                 Date closestFHMatchDate = null;
                 int closestFHMatchPoId = 0;
                 Date closestNonFHMatchDate = null;
                 int closestNonFHMatchPoId = 0;
                 while(rs.next()){
                    int poId = rs.getInt(1);
                    int fhId = rs.getInt(2);
                    Date poDate = rs.getDate(3);
                    if(freightHandlers.contains(new Integer(fhId))){
                        countFH++;
                        boolean useThisOne = true;
                        if(closestFHMatchPoId > 0){
                            if((closerToDate(esd,closestFHMatchDate,poDate) > 0)){
                                useThisOne = false;
                            }
                        }
                        if(useThisOne){
                            closestFHMatchPoId=poId;
                            closestFHMatchDate=poDate;
                        }
                    }else{
                        countNonFh++;
                        boolean useThisOne = true;
                        if(closestNonFHMatchPoId > 0){
                            if((closerToDate(esd,closestNonFHMatchDate,poDate) > 0)){
                                useThisOne = false;
                            }
                        }
                        if(useThisOne){
                            closestNonFHMatchPoId=poId;
                            closestNonFHMatchDate=poDate;
                        }
                    }
                }
                pData.setMatchingRecords(countFH);
                if(countFH > 0){
                    pData.setMatchType("Postal Code Match");
                    pData.setPurchaseOrderId(closestFHMatchPoId);
                }else if(countNonFh > 0){
                    pData.setMatchType("Postal Code Non PD Match");
                    pData.setMatchingRecordsNonPd(countNonFh);
                    pData.setPurchaseOrderIdNonPd(closestNonFHMatchPoId);
                }else{
                    pData.setMatchType("NO Match");
                }
                 rs.close();
             }
         }
         if(pData.getPdManifestId() == 0){
            PdManifestDataAccess.insert(pCon,pData);
         }else{
             if(pData.isDirty()){
                PdManifestDataAccess.update(pCon,pData);
             }
         }
     }




     /**
      *Returns 0 if pDate1 and pDate2 are the same amount of time from the src date,
      *1 if date1 is closer, -1 id date2 is closer.
      */
     private static int closerToDate(Date pSrcDate, Date pDate1, Date pDate2){
         long diff1 = pSrcDate.getTime() - pDate1.getTime();
         long diff2 = pSrcDate.getTime() - pDate2.getTime();
         if(diff1 < 0){
             diff1 = diff1*-1;
         }
         if(diff2 < 0){
             diff2 = diff2*-1;
         }
         if(diff1 == diff2){
             return 0;
         }
         if(diff1 > diff2){
             return -1;
         }
         return 1;
     }

    /**
     *Tries to estimate the date of this manifest record
     */
    private static void estimateDate(PdManifestData data,String fileName){
        //get valid years
        Calendar lowRange = Calendar.getInstance();
        lowRange.add(Calendar.DAY_OF_YEAR, -1*DAY_HINT_SPAN);

        Calendar highRange = Calendar.getInstance();
        highRange.add(Calendar.DAY_OF_YEAR, DAY_HINT_SPAN);

        int lowYear = lowRange.get(Calendar.YEAR);
        int highYear = highRange.get(Calendar.YEAR);
        ArrayList validYears = new ArrayList();
        for(int i=0;i<=(highYear - lowYear);i++){
            validYears.add(Integer.toString(lowYear + i));
        }

        if(fileName.matches("Date")){
            data.setEstShipDateType("FileName Exact");
        }
        //if the filename has an extension remove it for our comparison
        if(fileName.charAt(fileName.length() - 4) == '.'){
            fileName = fileName.substring(0,fileName.length() - 4);
        }
        //parse out the String
        char[] delimterChars = {'-','_','.',' '};
        char[] fileNameC = fileName.toCharArray();
        StringBuffer aWord = new StringBuffer();
        ArrayList parsedWords = new ArrayList();
        for(int i=0;i<fileNameC.length;i++){
            boolean delmitChar = false;
            for(int j=0;j<delimterChars.length;j++){
                if(delimterChars[j] == fileNameC[i]){
                    delmitChar = true;
                    break;
                }
            }

            if(!delmitChar){
               aWord.append(fileNameC[i]);
            }else{
                parsedWords.add(aWord.toString());
                aWord = new StringBuffer();
            }
        }
        //if the last char was not a delimted char add the contents of the word to
        //the parsed list
        if(aWord.length() > 0){
            parsedWords.add(aWord.toString());
        }

        //if the string is of the form yyyyMMdd or MMddyyyy without delimiters try that
        for(int i=0,len=parsedWords.size();i<len;i++){
            String lWord = (String) parsedWords.get(i);
            if(lWord.length()==8){
                int year= 0;
                String month = null;
                String day = null;
                if(validYears.contains(lWord.substring(0,4))){
                    year = Integer.parseInt(lWord.substring(0,4));
                    month = lWord.substring(4,6);
                    day = lWord.substring(6,8);
                }else if(validYears.contains(lWord.substring(4,lWord.length()))){
                    year = Integer.parseInt(lWord.substring(4,lWord.length()));
                    month = lWord.substring(0,2);
                    day = lWord.substring(2,4);
                }
                try{
                    java.util.Date aDate = getDate(month,day,year);
                    if(aDate != null){
                        data.setEstShipDate(aDate);
                        data.setEstShipDateType("Customer Manifest ID");
                        return;
                    }
                //not a real date, continue
                }catch(NumberFormatException e){
                }catch(ParseException e){}

            }
        }





        //and finally try and figure out the date based off the file
        for(int i=0,len=parsedWords.size();i<len;i++){
            String word = (String) parsedWords.get(i);
            if(validYears.contains(word)){
                //k, this is of the form
                //yyyy/mm/dd
                //or
                //mm/dd/yyyy
                //We could get fancy and feed it a directory to attempt to determine
                //if mm/dd or dd/mm is prefered, but for now assume std US notation
                if(i>=2){
                    //check mm/dd/yyyy
                    try{
                        String month = (String) parsedWords.get(i-2);
                        String day = (String) parsedWords.get(i-1);
                        java.util.Date aDate = getDate(month,day,Integer.parseInt(word));
                        if(aDate != null){
                            data.setEstShipDate(aDate);
                            return;
                        }
                    //something not a number, check other format or keep looping through, might be more
                    //year like strings
                    }catch(NumberFormatException e){
                    }catch(ParseException e){}
                }
                if(i+2<=len){
                    //check yyyy/mm/dd
                    try{
                        String month = (String) parsedWords.get(i+1);
                        String day = (String) parsedWords.get(i+2);
                        java.util.Date aDate = getDate(month,day,Integer.parseInt(word));
                        if(aDate != null){
                            data.setEstShipDate(aDate);
                            return;
                        }
                    //somthing not a number, keep looping through, might be more
                    //year like strings
                    }catch(NumberFormatException e){
                    }catch(ParseException e){}
                }
            }
        }
    }

    private static java.util.Date getDate(String month,String day, int year) throws NumberFormatException,ParseException{
        if(month==null || month.length() > 2 || day == null || day.length() > 2){
            //these may parse out to numbers but not be valid
            //00003 for example, whereas 03 is okay
            return null;
        }
        int dayI = Integer.parseInt(day);
        int monthI = Integer.parseInt(month);
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
        java.util.Date aDate = sdf.parse(month+"/"+day+"/"+Integer.toString(year));
        Calendar aCal = Calendar.getInstance();
        aCal.setTime(aDate);
        if(aCal.get(Calendar.YEAR) == year &&
            //month returned is always one less than human readable month...i.e. january = month 0
            aCal.get(Calendar.MONTH) == (monthI-1) &&
            aCal.get(Calendar.DAY_OF_MONTH) == dayI){
            return aDate;
        }
        return null;
    }

    /********************END Sub System to deal with the loading of the parcel direct
     manifest reconciliation files*/


    /**
     *Returns a populated siteData object as specified by the pSiteId
     *@throws DataNotFoundException if the specified site id oes not exist
     */
    public SiteData getSite(int pSiteId)throws RemoteException{
        try{
        	return getAPIAccess().getSiteAPI().getSite(pSiteId);
        }catch(Exception e){
            throw processException(e);
        }
    }

    public ProcessOrderResultData resendFailedPOs
	(int pOrderId,String pUserName)
	throws RemoteException,
	       BudgetRuleException {

        ProcessOrderResultData resendRes =
	    ProcessOrderResultData.createValue();
	resendRes.setOrderId(pOrderId);
	resendRes.setOKFlag(true);

	Connection conn = null;
	try {
	    conn = getConnection();

	    OrderDAO odao = new OrderDAO(conn, pOrderId);

	    OrderData od = odao.getOrderData();
	    if ( od.getOrderStatusCd() == null ||
		 ! od.getOrderStatusCd().equals
		 (RefCodeNames.ORDER_STATUS_CD.ERP_RELEASED) ) {
		String m = "trying to resend pos for an order in" +
		    " an invalid status od=" + od ;
		log.debug(m);
		resendRes.addResponseMsg(m);
		resendRes.setOKFlag(false);
		return resendRes;
	    }


	    OrderItemDataVector orderItems = odao.getOrderItems();

	    for ( int i = 0; null != orderItems &&
		      i < orderItems.size(); i++ ) {
		OrderItemData oid = (OrderItemData)orderItems.get(i);
		if ( oid.getOrderItemStatusCd() != null &&
		     oid.getOrderItemStatusCd().equals
		     (RefCodeNames.ORDER_ITEM_STATUS_CD.SENT_TO_DISTRIBUTOR_FAILED)) {
		    String newStatus =
			RefCodeNames.ORDER_ITEM_STATUS_CD.PENDING_FULFILLMENT;
		    String m = " Resending item: " + oid +
			" new line item status=" + newStatus;
		    oid.setOrderItemStatusCd(newStatus);
		    OrderItemDataAccess.update(conn, oid);
		    OrderDAO.addOrderItemNote(conn, pOrderId, oid.getOrderItemId(),
					  m,pUserName);
		    log.debug(m);
		    resendRes.addResponseMsg(m);
		}
	    }

	} catch (Exception e) {
	    e.printStackTrace();
	    throw new RemoteException( "ISB 2006-4-21: " + e.getMessage() );
	} finally {
	    log.debug( "resendFailedPOs, resendRes=" + resendRes);
	    closeConnection(conn);
	}

	return resendRes;
    }

        /**
     * @param conn                 connection
     * @param exceptOnTaxDiffValue property of the distributor
     * @param invoice              invoice
     * @param invoiceDistDetailDV  invoice detail collection
     * @param orderData            order data
     * @param notesToLog           variable for the  saving of errors
     * @return count of error
     * @throws Exception exceptions
     */
    public int invoiceDistTaxAnalysis(Connection conn,
                                      String exceptOnTaxDiffValue,
                                      InvoiceDistData invoice,
                                      InvoiceDistDetailDataVector invoiceDistDetailDV,
                                      OrderData orderData, OrderItemDataVector poItems,
                                      List itemNotesToLog, List notesToLog, Map paramMap) throws Exception {
        int exceptionCount = 0;
        try {

            log.info("invoiceDistTaxAnalysis method");

            if (invoice == null) throw new Exception("Invoice dist data is null");
            if (invoiceDistDetailDV == null) throw new Exception("Invoice data detail data collection  is null");
            if (orderData == null) throw new Exception("Order Data  is null");
            if (poItems == null) throw new Exception("Order item collection is null");

            if (RefCodeNames.EXCEPTION_ON_TAX_VALUE.NO.equals(exceptOnTaxDiffValue)) {
                return 0;
            }
            ///////////////////////////////////////////////////////////////////
            // gets  approved invoice flag
            // if this is an approved invoice then there are no errors possible
            ///////////////////////////////////////////////////////////////////
            DBCriteria crit = new DBCriteria();
            crit.addEqualTo(OrderPropertyDataAccess.INVOICE_DIST_ID, invoice.getInvoiceDistId());
            crit.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_TYPE_CD, RefCodeNames.ORDER_PROPERTY_TYPE_CD.INVOICE_DIST_APPROVED);
            crit.addEqualTo(OrderPropertyDataAccess.ORDER_PROPERTY_STATUS_CD, RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
            OrderPropertyDataVector values = OrderPropertyDataAccess.select(conn, crit);
            if (values != null) {
                if (values.size() > 0) {
                    OrderPropertyData prop = (OrderPropertyData) values.get(0);
                    log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis] order property  => " + prop);
                    if (prop != null && Utility.isTrue(prop.getValue())) {
                        return 0;
                    }
                }
            }
            ////////////////////////////////////////////////////////////////////////////
            //Gets the taxable subtotal for the invoice.
            //If an item matches to an order item it compares the taxable
            //status of the order item.  If not it assumes that the item is taxable.
            /////////////////////////////////////////////////////////////////////////////
            /********* old code
            BigDecimal subTotal = ZERO;
            boolean homoGenResaleOrderFl = true; //
            Iterator it = invoiceDistDetailDV.iterator();
            while (it.hasNext()) {
                InvoiceDistDetailData invDistDetailData = (InvoiceDistDetailData) it.next();
                OrderItemData oid = null;
                try {
                    invDistDetailData.setInvoiceDistId(invoice.getInvoiceDistId());
                    invDistDetailData.setDistItemQtyReceived(invDistDetailData.getDistItemQuantity());
                    oid = matchDistributorInvoiceItem(invDistDetailData, itemNotesToLog,
                            notesToLog, poItems, orderData, conn, paramMap);
                } catch (Exception e) {
                    log.error("Error no order item found." + e.getMessage());
                    return 1;
                }

                if (homoGenResaleOrderFl) {
                    if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())) {
                        homoGenResaleOrderFl = false;
                    }
                }

                if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
                        || (RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
                        && RefCodeNames.EXCEPTION_ON_TAX_VALUE.YES_FOR_RESALE.equals(exceptOnTaxDiffValue))) {
                    {
                        BigDecimal amt = Utility.getBestCostFromInvoiceDistDetail(invDistDetailData);
                        amt = amt.multiply(new BigDecimal(invDistDetailData.getDistItemQuantity()));
                        subTotal = Utility.addAmt(subTotal, amt);
                    }
                }
            }

            ////////////////////////////////////////////////////////////////////////////

            BigDecimal taxable = subTotal;
            if (taxable == null) {
                taxable = invoice.getSubTotal();
            }

            BigDecimal calcTax = TaxUtil.calculateTax(conn, new TaxQuery(taxable, orderData.getSiteId(), orderData.getAccountId(), invoice.getStoreId()));

            old code ***/

            // SVC_Avatax => new code: begin

            //int siteId = orderData.getSiteId() != null ? orderData.getSiteId() : 0;
            BigDecimal siteIdBd = new BigDecimal(orderData.getSiteId());
            int siteId = 0;
            if (null != siteIdBd) {
                siteId = siteIdBd.intValue();
            }
            AddressData sad; // shipping address
            sad = TaxUtilAvalara.getShipTo(conn, siteId); // Shipping address for the site
            APIAccess distApiAccess = new APIAccess();
            Distributor distributorEjb = distApiAccess.getDistributorAPI();
            APIAccess siteApiAccess = new APIAccess();
            Site siteEjb = siteApiAccess.getSiteAPI();

// New code Avalara Tax. YR
            BigDecimal taxTotal = ZERO;
            HashMap<String,AvalaraTaxEntry> addressItemsMap = new HashMap<String,AvalaraTaxEntry>();
            boolean homoGenResaleOrderFl = true;
            try {
                homoGenResaleOrderFl = preCalculateInvoceAvalaraTax(
                        conn,
                        exceptOnTaxDiffValue,
                        invoice,
                        invoiceDistDetailDV,
                        orderData,
                        poItems,
                        itemNotesToLog,
                        notesToLog,
                        paramMap,
                        siteId,
                        sad,
                        distributorEjb,
                        siteEjb,
                        addressItemsMap);
            } catch (TaxCalculationException tcex) {
                return 1;
            } catch (Exception ex) {
                throw new Exception(ex);
            }
            if (!addressItemsMap.isEmpty()) {
                TaxUtilAvalara.calculateAvalaraTax(addressItemsMap);
                taxTotal = Utility.addAmt(taxTotal,
                                          TaxUtilAvalara.postCalculateAvalaraTax(addressItemsMap, null));
            }

// End of New code Avalara Tax. YR


// Old code Avalara Tax
//            Iterator it = invoiceDistDetailDV.iterator();
//            while (it.hasNext()) {
//                InvoiceDistDetailData invDistDetailData = (InvoiceDistDetailData) it.next();
//                OrderItemData oid = null;
//                try {
//                    invDistDetailData.setInvoiceDistId(invoice.getInvoiceDistId());
//                    invDistDetailData.setDistItemQtyReceived(invDistDetailData.getDistItemQuantity());
//                    oid = matchDistributorInvoiceItem(invDistDetailData, itemNotesToLog,
//                            notesToLog, poItems, orderData, conn, paramMap);
//                } catch (Exception e) {
//                    log.error("Error no order item found." + e.getMessage());
//                    return 1;
//                }
//
//                if (homoGenResaleOrderFl) {
//                    if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())) {
//                        homoGenResaleOrderFl = false;
//                    }
//                }
//
//                if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
//                        || (RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
//                        && RefCodeNames.EXCEPTION_ON_TAX_VALUE.YES_FOR_RESALE.equals(exceptOnTaxDiffValue)))
//                {
//                        BigDecimal amt = Utility.getBestCostFromInvoiceDistDetail(invDistDetailData);
//                        amt = amt.multiply(new BigDecimal(invDistDetailData.getDistItemQuantity()));
//
//                        // calculate Avatax:begin
//
//                  	    BigDecimal distributorId = new BigDecimal(invDistDetailData.getInvoiceDistId()); // item Distributor (inside one Catalog)
//                 	    log.info("Invoice Item " + invDistDetailData.getItemShortDesc() + " Distributor = " + distributorId);
//                 	    AddressData oad = new AddressData();
//
//                 	    //find the origin address for the invoice item
//                        if (null != distributorId) {
//                     	   DistributorData dd = distributorEjb.getDistributor(distributorId.intValue());
//                     	   oad = dd.getPrimaryAddress(); //or Billing Address ??? (both - from DB table CLW_ADDRESS)
//                        } else { // invoice item Distributor is NOT defined/found in the Cleanwise Database
//                     	   // find the Site address, to which the catalog is attached
//                           SiteData sd = siteEjb.getSite(siteId);
//                     	   oad = sd.getSiteAddress(); //site Address from DB table CLW_ADDRESS
//                        }
//
//                        // find Shipping (Destination) Address for the invoice item
//                        BigDecimal salesTax = ZERO;
//                        //log.info("Before instantiating the class TaxUtilAvalara.");
//                        TaxUtilAvalara taxutilavalara = new TaxUtilAvalara();
//                        //log.info("After instantiating the class TaxUtilAvalara.");
//                        amt = amt.setScale(2, BigDecimal.ROUND_HALF_UP);
//                        GetTaxResult getTaxResult = taxutilavalara.calculateAvatax(oad, sad, amt);
//                        if (getTaxResult.getResultCode() == SeverityLevel.Success)
//                        {
//                            //log.info("DocCode: " + getTaxRequest.getDocCode());
//                            // DocId is generated by AvaTax
//                            log.info("DocId: " + getTaxResult.getDocId());
//                            log.info("TotalAmount: " + getTaxResult.getTotalAmount().toString());
//                            log.info("TotalTax: " + getTaxResult.getTotalTax().toString());
//                            BigDecimal taxitem = getTaxResult.getTotalTax();
//                            taxTotal = Utility.addAmt(taxitem.setScale(2, BigDecimal.ROUND_HALF_UP), taxTotal);
//                            log.info("AvaTax calculated invoice item tax successfully!!!");
//                        }
//                        else
//                        {
//                            avatax_success = false;
//                     	    printMessages(getTaxResult.getMessages());
//                            log.info("Avatax: tax calculation for Invoice item = " + invDistDetailData.getItemShortDesc() + " failed!");
//                            throw new Exception("Avatax: tax calculation for Invoice item = " + invDistDetailData.getItemShortDesc() + " failed!");
//                        }
//
//                        // calculate Avatax:end
//
//                }    // if
//            }    // while
// End of Old code Avalara Tax

            BigDecimal calcTax = taxTotal;

            // SVC_Avatax => new code: end

            BigDecimal recvTax = invoice.getSalesTax();

            if (calcTax == null) {
                calcTax = ZERO;
            }
            if (recvTax == null) {
                recvTax = ZERO;
            }

            calcTax = calcTax.abs();
            recvTax = recvTax.abs();

            BigDecimal orderAmount = PipelineCalculationOperations.getTotalAmountWhithALLOperations(conn, poItems, orderData);
            BigDecimal invoiceAmount = invoice.getSubTotal();

            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  exceptOnTaxDiffValue  => " + exceptOnTaxDiffValue);
            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  homoGenResaleOrderFl  => " + homoGenResaleOrderFl);
//            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  subTotal  => " + subTotal);

            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  calcTax  => " + calcTax);
            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  recvTax  => " + recvTax);

            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  orderAmount  => " + orderAmount);
            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis]  invoiceAmount  => " + invoiceAmount);



            calcTax = calcTax.abs();
            recvTax = recvTax.abs();
            double taxDiff = calcTax.subtract(recvTax).abs().doubleValue();
            if (taxDiff > ADMISSIBLE_TAX_ERROR) { //allow for up to a 5 cent discrepency
                String mess = "Tax charged (" + recvTax.toString() + ") does not match calculated tax (" + calcTax.toString() + ").";
                log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis] ERROR => " + mess);
                notesToLog.add(mess);
            }


            if (homoGenResaleOrderFl) {
                if (!Utility.isZeroValue(calcTax)) {
                    exceptionCount++;
                    String mess = "Tax Order (" + calcTax.toString() + ") does not match 0";
                    log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis] ERROR => " + mess);
                    notesToLog.add(mess);
                }
                if (!Utility.isZeroValue(recvTax)) {
                    exceptionCount++;
                    String mess = "Tax Invoice (" + recvTax.toString() + ") does not match 0";
                    log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis] ERROR => " + mess);
                    notesToLog.add(mess);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            log.debug("[IntegrationServiceBean::invoiceDistTaxAnalysis] WARNING => checking of the invoice distributor tax is failed ");
            notesToLog.add("Error during sales tax check");
        }
        return exceptionCount;
    }


    private boolean preCalculateInvoceAvalaraTax(Connection pCon,
                                                 String exceptOnTaxDiffValue,
                                                 InvoiceDistData invoice,
                                                 InvoiceDistDetailDataVector invoiceDistDetailDV,
                                                 OrderData orderData,
                                                 OrderItemDataVector poItems,
                                                 List itemNotesToLog,
                                                 List notesToLog,
                                                 Map paramMap,
                                                 int siteId,
                                                 AddressData shippingAddress,
                                                 Distributor distributorEjb,
                                                 Site siteEjb,
                                                 HashMap<String,AvalaraTaxEntry> addressItemsMap)
            throws Exception, TaxCalculationException {

                boolean homoGenResaleOrderFl = true;
                Iterator it = invoiceDistDetailDV.iterator();
                while (it.hasNext()) {
                    InvoiceDistDetailData invDistDetailData = (InvoiceDistDetailData) it.next();
                    OrderItemData oid = null;
                    try {
                        invDistDetailData.setInvoiceDistId(invoice.getInvoiceDistId());
                        invDistDetailData.setDistItemQtyReceived(invDistDetailData.getDistItemQuantity());
                        oid = matchDistributorInvoiceItem(invDistDetailData, itemNotesToLog,
                                notesToLog, poItems, orderData, pCon, paramMap);
                    } catch (Exception e) {
                        log.error("Error no order item found." + e.getMessage());
                        throw new TaxCalculationException("Error while trying to find the order item data");
                    }

                    if (homoGenResaleOrderFl) {
                        if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())) {
                            homoGenResaleOrderFl = false;
                        }
                    }

                    if (!RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
                            || (RefCodeNames.ITEM_SALE_TYPE_CD.RE_SALE.equals(oid.getSaleTypeCd())
                            && RefCodeNames.EXCEPTION_ON_TAX_VALUE.YES_FOR_RESALE.equals(exceptOnTaxDiffValue)))
                    {
                            BigDecimal distributorId = new BigDecimal(invDistDetailData.getInvoiceDistId()); // item Distributor (inside one Catalog)
                            AddressData oad = new AddressData();

                                //find the origin address for the invoice item
                            if (null != distributorId) {
                               DistributorData dd = distributorEjb.getDistributor(distributorId.intValue());
                               oad = dd.getPrimaryAddress(); //or Billing Address ??? (both - from DB table CLW_ADDRESS)
                            } else { // invoice item Distributor is NOT defined/found in the Cleanwise Database
                               // find the Site address, to which the catalog is attached
                               SiteData sd = siteEjb.getSite(siteId);
                               oad = sd.getSiteAddress(); //site Address from DB table CLW_ADDRESS
                            }

                            if (!Utility.isSetForDisplay(oad.getAddress1()) &&
                                !Utility.isSetForDisplay(oad.getAddress2()) &&
                                !Utility.isSetForDisplay(oad.getAddress3()) &&
                                !Utility.isSetForDisplay(oad.getAddress4()) &&
                                !Utility.isSetForDisplay(oad.getPostalCode()) ) {
                                oad = shippingAddress;
                            }
                            BigDecimal amt = Utility.getBestCostFromInvoiceDistDetail(invDistDetailData);
                            amt = amt.multiply(new BigDecimal(invDistDetailData.getDistItemQuantity()));
                            amt = amt.setScale(2, BigDecimal.ROUND_HALF_UP);

                            AvalaraTaxItem item = new AvalaraTaxItem(Integer.toString(invDistDetailData.getDistLineNumber()),
                                                                     invDistDetailData.getDistItemSkuNum(),
                                                                     amt,
                                                                     invDistDetailData.getDistItemQuantity(),
                                                                     invDistDetailData.getDistItemShortDesc());
                            String addressStr = TaxUtilAvalara.addressToString(oad);
                            if (addressItemsMap.get(addressStr) == null) {
                                AvalaraTaxEntry entry = new AvalaraTaxEntry();
                                ArrayList<AvalaraTaxItem> items = new ArrayList<AvalaraTaxItem>();
                                items.add(item);
                                entry.setItems(items);
                                entry.setOriginAddress(oad);
                                entry.setShippingAddress(shippingAddress);
                                addressItemsMap.put(addressStr, entry);
                            } else {
                                addressItemsMap.get(addressStr).getItems().add(item);
                            }

                    }    // if
                }    // while

                return homoGenResaleOrderFl;
            }






    protected static void printMessages(ArrayOfMessage messages)
    {
        for (int ii = 0; ii < messages.size(); ii++)
        {
            Message message = messages.getMessage(ii);
            log.info(message.getSeverity().toString() + " " + ii + ": " + message.getSummary());
        }

    }

    public OrderItemData matchDistributorInvoiceItem(InvoiceDistDetailData invDetailD,
    		List itemNotesToLog,
    		List notesToLog,
    		OrderItemDataVector poItems,
    		OrderData matchOrder)     throws RemoteException{

    	return matchDistributorInvoiceItem(invDetailD,
    			itemNotesToLog, notesToLog, poItems, matchOrder, false);
    }
    public OrderItemData matchDistributorInvoiceItem(InvoiceDistDetailData invDetailD,
    		List itemNotesToLog,
    		List notesToLog,
    		OrderItemDataVector poItems,
    		OrderData orderData,
    		boolean usePoLineNumForInvoiceMatch) throws RemoteException {
        // Validate that we have the fields needed to look up the
        // order item record.  If not, set flag so we won't
        // try to look the record up.
        int poLineNumber = invDetailD.getErpPoLineNum();
        int cwSku = invDetailD.getItemSkuNum();
        String vendorSku = invDetailD.getDistItemSkuNum();
        boolean haveRequiredFields = true;
        int exceptionCount = 0;
        OrderItemDataVector itemsMatch = null;
        String notes = null;

        // check if both cw sku and vendor sku are missing
        if (cwSku == 0 && !Utility.isSet(vendorSku)) {
            haveRequiredFields = false;
            itemNotesToLog.add("Missing System Sku and Vendor Sku.");
            exceptionCount++;
        }

        OrderItemData itemMatch = null;

        if(haveRequiredFields){
        	// match po line number is usePoLineNumForInvoiceMatch = true
        	if (usePoLineNumForInvoiceMatch){
        		itemsMatch = getOrderItemByPoLineNumber(poLineNumber, poItems);
        	}else{
	            // First try to match on po line number and one of the SKUs.
	            // This will try to match against either the cwSku or the
	            // vendorSku, in either the "main" or the sub fields in the
	            // database.
	            log("Searching by PO line and SKUs: poLine#=" + poLineNumber +
	                " System Sku=" + cwSku + " vendorSku=" + vendorSku);
	            itemsMatch = getOrderItemByPoLineNumberAndSku(poLineNumber, cwSku, vendorSku,poItems);
	            
	            // If we don't have the po line number or couldn't get a
	            // match on it, try just the SKU numbers without the po
	            // line number.
	            if (itemsMatch.size() == 0) {
	                itemsMatch = getOrderItemBySku(cwSku, vendorSku,
	                poItems);
	                log("Searching by SKUs: System Sku=" + cwSku + " vendorSku=" + vendorSku);
	            }
        	}            

            // At this point we *might* have some kind of match
            if (itemsMatch.size() == 1) {

                itemMatch = (OrderItemData)itemsMatch.get(0);
            } else if (itemsMatch.size() > 1) {

                notes = "Found multiple matching order item records.\n";
                notes += "Possible order item ids:";

                for (int x = 0; x < itemsMatch.size(); x++) {
                    notes += " " + ((OrderItemData)itemsMatch.get(x)).getOrderItemId();
                }

                itemNotesToLog.add(notes);
                exceptionCount++;
            }
        }
        if(exceptionCount > 0){
            log.error("Exception count greater than 0");
        }
        return itemMatch;
    }


    public InvoiceDistData insertInvoiceDistData(InvoiceDistData invoiceD, int exceptionCount, BigDecimal recvdTotal, List notesToLog, List insertedInvoices, boolean checkDuplInvoiceNum)
            throws RemoteException {
        Connection conn = null;
        try {
            conn = getConnection();
            return insertInvoiceDistData(conn, invoiceD, exceptionCount, recvdTotal, notesToLog, insertedInvoices, checkDuplInvoiceNum);
        }
        catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }
        finally {
            closeConnection(conn);
        }
    }


    public void insertDistributorInvoiceNotes(InvoiceDistData invoiceD, OrderData matchOrder, List notesToLog, Map miscInvoiceNotes)
            throws RemoteException {
        Connection conn = null;
        try {
            conn = getConnection();
            insertDistributorInvoiceNotes(conn, invoiceD, matchOrder, notesToLog, miscInvoiceNotes);
        }
        catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }
        finally {
            closeConnection(conn);
        }
    }

    public InvoiceDistDataVector existingInvoiceFound(String pInvoiceNum, String pErpPoNum, int pStoreId, List insertedInvoices)
    throws RemoteException {
        Connection conn = null;
        try {
            conn = getConnection();
            return existingInvoiceFound(pInvoiceNum, pErpPoNum, pStoreId, conn, insertedInvoices);
        }
        catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }
        finally {
            closeConnection(conn);
        }
     }


    public void insertInvoiceDistDetailAndProperties(InvoiceDistDetailDescDataVector toInsertItems,
                                                     int invoiceDistId,
                                                     OrderData order) throws RemoteException {
        Connection conn = null;
        try {
            conn = getConnection();
            insertInvoiceDistDetailAndProperties(conn, toInsertItems, invoiceDistId, order);
        }
        catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException(e.getMessage());
        }
        finally {
            closeConnection(conn);
        }
    }


    /**
     * Check that list contains needed type for prepare OrderGuide
     */
    private final static boolean isFlatOrderGuides(
            IntegrationRequestsVector list) {
        if (list != null && list.size() > 0) {
            for (int i = 0; i < list.size(); i++) {
                Object oo = list.get(i);
                if(!(oo instanceof IntegrationRequestData)) {
                    return false;
                }
                IntegrationRequestData irD = (IntegrationRequestData) list
                        .get(i);
                Object object = irD.getIntegrationRequest();
                if ((object instanceof FlatOrderGuideRequestView) == false) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Process OrderGuides from flat file.
     */
    private void processFlatOrderGuides(IntegrationRequestsVector list,
            Connection conn, Map paramMap, String pErpNum, IdVector pStoreIds,
            IdVector pAccountIds, IdVector pDistributorIds, int tradingPartnerId)
            throws RemoteException {
    	log.info("processFlatOrderGuides.");
    	log.info("JJJJJ: pStoreIds = " + pStoreIds);
    	log.info("HHHHH: pDistributorIds = " + pDistributorIds);
    	log.info("IIIII: tradingPartnerId = " + tradingPartnerId);
        final Map map = new TreeMap();
        final Set checkDuplicates = new HashSet();
        for (int i = 0; list != null && i < list.size(); i++) {
            IntegrationRequestData irD = (IntegrationRequestData) list.get(i);
            FlatOrderGuideRequestView flatOG = (FlatOrderGuideRequestView) irD
                    .getIntegrationRequest();
            irD.getIntegrationRequest();
            final PreparedOrderGuide item = processFlatOrderGuide(flatOG, tradingPartnerId, conn);
            Date date = item.flatOrder.getReleasedDate();
            String key = "SiteId:" + item.siteId + " ItemId:" + item.itemId
                    + " Released Date:" + date;
            if (checkDuplicates.contains(key) == true) {
                throw new RemoteException("Combination '" + key
                        + "' already using!");
            }
            checkDuplicates.add(key);
            key = date + "_" + item.siteId;
            List values = (List) map.get(key);
            if (values == null) {
                values = new ArrayList();
                map.put(key, values);
            }
            values.add(item);
        }
        savePreparedOrderGuides(map, conn);
    }

    /**
     * Found all needed data:siteId, catalogId, itemId
     * and prepare OrderGuides for store.
     */
    private PreparedOrderGuide processFlatOrderGuide(
            FlatOrderGuideRequestView value, int tradingPartnerId, Connection conn) throws RemoteException {
        try {
	        log.info("processFlatOrderGuide.");
            APIAccess factory = new APIAccess();
            final int busIds[] = factory.getTradingPartnerAPI()
                    .getBusEntityIds(tradingPartnerId,
                            RefCodeNames.TRADING_PARTNER_ASSOC_CD.STORE);
            IdVector pStoreIds = new IdVector();
            for (int i = 0; busIds != null && i < busIds.length; i++) {
                pStoreIds.add(new Integer(busIds[i]));
            }
            String errMsg = null;
            IdVector pAccountIds = new IdVector();
            /**
             * Find site by SiteRefNumber and TradingPartner's stores.
             */
            BusEntityDataVector pSiteData = getSitesFromEntityKey(value
                    .getSiteRefNumber(), pStoreIds, pAccountIds, tradingPartnerId, conn);
            int siteId = -1;
            if (pSiteData == null || pSiteData.size() == 0) {
                errMsg = "Site for ref.num. '" + value.getSiteRefNumber()
                        + "' + not found!";
            } else if (pSiteData.size() != 1) {
                errMsg = "Multiple sites found for ref.num. '"
                        + value.getSiteRefNumber() + "'!";
            } else {
                siteId = ((BusEntityData) pSiteData.get(0)).getBusEntityId();
            }
            checkErrorMessage(errMsg);
            /**
             * Found ItemId by Dist.Sku.Num
             */

            /*** Begin: new piece of code ***/

            /***
            DBCriteria dbC0 = new DBCriteria();
            dbC0.addEqualTo(ItemMappingDataAccess.ITEM_NUM, value
                    .getDistSkuNumber());
            dbC0.addEqualTo(ItemMappingDataAccess.ITEM_MAPPING_CD,
                    RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
            dbc0.addOneOf();
            ***/
            String selectDistSkuSql = "SELECT DISTINCT ITEM_ID " +
            //"FROM CLW_ITEM_MAPPING WHERE ITEM_NUM = '" + value.getDistSkuNumber() + "'" +
            "FROM CLW_ITEM_MAPPING WHERE ITEM_NUM = ? " +
            " AND ITEM_MAPPING_CD = 'ITEM_DISTRIBUTOR'" +
            " AND bus_entity_id in (SELECT BUS_ENTITY1_ID FROM clw_bus_entity_assoc where " +
            //"BUS_ENTITY2_ID = " +  pStoreIds.get(0) + " and bus_entity_assoc_cd = 'DISTRIBUTOR OF STORE')";
            "BUS_ENTITY2_ID = ?  and bus_entity_assoc_cd = 'DISTRIBUTOR OF STORE')";

            log.info("selectDistSku sql: "+selectDistSkuSql);

            PreparedStatement stm = conn.prepareStatement(selectDistSkuSql);
            stm.setString(1, value.getDistSkuNumber());
            stm.setInt(2, (Integer)pStoreIds.get(0));

            ResultSet rs = stm.executeQuery();

            IdVector ids = new IdVector();
            while (rs.next()) {
                Integer x = new Integer(rs.getInt(1));
                ids.add(x);
            }
            rs.close();
            stm.close();
            log.info("KKKKK: ids = " + ids);
            int itemId = -1;

            /*** End: new piece of code ***/

            DBCriteria dbC = new DBCriteria();

            /*** Old piece of code: Begin ***/
            /***
            dbC.addEqualTo(ItemMappingDataAccess.ITEM_NUM, value
                    .getDistSkuNumber());
            dbC.addEqualTo(ItemMappingDataAccess.ITEM_MAPPING_CD,
                    RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
            int itemId = -1;
            IdVector ids = ItemMappingDataAccess.selectIdOnly(conn,
                    ItemMappingDataAccess.ITEM_ID, dbC);
            ***/
            /*** Old piece of code: End ***/

            if (ids == null || ids.size() == 0) {
                errMsg = "Item with Dist.Sku '" + value.getDistSkuNumber()
                        + "' + not found!";
            } else if (ids.size() != 1) {
                errMsg = "Multiple items found for Man.Sku '"
                        + value.getDistSkuNumber() + "'!";
            } else {
                itemId = ((Integer) ids.get(0)).intValue();
            }
            checkErrorMessage(errMsg);
            /**
             * Found Catalog Id by ItemId and
             */
            dbC = new DBCriteria();
            dbC.addEqualTo(CatalogAssocDataAccess.BUS_ENTITY_ID, siteId);
            ids = CatalogAssocDataAccess.selectIdOnly(conn,
                    CatalogAssocDataAccess.CATALOG_ID, dbC);
            dbC = new DBCriteria();
            dbC.addOneOf(CatalogStructureDataAccess.CATALOG_ID, ids);
            dbC.addEqualTo(CatalogStructureDataAccess.ITEM_ID, itemId);
            int catalogId = -1;
            ids = CatalogStructureDataAccess.selectIdOnly(conn,
                    CatalogAssocDataAccess.CATALOG_ID, dbC);
            if (ids == null || ids.size() == 0) {
                errMsg = "Catalog with ItemId'" + itemId + "' + not found!";
            } else if (ids.size() != 1) {
                errMsg = "Multiple catalogs found for itemId'" + itemId + "'!";
            } else {
                catalogId = ((Integer) ids.get(0)).intValue();
            }
            checkErrorMessage(errMsg);
            return PreparedOrderGuide.createValue(value, siteId, itemId,
                    catalogId);
        } catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException("Process FlatOrderGuide problem.", e);
        }
    }

    /**
     * Check error message and throw exception if need.
     */
    private void checkErrorMessage(String errMsg) throws RemoteException {
        if (errMsg != null) {
            log.error(errMsg);
            throw new RemoteException(errMsg);
        }
    }

    /**
     * Save prepared OrderGuides.
     */
    private static void savePreparedOrderGuides(final Map map,
            final Connection conn) throws RemoteException {
        try {
            APIAccess factory = new APIAccess();
            OrderGuide orderGuide = factory.getOrderGuideAPI();
            Account accEjb = factory.getAccountAPI();
            final List[] lists = findSameOrderGuides(map.values());
            List orders = lists[0];
            List dates = lists[1];
            AccCategoryToCostCenterView categToCCView = null;
            for (int i = 0; i < orders.size(); i++) {
                final List val = (List) orders.get(i);
                final PreparedOrderGuide prepared = (PreparedOrderGuide) val
                        .get(0);
                if(Utility.isSet(prepared.flatOrder.getOrderGuideName())){
                	prepared.orderGuide.setShortDesc(prepared.flatOrder.getOrderGuideName());
                }else{
                	prepared.orderGuide.setShortDesc("SchOrder_"+ getNameOfOrderGuideByHash(val));
                }
                categToCCView = accEjb.refreshCategoryToCostCenterView(categToCCView, prepared.siteId);
                DBCriteria cr = new DBCriteria();
                cr.addEqualTo(OrderGuideDataAccess.SHORT_DESC,
                        prepared.orderGuide.getShortDesc());
                cr.addNotEqualTo(OrderGuideDataAccess.ORDER_GUIDE_TYPE_CD,
                        RefCodeNames.ORDER_GUIDE_TYPE_CD.DELETED);
                cr.addEqualTo(OrderGuideDataAccess.BUS_ENTITY_ID,prepared.siteId);
                IdVector ids = OrderGuideDataAccess.selectIdOnly(conn, cr);
                if (ids != null && ids.size() > 0) {
                    throw new RemoteException("OrderGuide '"
                            + prepared.orderGuide.getShortDesc()
                            + "' is used already!");
                }
                final OrderGuideData oGD = orderGuide
                        .addOrderGuide(prepared.orderGuide);
                for (int ii = 0; ii < val.size(); ii++) {
                    final PreparedOrderGuide item = (PreparedOrderGuide) val
                            .get(ii);
                    orderGuide.addItem(oGD.getOrderGuideId(), item.itemId,
                            item.flatOrder.getQuantity(), categToCCView);
                }
                Date[] alsoDates = (Date[]) dates.get(i);
                saveOrderSchedule(factory, prepared.siteId, oGD
                        .getOrderGuideId(), alsoDates);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException("Error in save of OrderGuide.", e);
        }

    }

    /**
     * Find the same OrderGuide, which have the same items & quantities, but
     * different release dates.
     */
    private static List[] findSameOrderGuides(Collection lists) {
        final List list1 = new ArrayList(lists);
        final List list2 = new ArrayList(lists);
        final List mainOrders = new ArrayList();
        final List mainDates = new ArrayList();
        boolean checked[] = new boolean[list1.size()];
        for (int i = 0; i < list1.size(); i++) {
            if (checked[i] == true) {
                continue;
            }
            final List orders = (List) list1.get(i);
            final List dates = new ArrayList();
            for (int i2 = 0; i2 < list2.size(); i2++) {
                if (equals(orders, (List) list2.get(i2))) {
                    Date date = ((PreparedOrderGuide) ((List) list2.get(i2))
                            .get(0)).flatOrder.getReleasedDate();
                    dates.add(date);
                    checked[i2] = true;
                }
            }
            mainOrders.add(orders);
            mainDates.add((Date[]) dates.toArray(new Date[dates.size()]));
        }
        return new List[] { mainOrders, mainDates };
    }

    /**
     * Get unique name of OrderGuide by its contents.
     */
    private static int getNameOfOrderGuideByHash(List list) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; list != null && i < list.size(); i++) {
            final PreparedOrderGuide item = (PreparedOrderGuide) list.get(i);
            sb.append(item.siteId + "," + item.itemId + ","
                    + item.flatOrder.getQuantity() + ";");
        }
        return sb.toString().hashCode();
    }

    /**
     * Compare two lists of items, to store in one OrderGuide if they equal.
     */
    private static boolean equals(List list1, List list2) {
        if (list1 == null || list2 == null || list1.size() == 0
                || list1.size() != list2.size()) {
            return false;
        }
        boolean checked1[] = new boolean[list1.size()];
        boolean checked2[] = new boolean[list1.size()];
        for (int i1 = 0; i1 < checked1.length; i1++) {
            PreparedOrderGuide item1 = (PreparedOrderGuide) list1.get(i1);
            for (int i2 = 0; i2 < checked2.length; i2++) {
                if (checked2[i2] == false) {
                    PreparedOrderGuide item2 = (PreparedOrderGuide) list2
                            .get(i2);
                    if (item1.itemId == item2.itemId
                            && item1.siteId == item2.siteId
                            && item1.flatOrder.getQuantity() == item2.flatOrder
                                    .getQuantity()) {
                        checked1[i1] = true;
                        checked2[i2] = true;
                        continue;
                    }
                }
            }
        }
        for (int i = 0; i < checked1.length; i++) {
            if ((checked1[i] && checked2[i]) == false) {
                return false;
            }
        }
        return true;
    }

    /**
     * Simple ValueObject class to help handle flat OrderGuides.
     */
    private static class PreparedOrderGuide {
        private final FlatOrderGuideRequestView flatOrder;

        private final OrderGuideData orderGuide = OrderGuideData.createValue();

        private final int siteId;

        private final int itemId;

        private PreparedOrderGuide(FlatOrderGuideRequestView flatOrder,
                int siteId, int itemId, int catalogId) {
            if (flatOrder == null) {
                throw new IllegalArgumentException(
                        "FlatOrderGuideRequestView can't be NULL!");
            }
            this.flatOrder = flatOrder;
            this.siteId = siteId;
            this.itemId = itemId;
        }

        private final static PreparedOrderGuide createValue(
                FlatOrderGuideRequestView flatOrder, int siteId, int itemId,
                int catalogId) {
            PreparedOrderGuide result = new PreparedOrderGuide(flatOrder,
                    siteId, itemId, catalogId);
            final Date curDate = new Date();
            result.orderGuide.setAddBy(flatOrder.getUserName());
            result.orderGuide.setAddDate(curDate);
            result.orderGuide.setModBy(flatOrder.getUserName());
            result.orderGuide.setModDate(curDate);
            result.orderGuide.setBusEntityId(siteId);
            result.orderGuide.setCatalogId(catalogId);
            result.orderGuide
                    .setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
            return result;
        }
    }

    /**
     * Save OrderSchedule
     */
    private static void saveOrderSchedule(APIAccess factory, int siteId,
            int orderGuideId, Date[] alsoDates) throws RemoteException {
        OrderScheduleJoin orderSchedule = OrderScheduleJoin.createValue();
        Site siteEjb = null;
        try {
            siteEjb = factory.getSiteAPI();
        } catch (com.cleanwise.service.api.APIServiceAccessException exc) {
            exc.printStackTrace();
            throw new RemoteException("No site Ejb pointer");
        }
        SiteData site = null;
        try {
            site = siteEjb.getSite(siteId);
        } catch (Exception exc) {
            throw new RemoteException(exc.getMessage());
        }
        orderSchedule.setEffDate(new Date());
        orderSchedule.setAlsoDates(alsoDates);
        orderSchedule.setSiteName(site.getBusEntity().getShortDesc());
        BusEntityData accountBusEntity = site.getAccountBusEntity();
        orderSchedule.setAccountName(accountBusEntity.getShortDesc());
        orderSchedule.setAccountId(accountBusEntity.getBusEntityId());
        orderSchedule.setOrderGuideId(orderGuideId);
        User userEjb = null;
        try {
            userEjb = factory.getUserAPI();
        } catch (com.cleanwise.service.api.APIServiceAccessException exc) {
            throw new RemoteException("No users Ejb pointer");
        }
        UserDataVector users = null;
        try {
            users = userEjb.getUsersCollectionByBusEntity(siteId, null);
        } catch (Exception exc) {
            throw new RemoteException(exc.getMessage());
        }
        if (users.size() == 0) {
            throw new RemoteException("Selected site has no users");
        }
        UserData user = (UserData) users.get(0);
        int userId = user.getUserId();
        orderSchedule.setSiteId(siteId);
        orderSchedule.setUserId(userId);
        orderSchedule.setUserFirstName(user.getFirstName());
        orderSchedule.setUserLastName(user.getLastName());
        orderSchedule.setOrderScheduleCd(RefCodeNames.ORDER_SCHEDULE_CD.PLACE_ORDER);
        orderSchedule
                .setOrderScheduleRuleCd(RefCodeNames.ORDER_SCHEDULE_RULE_CD.DATE_LIST);
        try {
            factory.getAutoOrderAPI().saveOrderSchedule(orderSchedule,
                    user.getUserName());
        } catch (com.cleanwise.service.api.APIServiceAccessException exc) {
            exc.printStackTrace();
            throw new RemoteException("No auto order Ejb pointer");
        }
    }

    /**
     * Send Invoice Notification by Order Id
     * @param pDistEdi856           order for notification
     * @throws RemoteException
     */
    private void send856Notification(EdiInp856View pDistEdi856)
            throws    RemoteException {

        Connection conn = null;

        try {
            conn = getConnection();
            send856Notification(conn, pDistEdi856) ;

        } catch (Exception e) {
            e.printStackTrace();
            throw new RemoteException("Error in save of sendOrderNotification.", e);
        }

        finally {
            closeConnection(conn);
        }
    }


    /**
     * Send Invoice Notification by Order Id
     * @param conn     current connection to DB
     * @param pDistEdi856  order for notification
     * @throws Exception
     */
    private void send856Notification(Connection conn, EdiInp856View pDistEdi856)
            throws Exception {

        log("send856Notification() => begin.pDistEdi856: "+pDistEdi856);

        EdiInp856ItemViewVector ediItems = pDistEdi856.getItems();
        if(ediItems==null || ediItems.size()==0) {
            log("send856Notification() => no matched items in edi 856");
            return;
        }

        Event eventEjb     = APIAccess.getAPIAccess().getEventAPI();
        Order orderEjb     = APIAccess.getAPIAccess().getOrderAPI();
        Account accountEjb = APIAccess.getAPIAccess().getAccountAPI();
        User userEjb       = APIAccess.getAPIAccess().getUserAPI();
//        Site siteEjb       = APIAccess.getAPIAccess().getSiteAPI();

        int orderId = pDistEdi856.getOrderId();
        if(orderId<=0) {
            return;
        }
        OrderData orderD = orderEjb.getOrder(orderId);
        int storeId = orderD.getStoreId();
        int accountId = orderD.getAccountId();
        int siteId = orderD.getSiteId();


        if (storeId <=0 || accountId <= 0 || siteId <=0) {
            return;
        }

        UserInfoDataVector users = userEjb.getUsersByRight(siteId, accountId, UserInfoData.USER_GETS_EMAIL_ORDER_SHIPPED);

        if (users != null && users.size() >0) {

            log("send856Notification() => BEGIN the sending email");

            String poNum        = pDistEdi856.getPurchOrderNum();
            String transaction  = pDistEdi856.getTransactionIdentifier();
            String orderProp    = "Order shipment notification received. Po Number: "+poNum+ " Transaction: "+transaction;
            String processName  = "SEND_856_EMAIL";


                DBCriteria dbc = new DBCriteria();
                dbc.addEqualTo(OrderPropertyDataAccess.ORDER_ID, orderId);
                dbc.addEqualTo(OrderPropertyDataAccess.SHORT_DESC,processName);
                dbc.addEqualTo(OrderPropertyDataAccess.CLW_VALUE,orderProp);

                IdVector orderPropertyIdV = OrderPropertyDataAccess.selectIdOnly(conn,dbc);
                if (orderPropertyIdV.size()==0) {                    
                    //for each user who is to receive the email, send a message
                    String fromAddress = accountEjb.getDefaultEmail(accountId, storeId);
                    Map<String, TemplateDataExtended> localeToTemplateMap = new HashMap();
                    //the shipping notification email requires different information than that supplied by
                    //the default order email object map, so retrieve that information now.
                    Map templateObjects = populateTemplateObjectMap(conn, orderId, pDistEdi856);
                    Iterator<UserInfoData> userIterator = users.iterator();
                    while (userIterator.hasNext()) {
                    	UserInfoData user = userIterator.next();
                    	if (Utility.isSet(user.getEmailData().getEmailAddress())) {
        	      	        String templateType = RefCodeNames.PROPERTY_TYPE_CD.SHIPPING_NOTIFICATION_EMAIL_TEMPLATE;
                    		//because the framework is set up to handle exceptions, call the email data generation
        	      	        //method that throws exceptions so the event can be reprocessed once the problem is resolved.
                    		Map<String, String> emailData = TemplateUtilities.generateEmailData(templateType, storeId, 
                    				accountId, orderId, user.getUserData().getPrefLocaleCd(),
                    				localeToTemplateMap, templateObjects);
                    		String subj = emailData.get(Constants.TEMPLATE_OUTPUT_EMAIL_SUBJECT);
                    		String message = emailData.get(Constants.TEMPLATE_OUTPUT_EMAIL_BODY);
    	              		log("send856Notification() => PO subject: \n\r" + subj);
    	              		log("send856Notification() => PO text: \n\r" + message);
    	              		EventEmailDataView eventEmailData = new EventEmailDataView();
    	              		eventEmailData.setToAddress(user.getEmailData().getEmailAddress());
    	              		eventEmailData.setFromAddress(fromAddress);
    	              		eventEmailData.setSubject(subj);
    	              		eventEmailData.setText(message);
    	              		FileAttach[] fileAttach = (new ApplicationsEmailTool()).fromFilesToAttachs(new File[0]);
    	              		eventEmailData.setAttachments(fileAttach);
    	              		eventEmailData.setEmailStatusCd(Event.STATUS_READY);
    	              		eventEmailData.setModBy("IntegrationServicesBean");
    	              		eventEmailData.setAddBy("IntegrationServicesBean");
    	              		EventData eventData = Utility.createEventDataForEmail();
    	              		EventEmailView eev = new EventEmailView(eventData, eventEmailData);
    	              		eventEjb.addEventEmail(eev, "IntegrationServicesBean");                    		
    	              		log("For order ID=" + orderId +
                                " Event has been created by CleanWise at " + Calendar.getInstance().getTime());
    	              		OrderPropertyData note = OrderPropertyData.createValue();
    	              		note.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.EVENT);
    	              		note.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
    	              		note.setShortDesc(processName);
    	              		note.setValue(orderProp);
    	              		note.setModBy("IntegrationServicesBean");
    	              		note.setAddBy("IntegrationServicesBean");
    	              		note.setOrderId(orderId);
    	              		orderEjb.addNote(note);
                    	}
                    	else {
                            log("send856Notification() => User " + user.getUserData().getUserId() + " has no email address defined.");
                    	}
                    }
                }
                else {
                    log("send856Notification() => Duplicated EDI 856");
                }
        }  else{
            log("send856Notification() => No users");
        }
        log("send856Notification() => END the sending email");
    }
    
    private Map populateTemplateObjectMap(Connection conn, int orderId, EdiInp856View pDistEdi856) throws Exception {
    	Map returnValue = new HashMap();
        Order orderEjb = APIAccess.getAPIAccess().getOrderAPI();
        OrderInfoDataView orderInfoData = orderEjb.getOrderInfoData(orderId);
        OrderInfoView orderInfo = orderInfoData.getOrderInfo();
        OrderDto orderDto = new OrderDto();
        orderDto.setOrderNumber(orderInfo.getOrderNum());
        orderDto.setPurchaseOrderNumber(pDistEdi856.getPurchOrderNum());
        DistributorDto distributorDto = new DistributorDto();
        distributorDto.setName(pDistEdi856.getDistName());
        orderDto.setDistributor(distributorDto);
        orderDto.setTrackingNumber(pDistEdi856.getTrackingNum());
        orderDto.setShipDate(pDistEdi856.getShipDate());
        orderDto.setOrderLocale(orderInfo.getLocaleCd());
        //retrieve the item information
        ItemInfoViewVector orderItems = orderInfoData.getItems();
        EdiInp856ItemViewVector ediItems = pDistEdi856.getItems();
        List<OrderItemDto> orderItemDtoList = new ArrayList<OrderItemDto>();
        Iterator ediItemIterator = ediItems.iterator();
        while (ediItemIterator.hasNext()) {
            EdiInp856ItemView ediItem = (EdiInp856ItemView) ediItemIterator.next();
            OrderItemDto orderItemDto = new OrderItemDto();
            String distSkuNum = ediItem.getDistSkuNum();            
            orderItemDto.setSku(distSkuNum);
            String skuName = "";
            if (Utility.isSet(distSkuNum)) {
            	Iterator orderItemIterator = orderItems.iterator();
                while (orderItemIterator.hasNext()) {
                    ItemInfoView orderItem = (ItemInfoView) orderItemIterator.next();
                    if(ediItem.getOrderItemId() == orderItem.getOrderItemId()){
                        skuName = orderItem.getItemName();
                        break;
                    }
                }
            }
            orderItemDto.setName(skuName);
            orderItemDto.setLineNumber(ediItem.getPurchOrderLineNum() + "");
            orderItemDto.setUnitOfMeasure(ediItem.getUom());
            orderItemDto.setQuantity(new BigDecimal(ediItem.getShippedQty()));

            List trackingNumList = ediItem.getTrackingNumList();
            String trackingNums = "";
            if(trackingNumList != null && trackingNumList.size() > 0) {
                int count = 0;
                Iterator trackingNumberIterator = trackingNumList.iterator();
                while (trackingNumberIterator.hasNext()) {
                   String tn = pDistEdi856.getCarrierName() + " " +(String)trackingNumberIterator.next();
                   count++;
                   if(count > 1) {
                       trackingNums += " " + tn;
                   } else {
                       trackingNums = tn;
                   }
                }
            }
            orderItemDto.setTrackingNumbers(trackingNums);
            orderItemDto.setOrderLocale(orderDto.getOrderLocale());
            orderItemDtoList.add(orderItemDto);
        }        
        orderDto.setItems(orderItemDtoList);
        AddressInfoView addressInfo = orderInfoData.getShippingAddress();
        AccountDto accountDto = new AccountDto();
        accountDto.setErpNumber(addressInfo.getAccountErpNum());
        orderDto.setAccount(accountDto);
        AddressDto shippingAddress = new AddressDto();
        shippingAddress.setStreet1(addressInfo.getStreetAddress());
        shippingAddress.setCity(addressInfo.getCity());
        shippingAddress.setState(addressInfo.getStateProvinceCd());
        shippingAddress.setPostalCode(addressInfo.getPostalCode());
        shippingAddress.setCountry(addressInfo.getCountry());
        orderDto.setShippingAddress(shippingAddress);
        AddressDto shipFromAddress = new AddressDto();
        shipFromAddress.setStreet1("");
        shipFromAddress.setCity(pDistEdi856.getShipFromCity());
        shipFromAddress.setState(pDistEdi856.getShipFromState());
        shipFromAddress.setPostalCode(pDistEdi856.getShipFromPostalCode());
        shipFromAddress.setCountry("");
        orderDto.setShipFromAddress(shipFromAddress);
        returnValue.put(Constants.TEMPLATE_EMAIL_MAP_KEY_ORDER, orderDto);
    	return returnValue;
    }

    private void send856ErrorNotification(Map<String, List<EdiInp856View>> pDistEdi856ByErrorMessage,
                                          TradingPartnerInfo pTraidingPartnerInfo,
                                          Connection pConn)
            throws Exception {

        log("send856ErrorNotification() => begin.pDistEdi856: "+pDistEdi856ByErrorMessage);
        String toAddress    = pTraidingPartnerInfo.getAllow856Email();

        if (!Utility.isSet(toAddress)) {
            return;
        }
        APIAccess factory = getAPIAccess();
        int storeId = 0;
        BusEntityDataVector entities = pTraidingPartnerInfo.getBusEntities();
        for (int i = 0; entities != null && i < entities.size(); i++) {
            BusEntityData busEntity = (BusEntityData) entities.get(i);
            if (RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT.equals(busEntity.getBusEntityTypeCd())) {
                storeId = BusEntityDAO.getStoreForAccount(pConn, busEntity.getBusEntityId());
                break;
            } else if (RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR.equals(busEntity.getBusEntityTypeCd())){
                storeId = BusEntityDAO.getStoreForDistributor(pConn, busEntity.getBusEntityId());
                break;
            }
        }
        Event eventEjb     = APIAccess.getAPIAccess().getEventAPI();

        log("send856ErrorNotification() => BEGIN the sending email");
        String subject      = "Ship Notice Error.";

        StringBuffer message = new StringBuffer();
        message.append("The eSpendwise OPS Support team has identified the following errors and needs your assistance to resolve and process the following:\n");
        message.append("\n");
        Iterator<Map.Entry<String, List<EdiInp856View>>> buffer =  pDistEdi856ByErrorMessage.entrySet().iterator();
        while (buffer != null && buffer.hasNext()) {
            Map.Entry<String, List<EdiInp856View>> item = buffer.next();
            String errorMessage = item.getKey();
            List<EdiInp856View> value = item.getValue();
            for (EdiInp856View pDistEdi856 : value) {
            	int ICN = pDistEdi856.getInterchangeControlNum();
            	int GCN = pDistEdi856.getGroupControlNum();
            	log.info(".send856ErrorNotification(): ICN = " + ICN);
            	log.info(".send856ErrorNotification(): GCN = " + GCN);
                message.append("Error: [Inbound 856] ").append(errorMessage)
                        .append(" ").append(pDistEdi856.getDistOrderNum())
                        .append("\n");
                message.append("GCN: ").append(GCN).append("\n");
                message.append("ICN: ").append(ICN).append("\n");
                message.append("\n");
            }
        }
        SimpleDateFormat sdf = new SimpleDateFormat("MMM dd HH:mm",
                Locale.US);
        message.append("Date: ").append(sdf.format(new Date()));
        message.append("\n\n");
        message.append("Upon resolution of the issue, please resend the transactions for processing.\n");
        message.append("\n");
        message.append("Thank you,\n");
	message.append("\n");
	message.append("OPS Support\n");
	message.append("eSpendwise, Inc.\n");

        String fromAddress = (storeId > 0) ? factory.getAccountAPI()
                .getDefaultEmail(0, storeId) : null;
        if (Utility.isSet(fromAddress) == false) {
            fromAddress = getIntegrationEmailAddress();
        }
        EventEmailDataView eventEmailData = new EventEmailDataView();
        eventEmailData.setToAddress(toAddress);
        eventEmailData.setFromAddress(fromAddress);
        eventEmailData.setSubject(subject);
        eventEmailData.setText(message.toString());

        eventEmailData.setEmailStatusCd(Event.STATUS_READY);
        eventEmailData.setModBy("IntegrationServicesBean");
        eventEmailData.setAddBy("IntegrationServicesBean");
        EventData eventData = Utility.createEventDataForEmail();
        EventEmailView eev = new EventEmailView(eventData, eventEmailData);
        eventEjb.addEventEmail(eev, "IntegrationServicesBean");

        log("send856ErrorNotification() => END the sending email");
    }

    private void log(String message) {
        log.info(message);
    }

    private final static void fillAdditionalInfo(
            OutboundEDIRequestData reqData, Connection conn)
            throws SQLException {
        fillCostCenters(reqData, conn);
        fillShipMethod(reqData, conn);
    }

    private final static void fillCostCenters(OutboundEDIRequestData reqData,
            Connection conn) throws SQLException {
        Map costCenters = new HashMap();
        OrderItemDataVector items = reqData.getOrderItemDV();
        for (int i = 0; items != null && i < items.size(); i++) {
            OrderItemData item = (OrderItemData) items.get(i);
            try {
                CostCenterData costCenter = CostCenterDataAccess.select(conn,
                        item.getCostCenterId());
                costCenters.put("" + item.getCostCenterId(), costCenter);
            } catch (DataNotFoundException dnfe) {
            }
        }
        reqData.setCostCenters(costCenters);
    }

    private final static void fillShipMethod(OutboundEDIRequestData reqData,
            Connection conn) throws SQLException {
        DBCriteria dbCr = new DBCriteria();
        dbCr.addEqualTo(OrderFreightDataAccess.ORDER_ID, reqData.getOrderD().getOrderId());
        OrderFreightDataVector data = OrderFreightDataAccess.select(conn, dbCr);
        if (data != null && data.size() > 0) {
            //OrderFreightData item = (OrderFreightData) data.get(0);
            //reqData.setShipMethod(item.getShortDesc());
        	reqData.setShipMethod(data);
        } else {
            reqData.setShipMethod(null);
        }
    }

    public TradingPartnerDescView getOutboundTradingProfileConfig(String erpNum
                                                                  ,int incommingProfileId,
                                                                  String setType,
                                                                  String entityType,
                                                                  String direction)  throws RemoteException {

        Connection conn = null;
        DBCriteria dbc;

        try {
            conn = getConnection();
            TradingPartner partnerEjb = APIAccess.getAPIAccess().getTradingPartnerAPI();

            int partnerId;
            if(setType.equals(RefCodeNames.EDI_TYPE_CD.TORDER_PROCESSING_OUT)
                    || setType.equals(RefCodeNames.EDI_TYPE_CD.TMANIFEST_OUT)) {
                entityType=null;
                log.debug("getOutboundTradingProfileConfig => looking for app tp");
                partnerId = getPartnerId(erpNum,0, entityType, conn, true,true);

            }else{
            	log.debug("getOutboundTradingProfileConfig => NOT  looking for app tp"+ " erpNum=" + erpNum+ " entityType=" + entityType+ " setType=" + setType);
                partnerId = getPartnerId(erpNum,0, entityType, conn, false, null, true, setType);
            }

            DBCriteria mapDbc = new DBCriteria();
            dbc = new DBCriteria();
            dbc.addEqualTo(TradingProfileDataAccess.TRADING_PARTNER_ID, partnerId);

            IdVector profileIds = TradingProfileDataAccess.selectIdOnly(conn, dbc);

            if (profileIds.size() == 0) {
            	log.debug("getOutboundTradingProfileConfig => Could not find profile for partner id: " + partnerId);
                return null;
            }

            dbc = new DBCriteria();

            if (profileIds.size() == 1) {
                dbc.addEqualTo(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, (Integer)profileIds.get(0));
                dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);

                mapDbc.addEqualTo(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, (Integer)profileIds.get(0));
                mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);
            } else {
                if (incommingProfileId > 0) {
                    dbc.addEqualTo(TradingProfileConfigDataAccess.INCOMING_TRADING_PROFILE_ID, incommingProfileId);
                    dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);

                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, incommingProfileId);
                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);
                } else {
                    dbc.addEqualTo(TradingProfileConfigDataAccess.SET_TYPE, setType);
                    dbc.addOneOf(TradingProfileConfigDataAccess.TRADING_PROFILE_ID, profileIds);

                    mapDbc.addEqualTo(TradingPropertyMapDataAccess.SET_TYPE, setType);
                    mapDbc.addOneOf(TradingPropertyMapDataAccess.TRADING_PROFILE_ID, profileIds);
                }
            }

            if(Utility.isSet(direction)){
                dbc.addEqualTo(TradingProfileConfigDataAccess.DIRECTION,direction);
                mapDbc.addEqualTo(TradingPropertyMapDataAccess.DIRECTION,direction);
               }
            mapDbc.addOrderBy(TradingPropertyMapDataAccess.ORDER_BY,true);


            log.debug("getOutboundTradingProfileConfig => sql::"+dbc.getWhereClause());
            TradingProfileConfigDataVector profileConfigDV = TradingProfileConfigDataAccess.select(conn, dbc);
            if (profileConfigDV.size() >= 1) {
                TradingPartnerDescView ret = TradingPartnerDescView.createValue();
                TradingProfileConfigData config = (TradingProfileConfigData)profileConfigDV.get(0);
                ret.setTradingProfileConfigData(config);
                ret.setTradingProfileData(partnerEjb.getTradingProfile(config.getTradingProfileId()));
                ret.setTradingPartnerData(partnerEjb.getTradingPartner(partnerId));
                ret.setTradingPropertyMapDataVector(TradingPropertyMapDataAccess.select(conn,mapDbc));
                return ret;
            } else {
            	log.debug("getOutboundTradingProfileConfig => Could not find TradingProfileConfigData.");
                return null;
            }
        } catch (Exception exc) {
            exc.printStackTrace();
            throw new RemoteException("Error.IntegrationServicesBean.getOutboundTradingProfileConfig()=> "+ exc.getMessage());
        } finally {
            closeConnection(conn);
        }
    }

    public String getErpNumByBusEntityId(int busEntityId) throws RemoteException {
    	Connection conn = null;
        try {
            conn = getConnection();
	    	if(busEntityId > 0){
	    		BusEntityData busEnt = BusEntityDataAccess.select(conn,busEntityId);
	            if(busEnt != null){
	                return busEnt.getErpNum();
	            }
	    	}
	    	return null;
        } catch (Exception exc) {
            exc.printStackTrace();
            throw new RemoteException("Error.IntegrationServicesBean.getErpNumByBusEntityId()=> "+ exc.getMessage());
        } finally {
            closeConnection(conn);
        }

    }

    private String getInvoiceCompositeKey(InvoiceNetworkServiceData item) {
        String key = item.getDistCenterNo() + ";" +
                     item.getInvoiceNumber() + ";" +
                     item.getInvoiceDate() + ";" +
                     item.getInvoiceType() + ";" +
                     item.getPoNumber() + ";" +
                     item.getTaxAmount();
        return key;
      }

    private boolean checkNscInvoiceForDupication(OrderPropertyDataVector pNotes, Connection conn,
          InvoiceDistData pInvoice, String pDistCenterName, String pInvoiceType,
          InvoiceDistDetailDataVector pInvoiceItems,
          HashMap pDbInvoiceHM)
    throws Exception
    {

        String invoiceNumber = pInvoice.getInvoiceNum();
        boolean isKeyEquals = false;
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");

        String invoiceNum = Utility.strNN(pInvoice.getInvoiceNum()).trim();
        String poNum = Utility.strNN(pInvoice.getErpPoNum()).trim();
        Date invDate  = pInvoice.getInvoiceDate();
        String invDateS = "";
        if(invDate!=null) {
            invDateS = sdf.format(invDate);
        }
        String key = invoiceNum+"*"+poNum+"*"+invDateS;
        LinkedList invLL = (LinkedList) pDbInvoiceHM.get(key);
        if(invLL==null) {
            return false;
        }

        for(Iterator iterDup =invLL.iterator(); iterDup.hasNext();) {
            pNotes.clear();
            InvoiceDistData idD = (InvoiceDistData) iterDup.next();
            BigDecimal freight = pInvoice.getFreight();
            BigDecimal tax = Utility.bdNN(pInvoice.getSalesTax());

            isKeyEquals =
                  (tax.subtract(idD.getSalesTax()).abs().doubleValue()<0.00999) ;

            if(!isKeyEquals) {
                continue; //No reason for futher actions
            }

            DBCriteria cr = new DBCriteria();
            cr.addEqualTo(OrderPropertyDataAccess.INVOICE_DIST_ID, idD.getInvoiceDistId());
            cr.addEqualTo(OrderPropertyDataAccess.INVOICE_DIST_DETAIL_ID,0);
            OrderPropertyDataVector orderPropertyDV = OrderPropertyDataAccess.select(conn, cr);
            for(Iterator iter = orderPropertyDV.iterator(); iter.hasNext();) {
                OrderPropertyData opD = (OrderPropertyData) iter.next();
                String shortDesc = opD.getShortDesc();
                if(RefCodeNames.NETWORK_PROP_SHORT_DESC.DISTRIBUTION_CENTER_NAME.equals(shortDesc)) {
                    String val = Utility.strNN(opD.getValue());
                    if(!val.equals(pDistCenterName)) {
                      isKeyEquals = false;
                      break;
                    }
                }
                if(RefCodeNames.NETWORK_PROP_SHORT_DESC.INVOICE_TYPE.equals(shortDesc)) {
                    String val = Utility.strNN(opD.getValue());
                    if(!val.equals(pInvoiceType)) {
                        isKeyEquals = false;
                        break;
                    }
                }
            }

            if(!isKeyEquals) {
                continue;
            }

            BigDecimal fr = idD.getFreight();
            if (fr==null) fr = new BigDecimal(0);
            if (freight.subtract(fr).abs().doubleValue()>0.00999){
                  //Freight is different
                OrderPropertyData opD = new OrderPropertyData();
                String mess = "Found invoice with the same number but different freight: "+freight.setScale(2,BigDecimal.ROUND_HALF_UP)+
                        " != "+fr.setScale(2,BigDecimal.ROUND_HALF_UP);
                opD.setValue(mess);
                pNotes.add(opD);
            }
            //Check lines
            cr = new DBCriteria();
            cr.addEqualTo(InvoiceDistDetailDataAccess.INVOICE_DIST_ID, idD.getInvoiceDistId());
            InvoiceDistDetailDataVector iddV =InvoiceDistDetailDataAccess.select(conn, cr);

            for (int ii = 0; ii < pInvoiceItems.size(); ii++) {
                InvoiceDistDetailData item = (InvoiceDistDetailData) pInvoiceItems.get(ii);
                int lineNum = item.getDistLineNumber();
                boolean foundFl = false;
                for (Iterator iter=iddV.iterator(); iter.hasNext();) {
                    InvoiceDistDetailData iddD = (InvoiceDistDetailData)iter.next();
                    int ln = iddD.getDistLineNumber();
                    if(ln!=lineNum) {
                        continue;
                    }
                    if(!item.getDistItemSkuNum().equals(iddD.getDistItemSkuNum())) {
                        break;
                    }
                    if(item.getDistItemQtyReceived()!=iddD.getDistItemQtyReceived()) {
                        break;
                    }

                    if(Utility.bdNN(item.getItemReceivedCost())
                            .subtract(Utility.bdNN(iddD.getItemReceivedCost()))
                            .abs().doubleValue()>0.00999) {
                        OrderPropertyData opD = new OrderPropertyData();
                        String mess = "Found invoice with the same number but different price in line "+ln+
                                " ("+Utility.bdNN(item.getItemReceivedCost()).setScale(2,BigDecimal.ROUND_HALF_UP)+
                                " != "+Utility.bdNN(iddD.getItemReceivedCost()).setScale(2,BigDecimal.ROUND_HALF_UP);
                        opD.setValue(mess);
                        pNotes.add(opD);
                    }

                    if(Utility.bdNN(item.getLineTotal())
                            .subtract(Utility.bdNN(iddD.getLineTotal()))
                            .abs().doubleValue()>0.00999) {
                        OrderPropertyData opD = new OrderPropertyData();
                        String mess = "Found invoice with the same number but different line total in line "+ln+
                                " ("+Utility.bdNN(item.getLineTotal()).setScale(2,BigDecimal.ROUND_HALF_UP)+
                                " != "+Utility.bdNN(iddD.getLineTotal()).setScale(2,BigDecimal.ROUND_HALF_UP);
                        opD.setValue(mess);
                        pNotes.add(opD);
                    }
                    iter.remove();
                    foundFl = true;
                    break;
                }
                if(!foundFl) {
                    continue; //Line was not found
                }
                //     RefCodeNames.INVOICE_STATUS_CD.DUPLICATE:
                //    RefCodeNames.INVOICE_STATUS_CD.PENDING_REVIEW;
            }
            if(iddV.size()>0) {
                continue; //DB invoice has extra items
            }
            return true; //found invoice copy
        }
        return false; //
    }

    public void processInvoicesOfNetworkService(
            InvoiceNetworkServiceDataVector data, int storeId)
            throws RemoteException {
    	log.info("processInvoicesOfNetworkService.");
        Connection conn = null;
        String user = "Net Supply Inoice Loader";
        Map distMap = new TreeMap();
	if(data==null) data = new InvoiceNetworkServiceDataVector();
log.info("IntegrationServicesBean VVVVVVV data size: "+data.size());
        try {
            conn = getConnection();
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(BusEntityAssocDataAccess.BUS_ENTITY2_ID, storeId);
            dbc.addEqualTo(BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD,
                    RefCodeNames.BUS_ENTITY_ASSOC_CD.DISTRIBUTOR_STORE);
            IdVector allDistBusEntityIdV =
                    BusEntityAssocDataAccess.selectIdOnly(conn,BusEntityAssocDataAccess.BUS_ENTITY1_ID,dbc);
            dbc = new DBCriteria();
            dbc.addOneOf(PropertyDataAccess.BUS_ENTITY_ID,allDistBusEntityIdV);
            dbc.addEqualTo(PropertyDataAccess.SHORT_DESC,RefCodeNames.DISTRIBUTOR_TYPE_LABEL);
            dbc.addEqualTo(PropertyDataAccess.CLW_VALUE,RefCodeNames.DISTRIBUTOR_TYPE_CD.NATIONAL);
            IdVector distBusEntityIdV =
                    PropertyDataAccess.selectIdOnly(conn,PropertyDataAccess.BUS_ENTITY_ID,dbc);

            if(distBusEntityIdV.size()==0) {
                String errorMess = "Store doesn't have any distributors. Store Id: "+storeId;
                throw new Exception(errorMess);
            }
            if(distBusEntityIdV.size()>1) {
                String errorMess = "Store has multiple distributors when suppose to have only one. Store Id: "+storeId;
                throw new Exception(errorMess);
            }

            int distId = ((Integer) distBusEntityIdV.get(0)).intValue();
            for (Iterator iter= data.iterator(); iter.hasNext();) {
               InvoiceNetworkServiceData item =
                        (InvoiceNetworkServiceData) iter.next();
               String invoiceKey = getInvoiceCompositeKey(item);
               List list = (List) distMap.get(invoiceKey);
               if (list == null) {
                    list = new ArrayList();
                    distMap.put(invoiceKey, list);
                }
                list.add(item);
            }

            IdVector invoiceNumbers = new IdVector();
            HashSet invoiceNumbersHS = new HashSet();
            IdVector poNumbers = new IdVector();
            HashSet poNumbersHS = new HashSet();
            for(Iterator iter = distMap.entrySet().iterator(); iter.hasNext(); ) {
                Entry entry = (Entry) iter.next();
//                String invoiceNumber = (String) entry.getKey();
//                invoiceNumbers.add(invoiceNumber);
                List items = (List) entry.getValue();
                InvoiceNetworkServiceData item = (InvoiceNetworkServiceData) items.get(0);
                String invoiceNumber = item.getInvoiceNumber();
                if(!invoiceNumbersHS.contains(invoiceNumber)) {
                    invoiceNumbersHS.add(invoiceNumber);
                    invoiceNumbers.add(invoiceNumber);
                }
                String poNumber = item.getPoNumber();
                if(Utility.isSet(poNumber)) {
                    if(!poNumbersHS.contains(poNumber)) {
                        poNumbersHS.add(poNumber);
                        poNumbers.add(poNumber);
                    }
                }
            }
            DBCriteria cr = new DBCriteria();
            cr.addOneOf(InvoiceDistDataAccess.INVOICE_NUM,invoiceNumbers);
            //cr.addOneOf(InvoiceDistDataAccess.ERP_PO_REF_NUM,poNumbers);
            cr.addEqualTo(InvoiceDistDataAccess.BUS_ENTITY_ID, distId);
            cr.addEqualTo(InvoiceDistDataAccess.STORE_ID, storeId);

            //cr.addOrderBy(InvoiceDistDataAccess.INVOICE_DIST_ID);
            cr.addOrderBy(InvoiceDistDataAccess.INVOICE_NUM);
            cr.addOrderBy(InvoiceDistDataAccess.INVOICE_DATE);
            cr.addOrderBy(InvoiceDistDataAccess.ERP_PO_NUM);
            cr.addOrderBy(InvoiceDistDataAccess.SALES_TAX);

            InvoiceDistDataVector dbInvoiceDV = InvoiceDistDataAccess.select(conn,cr);
            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
            HashMap dbInvoiceHM = new HashMap();
            for(Iterator iter=dbInvoiceDV.iterator(); iter.hasNext();) {
                InvoiceDistData idD = (InvoiceDistData) iter.next();
                String invoiceNum = Utility.strNN(idD.getInvoiceNum()).trim();
                String poNum = Utility.strNN(idD.getErpPoNum()).trim();
                Date invDate  = idD.getInvoiceDate();
                String invDateS = "";
                if(invDate!=null) {
                    invDateS = sdf.format(invDate);
                }
                String key = invoiceNum+"*"+poNum+"*"+invDateS;
                LinkedList invLL = (LinkedList) dbInvoiceHM.get(key);
                if(invLL==null) {
                    invLL = new LinkedList();
                    dbInvoiceHM.put(key, invLL);
                }
                invLL.add(idD);
            }

            cr = new DBCriteria();
            cr.addOneOf(PurchaseOrderDataAccess.OUTBOUND_PO_NUM, poNumbers);
            cr.addEqualTo(PurchaseOrderDataAccess.STORE_ID,storeId);
            cr.addOrderBy(PurchaseOrderDataAccess.OUTBOUND_PO_NUM);
            PurchaseOrderDataVector poDV = PurchaseOrderDataAccess.select(conn, cr);



            int count = 0;
            int invQty = distMap.keySet().size();
            for (Iterator itInvoices = distMap.entrySet().iterator(); itInvoices.hasNext();) {
                Entry entry = (Entry) itInvoices.next();
                String key = (String) entry.getKey();
                List invoiceItems = (List) entry.getValue();
                InvoiceDistData idData = InvoiceDistData.createValue();
                OrderPropertyDataVector invoicePropDV = new OrderPropertyDataVector();
                InvoiceDistDetailDataVector idDetV = new InvoiceDistDetailDataVector();
                LinkedList invoiceDetPropLL = new LinkedList();
                String distCenterName = "";
                String invoiceType = "";
                String status = RefCodeNames.INVOICE_STATUS_CD.INVOICE_HISTORY;
                BigDecimal freight = new BigDecimal(0);
                for(int ii=0; ii<invoiceItems.size(); ii++) {
                    InvoiceNetworkServiceData item = (InvoiceNetworkServiceData) invoiceItems.get(ii);
                    if(ii==0) {
                        String poNum = item.getPoNumber();
                        if(Utility.isSet(poNum)) {
                            for(Iterator iter1=poDV.iterator(); iter1.hasNext();) {
                                PurchaseOrderData poD = (PurchaseOrderData) iter1.next();
                                int con = poNum.compareTo(poD.getOutboundPoNum());
                                if(con==0) {
                                    status = RefCodeNames.INVOICE_STATUS_CD.CLW_ERP_RELEASED;
                                    idData.setOrderId(poD.getOrderId());
                                    idData.setErpPoRefNum(poD.getErpPoRefNum());
                                    break;
                                }
                                if(con<0) {
                                    break;
                                }
                            }
                        }
                        idData.setInvoiceNum(item.getInvoiceNumber());
                        idData.setInvoiceDate(Utility.parseDate(item.getInvoiceDate(), "MM/dd/yyyy", false));
                        idData.setErpPoNum(poNum);
                        idData.setErpPoRefNum(poNum);
                        idData.setSalesTax(new BigDecimal(item.getTaxAmount()));
                        idData.setBusEntityId(distId);
                        idData.setStoreId(storeId);
                        idData.setAddBy(user);
                        idData.setModBy(user);
                        OrderPropertyData opD = new OrderPropertyData();
                        invoicePropDV.add(opD);
                        opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.DISTRIBUTION_CENTER_NO);
                        opD.setValue(item.getDistCenterNo());

                        opD = new OrderPropertyData();
                        invoicePropDV.add(opD);
                        distCenterName = item.getDistCenterName();
                        opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.DISTRIBUTION_CENTER_NAME);
                        opD.setValue(distCenterName);

                        opD = new OrderPropertyData();
                        invoicePropDV.add(opD);
                        opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.ACCOUNT_NUMBER);
                        opD.setValue(item.getAccountNumber());

                        opD = new OrderPropertyData();
                        invoicePropDV.add(opD);
                        opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.ACCOUNT_NAME);
                        opD.setValue(item.getAccountName());

                        opD = new OrderPropertyData();
                        invoicePropDV.add(opD);
                        invoiceType  = item.getInvoiceType();
                        opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.INVOICE_TYPE);
                        opD.setValue(invoiceType);


                    } //end of first item

                    String freightS = item.getFreightCharges();
                    if (Utility.isSet(freightS)) {
                        freight.add(new BigDecimal(freightS));
                    }
                    idData.setFreight(freight);

                    // Add individual invoice data.
                    InvoiceDistDetailData iddD =
                            InvoiceDistDetailData.createValue();
                    idDetV.add(iddD);

                    iddD.setDistLineNumber(Utility.parseInt(item.getLineNumber()));
                    String qtyS = item.getQuantity();
                    Double qtyDb = new Double(qtyS);
                    int qty = qtyDb.intValue();
                    iddD.setDistItemQuantity(qty);
                    iddD.setDistItemQtyReceived(qty);

                    iddD.setDistItemUom(item.getQuantityUnitOfMeasure());
                    iddD.setItemReceivedCost(new BigDecimal(item.getUnitPrice()));
                    iddD.setLineTotal(new BigDecimal(item.getExtendedPrice()));
                    iddD.setDistItemSkuNum(item.getProductNumber());
                    iddD.setInvoiceDistSkuNum(item.getProductNumber());
                    iddD.setDistItemShortDesc(item.getProductName());
                    iddD.setDistItemPack(item.getPack());
                    iddD.setAddBy(user);
                    iddD.setModBy(user);
                    // Add Invoice Dist Detail Properties
                    OrderPropertyDataVector opDV = new OrderPropertyDataVector();
                    invoiceDetPropLL.add(opDV);

                    OrderPropertyData opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.UNIT_PRICE_UNIT_OF_MEASURE);
                    opD.setValue(item.getUnitPriceOfMeasure());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.EXTENDED_WEIGHT);
                    opD.setValue(item.getExtendedWeight());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.PACK_SIZE);
                    opD.setValue(item.getPackSize());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.BRAND);
                    opD.setValue(item.getBrand());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.MANUFACTURER_NAME);
                    opD.setValue(item.getManufacturerName());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.MANUFACTURER_PRODUCT_NO);
                    opD.setValue(item.getManufacturerProductNo());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.RANDOM_WEIGHT_INDICATOR);
                    opD.setValue(item.getRandomWeightIndicator());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.SPLIT_CASE_INDICATOR);
                    opD.setValue(item.getSplitCaseIndicator());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.CATCH_WEIGHT_INDICATOR);
                    opD.setValue(item.getCatchWeightIndicator());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.SPLIT_CASE_UOM);
                    opD.setValue(item.getSplitCaseUOM());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.UPC);
                    opD.setValue(item.getUpc());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.DISCOUNTS);
                    opD.setValue(item.getDiscounts());

                    opD = new OrderPropertyData();
                    opDV.add(opD);
                    opD.setShortDesc(RefCodeNames.NETWORK_PROP_SHORT_DESC.DEVIATED_PRICE);
                    opD.setValue(item.getDeviatedPrice());

                }

                OrderPropertyDataVector notes = new OrderPropertyDataVector();
                boolean isDuplicatedFl = checkNscInvoiceForDupication(notes, conn,
                        idData,distCenterName, invoiceType,
                        idDetV,dbInvoiceHM);

               if(isDuplicatedFl) {
                   if(notes.isEmpty()) {
                       status = RefCodeNames.INVOICE_STATUS_CD.DUPLICATE;
                   } else {
                       status = RefCodeNames.INVOICE_STATUS_CD.PENDING_REVIEW;
                   }
               }

               idData.setInvoiceStatusCd(status);
               //Save invoice
               idData = InvoiceDistDataAccess.insert(conn, idData);
               int invoiceDistId = idData.getInvoiceDistId();
               int orderId = idData.getOrderId();
               for(Iterator iter = invoicePropDV.iterator(); iter.hasNext();) {
                   OrderPropertyData opD = (OrderPropertyData) iter.next();
                   opD.setInvoiceDistId(invoiceDistId);
                   if(orderId>0) {
                        opD.setOrderId(orderId);
                   }
                   opD.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                   opD.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.NETWORK_INVOICE);
                   opD.setAddBy(user);
                   opD.setModBy(user);
                   OrderPropertyDataAccess.insert(conn, opD);
               }
               //Save items
               for(int jj = 0; jj<idDetV.size(); jj++) {
                   InvoiceDistDetailData iddD = (InvoiceDistDetailData) idDetV.get(jj);
                   iddD.setInvoiceDistId(invoiceDistId);
                   iddD = InvoiceDistDetailDataAccess.insert(conn, iddD);
                   int iddId = iddD.getInvoiceDistDetailId();
                   int orderItemId = iddD.getOrderItemId();
                   OrderPropertyDataVector opDV =  (OrderPropertyDataVector) invoiceDetPropLL.get(jj);
                   for(Iterator iter = opDV.iterator(); iter.hasNext();) {
                       OrderPropertyData opD = (OrderPropertyData) iter.next();
                       opD.setInvoiceDistId(invoiceDistId);
                       opD.setInvoiceDistDetailId(iddId);
                       if(orderId>0) {
                            opD.setOrderId(orderId);
                       }
                       opD.setOrderItemId(orderItemId);
                       opD.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                       opD.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.NETWORK_INVOICE);
                       opD.setAddBy(user);
                       opD.setModBy(user);
                       OrderPropertyDataAccess.insert(conn, opD);
                   }
               }
               if(isDuplicatedFl && !notes.isEmpty()) {
                   for(Iterator iter = notes.iterator(); iter.hasNext();) {
                       OrderPropertyData opD = (OrderPropertyData) iter.next();
                       opD.setInvoiceDistId(invoiceDistId);
                       if(orderId>0) {
                            opD.setOrderId(orderId);
                       }
                       opD.setOrderPropertyStatusCd(RefCodeNames.ORDER_PROPERTY_STATUS_CD.ACTIVE);
                       opD.setOrderPropertyTypeCd(RefCodeNames.ORDER_PROPERTY_TYPE_CD.NETWORK_INVOICE_NOTE);
                       opD.setAddBy(user);
                       opD.setModBy(user);
                       OrderPropertyDataAccess.insert(conn, opD);
                   }
               }
               count++;
               log.info("IntegrationServicesBean VVVVVVVV +"+count+" ("+invQty+") invoices processed. Current" +
                        " invoice num: "+idData.getInvoiceNum());
            }

        } catch (Exception exc) {
            exc.printStackTrace();
            throw new RemoteException(exc.getMessage(), exc);
        } finally {
            closeConnection(conn);
        }
    }
/*
    private boolean isEqualInvoiceAttribute(String attrName, String attrValue,  boolean validateFlag,
            int invoiceDistId, Connection conn)  throws Exception{
      boolean isEqual = false;
      DBCriteria cr = new DBCriteria();
      cr.addEqualTo(OrderPropertyDataAccess.INVOICE_DIST_ID, invoiceDistId);
      cr.addEqualTo(OrderPropertyDataAccess.SHORT_DESC, attrName);
      cr.addEqualTo(OrderPropertyDataAccess.CLW_VALUE, attrValue);
      IdVector idV = null;
      if (validateFlag) {
        idV = OrderPropertyDataAccess.selectIdOnly(conn, cr);
        isEqual = (idV.size() > 0);
      }
      return isEqual;
    }
*/
    public void processSiteDelivery(SiteDeliveryUploadViewVector data,
             ErrorHolderViewVector errorHolder) throws RemoteException {
       processSiteDelivery(data, errorHolder, null);
    }

    public void processSiteDelivery(SiteDeliveryUploadViewVector data,
            ErrorHolderViewVector errorHolder, IdVector storeIds) throws RemoteException {
    	processSiteDelivery(data, errorHolder, null, "Network");
    }

    public void processSiteDelivery(SiteDeliveryUploadViewVector data,
            ErrorHolderViewVector errorHolder, IdVector storeIds, String pUser) throws RemoteException {
    	log.info("processSiteDelivery.");
        final int MAX_ITEMS_IN_CLAUSE = 1000;
        Connection conn = null;
        String user = pUser +" Site Delivery Loader";

        String accountPropName = RefCodeNames.PROPERTY_TYPE_CD.CUST_MAJ;
        String sitePropName = RefCodeNames.PROPERTY_TYPE_CD.SITE_REFERENCE_NUMBER;
        boolean isPollock = "Pollock".equals(pUser);
        if (isPollock){
          accountPropName = RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM;
          sitePropName = RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER;
        }
       try {
            conn = getConnection();
            final String storesIn = (storeIds == null || storeIds.isEmpty()) ? null : join(storeIds, ",");

            Map accountSiteIdMap = new TreeMap();
            //accountSiteIdMap represent all the distinct siteIds of each account in the data.
            for (int i = 0; data != null && i < data.size(); i++) {
                SiteDeliveryUploadView item = (SiteDeliveryUploadView) data.get(i);
            	if (item != null ) {
                    String key = (isPollock)? item.getAccountRefNum() :item.getCustomerMajorAccount();
                    Set accountSiteIds = (HashSet) accountSiteIdMap.get(key);
                    if (accountSiteIds == null) {
                    	accountSiteIds = new HashSet();
                    	accountSiteIdMap.put(key, accountSiteIds);
                    }
                    String siteRefNum = (isPollock)? item.getSiteRefNum() : item.getCustomerMinorSite();
                    accountSiteIds.add("'" + siteRefNum + "'");
                }
            }
            Map accountSiteIdListMap = new TreeMap();
            Set siteIdsBuffer = new HashSet();
            final Iterator itaccountSiteIdMap = accountSiteIdMap.entrySet().iterator();
            //if an account have more than MAX_ITEMS_IN_CLAUSE siteIds, then
            //subsets siteid to sets of MAX_ITEMS_IN_CLAUSE siteIds .
            while (itaccountSiteIdMap.hasNext()) {
            	Entry entry = (Entry) itaccountSiteIdMap.next();
                Set accountAllSiteIds = (HashSet) entry.getValue();
                String accountsId = (String)entry.getKey();

                List siteIdsList = (ArrayList) accountSiteIdListMap.get(accountsId);
                if (siteIdsList == null) {
                	siteIdsList = new ArrayList();
                	accountSiteIdListMap.put(accountsId, siteIdsList);
                }

                if(accountAllSiteIds.size() > MAX_ITEMS_IN_CLAUSE){
                	Iterator it = accountAllSiteIds.iterator();
                	Set buffer2 = new HashSet();
                	int i = 1;
                	while(it.hasNext()){
                		if(i>MAX_ITEMS_IN_CLAUSE){
                			siteIdsList.add(buffer2);
                			buffer2 = new HashSet();
                			i =1;
                		}
                		buffer2.add(it.next());
                		i++;
                	}
                	if(buffer2.size()>0){
                		siteIdsList.add(buffer2);
                	}

                }else{
                	siteIdsList.add(accountAllSiteIds);
                }
            }
            Map refsToSite = new HashMap();
            Set existAccRefNum = new HashSet();
            final Iterator itaccountSiteIdListMap = accountSiteIdListMap.entrySet().iterator();
            while (itaccountSiteIdListMap.hasNext()) {
            	Entry entry = (Entry) itaccountSiteIdListMap.next();
            	List siteIdList = (ArrayList) entry.getValue();
                String accountsIn = (String)entry.getKey();
                boolean isAccountIn = Utility.isSet(accountsIn);
                for(int i =0; isAccountIn && i< siteIdList.size(); i++){
                	Set siteIds = (Set)siteIdList.get(i);
                    String sitesIn = join(siteIds, ",");
                    String sql = "SELECT DISTINCT bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY1_ID
                            + " site_id, bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY2_ID
                            + " account_id, sp."
                            + PropertyDataAccess.CLW_VALUE
                            + " site_ref_num, ap."
                            + PropertyDataAccess.CLW_VALUE
                            + " acc_ref_num ";
//                            + " cust_maj ";
                    if (storesIn != null) {
                    	sql += ", bea2.bus_entity2_id store_id ";
                    }
                    sql += " FROM "
                            + BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC
                            + " bea "
                            + "JOIN "
                            + PropertyDataAccess.CLW_PROPERTY
                            + " sp ON bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY1_ID
                            + " = sp."
                            + PropertyDataAccess.BUS_ENTITY_ID
                            + " "
                            + "AND sp."
                            + PropertyDataAccess.SHORT_DESC
                            + " = ? "
                            //+ sitePropName
                            //+ "' "
                            + "AND sp." + PropertyDataAccess.CLW_VALUE
                            + " IN (" + sitesIn + ") " + "JOIN "
                            + PropertyDataAccess.CLW_PROPERTY + " ap ON bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY2_ID
                            + " = ap." + PropertyDataAccess.BUS_ENTITY_ID + " "
                            + "AND ap." + PropertyDataAccess.SHORT_DESC
                            //+ " = '" + accountPropName
                            + " = ? "
                            + "AND ap.clw_value in ('" + accountsIn
                            + "') "
                            + "JOIN "
                            + BusEntityDataAccess.CLW_BUS_ENTITY
                            + " be ON be."
                            + BusEntityDataAccess.BUS_ENTITY_ID
                            + " = bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY1_ID
                            + " "
                            + "AND be."
                            + BusEntityDataAccess.BUS_ENTITY_STATUS_CD
                            + " <> '"
                            + RefCodeNames.BUS_ENTITY_STATUS_CD.INACTIVE + "' ";

                    if (storesIn != null) {
						sql += "JOIN CLW_BUS_ENTITY_ASSOC bea2 ON "
								+ "bea2.BUS_ENTITY1_ID = bea.BUS_ENTITY2_ID AND "
								+ "bea2."
								+ BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD
								+ " = '"
								+ RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE
								+ "' AND " + "bea2.bus_entity2_id IN ("
								+ storesIn + ") ";
					}
                    sql += " WHERE bea."
                            + BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD
                            + " = '"
                            + RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT
                            + "'";
                    PreparedStatement st = conn.prepareStatement(sql);
                    st.setString(1, sitePropName);
                    st.setString(2, accountPropName);
                    ResultSet rs = st.executeQuery();
                    int siteId = -1;
                    //int accountId = -1;
                    String siteRefNum = "";
                    String accRefNum = "";
                    while (rs.next()) {
                        siteId = rs.getInt(1);
                        //accountId = rs.getInt(2);
                        siteRefNum = rs.getString(3);
                        accRefNum = rs.getString(4);
                        existAccRefNum.add(accRefNum);
                        Object val = refsToSite.put(accRefNum + "_" + siteRefNum,
                                new Integer(siteId));
                        if (val != null) {
                            throw new Exception(
                                    "Duplicate combination: " + accountPropName +":"
                                            + accRefNum + " and " + sitePropName + ":"
                                            + siteRefNum);
                        }
                    }
                    rs.close();
                    st.close();
                }
            }
            if (existAccRefNum.size() > 0) {
                DBCriteria cr = new DBCriteria();
                cr.addOneOf(SiteDeliveryDataAccess.CUST_MAJ, new ArrayList(existAccRefNum));
                cr.addEqualTo(SiteDeliveryDataAccess.STATUS_CD, RefCodeNames.SITE_DELIVERY_STATUS_CD.ACTIVE);
                SiteDeliveryDataVector existItems = SiteDeliveryDataAccess.select(conn, cr);
                Map existData = new HashMap();
                for (int i = 0; existItems != null && i < existItems.size(); i++) {
                    SiteDeliveryData existItem = (SiteDeliveryData) existItems.get(i);
                    String key = existItem.getCustMaj() + "_"
                            + existItem.getSiteRefNum() + "_"
                            + existItem.getYear() + "_" + existItem.getWeek()
                            + "_" + existItem.getDeliveryDay();
                    existData.put(key, existItem);
                }
                SiteDeliveryDataVector preparedForUpdate = new SiteDeliveryDataVector();
                for (int i = 0; i < data.size(); i++) {
                    SiteDeliveryUploadView item = (SiteDeliveryUploadView) data.get(i);
                    String accountRefNum = (isPollock)? item.getAccountRefNum() :item.getCustomerMajorAccount();
                    String siteRefNum = (isPollock)? item.getSiteRefNum() :item.getCustomerMinorSite();

                    String siteIdentifKey = accountRefNum + "_" + siteRefNum;
                    Integer siteId = (Integer) refsToSite.get(siteIdentifKey);
                    if (siteId == null) {
                        errorHolder.add(new ErrorHolderView("WARNING",
                                "Not found BUS_ENTITY (reference site) for " +accountPropName+":"
                                        + accountRefNum
                                        + " AND " + sitePropName +":"
                                        + siteRefNum));
                    }
                    for (int day = 1; day <= 7; day++) {
                        String key = siteIdentifKey + "_"
                                + item.getYear() + "_" + item.getWeek() + "_"
                                + day;

                        SiteDeliveryData sdOrigData = null;
                        SiteDeliveryData sdData = (SiteDeliveryData) existData.remove(key);

                        if (sdData == null) {
                            sdData = SiteDeliveryData.createValue();
                            sdData.setAddBy(user);
                            sdData.setCustMaj(accountRefNum);
                            sdData.setSiteRefNum(siteRefNum);
                            sdData.setYear(item.getYear());
                            sdData.setWeek(item.getWeek());
                            sdData.setDeliveryDay(day);
                        } else{
                            sdOrigData = (SiteDeliveryData) sdData.clone();
                            sdOrigData.setSiteDeliveryId(sdData.getSiteDeliveryId());
                        }

                        sdData.setModBy(user);
                        if (siteId != null) {
                            sdData.setBusEntityId(siteId.intValue());
                        }
                        int cutoffDay = item.getCutoffDay1();
                        String cutoffSiteTime = item.getCutoffSiteTime1();
                        String cutoffSystemTime = item.getCutoffSystemTime1();
                        boolean deliveryFlag = "Y".equals(item
                                .getDeliveryFlag1());
                        Date deliveryDate = item.getDeliveryDate1();
                        Date cutoffDate = item.getCutoffDate1();
                        switch (day) {
                        case 2:
                            cutoffDay = item.getCutoffDay2();
                            cutoffSiteTime = item.getCutoffSiteTime2();
                            cutoffSystemTime = item.getCutoffSystemTime2();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag2());
                            deliveryDate = item.getDeliveryDate2();
                            cutoffDate = item.getCutoffDate2();
                            break;
                        case 3:
                            cutoffDay = item.getCutoffDay3();
                            cutoffSiteTime = item.getCutoffSiteTime3();
                            cutoffSystemTime = item.getCutoffSystemTime3();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag3());
                            deliveryDate = item.getDeliveryDate3();
                            cutoffDate = item.getCutoffDate3();
                            break;
                        case 4:
                            cutoffDay = item.getCutoffDay4();
                            cutoffSiteTime = item.getCutoffSiteTime4();
                            cutoffSystemTime = item.getCutoffSystemTime4();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag4());
                            deliveryDate = item.getDeliveryDate4();
                            cutoffDate = item.getCutoffDate4();
                            break;
                        case 5:
                            cutoffDay = item.getCutoffDay5();
                            cutoffSiteTime = item.getCutoffSiteTime5();
                            cutoffSystemTime = item.getCutoffSystemTime5();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag5());
                            deliveryDate = item.getDeliveryDate5();
                            cutoffDate = item.getCutoffDate5();
                            break;
                        case 6:
                            cutoffDay = item.getCutoffDay6();
                            cutoffSiteTime = item.getCutoffSiteTime6();
                            cutoffSystemTime = item.getCutoffSystemTime6();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag6());
                            deliveryDate = item.getDeliveryDate6();
                            cutoffDate = item.getCutoffDate6();
                            break;
                        case 7:
                            cutoffDay = item.getCutoffDay7();
                            cutoffSiteTime = item.getCutoffSiteTime7();
                            cutoffSystemTime = item.getCutoffSystemTime7();
                            deliveryFlag = "Y".equals(item.getDeliveryFlag7());
                            deliveryDate = item.getDeliveryDate7();
                            cutoffDate = item.getCutoffDate7();
                            break;
                        }
                        sdData
                                .setStatusCd(RefCodeNames.SITE_DELIVERY_STATUS_CD.ACTIVE);
                        sdData.setCutoffDay(cutoffDay);
                        sdData.setCutoffSiteTimeSource(cutoffSiteTime);
                        sdData.setCutoffSystemTimeSource(cutoffSystemTime);

                        Calendar c = new GregorianCalendar();
                        String timeFormat = "HH:mm";
                        if (cutoffSiteTime != null && cutoffSiteTime.length() == 8)
                        	timeFormat = "HH:mm:ss";
                        Date cutoffSiteDate = Utility.parseDate(cutoffSiteTime,
                        		timeFormat, false);
                        Date cutoffSystemDate = Utility.parseDate(
                                cutoffSystemTime, timeFormat, false);
                        boolean wasWrong = false;
                        String line = "Line # " + (i + 1) + ") " + ((isPollock)? "AccountRefNum" :"CustMaj") +":"
                                + sdData.getCustMaj() + " SiteRefNum:"
                                + sdData.getSiteRefNum() + " Year:"
                                + sdData.getYear() + " Week:"
                                + sdData.getWeek() + " Day:" + day;
                        if (deliveryFlag == true) {
                            if ((sdData.getCutoffDay() >= 1 && sdData
                                    .getCutoffDay() <= 7) == false) {
                                errorHolder
                                        .add(new ErrorHolderView(
                                                "WARNING",
                                                "Incorrect cutoff day ->"
                                                        + sdData.getCutoffDay()
                                                        + ", must be in range [1-7] for:"
                                                        + line));
                                wasWrong = true;
                            }
                            if (cutoffSiteDate == null) {
                                errorHolder
                                        .add(new ErrorHolderView(
                                                "WARNING",
                                                "Incorrect value ->"
                                                        + cutoffSiteTime
                                                        + "< of Cutoff Site Time  for: "
                                                        + line));
                                wasWrong = true;
                            }
                            if (cutoffSystemDate == null) {
                                errorHolder
                                        .add(new ErrorHolderView(
                                                "WARNING",
                                                "Incorrect value ->"
                                                        + cutoffSystemTime
                                                        + "< of Cutoff System Time for: "
                                                        + line));
                                wasWrong = true;
                            }
                        }
                        if (wasWrong) {
                            continue;
                        }
                        if (cutoffSiteDate == null) {
                            sdData.setCutoffSiteTime(null);
                        } else {
                            if (cutoffDate != null){
                            	sdData.setCutoffSiteTime(Utility.getDateTime(cutoffDate, cutoffSiteDate));
                            }else{
                            	c.setTime(cutoffSiteDate);                                
                            	sdData.setCutoffSiteTime(getCutoffDate(sdData
                                    .getYear(), sdData.getWeek(), sdData
                                    .getDeliveryDay(), sdData.getCutoffDay(), 
                                    c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), c.get(Calendar.SECOND)));
                            }
                        }
                        if (cutoffSystemDate == null) {
                            sdData.setCutoffSystemTime(null);
                        } else {
                        	if (cutoffDate != null){
                            	sdData.setCutoffSystemTime(Utility.getDateTime(cutoffDate, cutoffSystemDate));
                            }else{
	                            c.setTime(cutoffSystemDate);
	                            sdData.setCutoffSystemTime(getCutoffDate(sdData
                                    .getYear(), sdData.getWeek(), sdData
                                    .getDeliveryDay(), sdData.getCutoffDay(), 
                                    c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE), c.get(Calendar.SECOND)));
                            }
                        }
                        if (deliveryDate != null){
                        	sdData.setDeliveryDate(deliveryDate);
                        }else{
                        	sdData.setDeliveryDate(getDeliveryDate(
                                sdData.getYear(), sdData.getWeek(), sdData
                                        .getDeliveryDay()));
                        }
                        sdData.setDeliveryFlag(deliveryFlag);
                        

                        //only this fields might be chaged because of the other fields are unique
                        if (sdOrigData == null ||
                                !Utility.strNN(sdData.getCutoffSiteTimeSource()).equals(Utility.strNN(sdOrigData.getCutoffSiteTimeSource())) ||
                                !Utility.strNN(sdData.getCutoffSystemTimeSource()).equals(Utility.strNN(sdOrigData.getCutoffSystemTimeSource())) ||
                                !Utility.strNN(sdData.getStatusCd()).equals(Utility.strNN(sdOrigData.getStatusCd())) ||
  								sdData.getBusEntityId() != sdOrigData.getBusEntityId() ||
                                sdData.getCutoffDay() != sdOrigData.getCutoffDay() ||
                                !sdData.getCutoffSiteTime().equals(sdOrigData.getCutoffSiteTime()) ||
                                sdData.getDeliveryFlag() != sdOrigData.getDeliveryFlag()) {

                            preparedForUpdate.add(sdData);

                        }

                    }
                }

                Iterator itNotUsed = existData.values().iterator();
                while (itNotUsed.hasNext()) {
                    SiteDeliveryData notUsed = (SiteDeliveryData) itNotUsed.next();
                    if(!RefCodeNames.SITE_DELIVERY_STATUS_CD.INACTIVE.equals(notUsed.getStatusCd())){
                        notUsed.setStatusCd(RefCodeNames.SITE_DELIVERY_STATUS_CD.INACTIVE);
                        notUsed.setModBy(user);
                        preparedForUpdate.add(notUsed);
                    }
                }

                for (int i = 0; i < preparedForUpdate.size(); i++) {
                    SiteDeliveryData sdData = (SiteDeliveryData) preparedForUpdate
                            .get(i);
                    if (sdData.getSiteDeliveryId() > 0) {
                        SiteDeliveryDataAccess.update(conn, sdData);
                    } else {
                        sdData = SiteDeliveryDataAccess.insert(conn, sdData);
                    }
                }
            } else {
                throw new RemoteException(
                        "Not found any BUS_ENTITY for " + accountPropName +": " + accountSiteIdListMap.keySet().toString()
                                + " & " + sitePropName +": " + accountSiteIdListMap.values().toString());
            }
        } catch (Exception exc) {
            exc.printStackTrace();
            throw new RemoteException(
                    "Error.IntegrationServicesBean.processSiteDelivery()=> "
                            + exc.getMessage());
        } finally {
            closeConnection(conn);
        }
    }

    private int getAlternativeCatalogId(int partnerId)
			throws NamingException, APIServiceAccessException, RemoteException {
    	int alterCatalogId = 0;
    	String catalogIdS = getTradingPropertyValue(partnerId, RefCodeNames.EDI_TYPE_CD.T855, "IN", "ALTERNATIVE_CATALOG_ID");
    	if (catalogIdS != null)
    		alterCatalogId = (new Integer(catalogIdS)).intValue();

		return alterCatalogId;
	}

    private String getTradingPropertyValue(int partnerId, String setType, String direction, String propertyName)
	throws NamingException, APIServiceAccessException, RemoteException {
		APIAccess factory = getAPIAccess();
		TradingPartner tradingPartnerEjb = factory.getTradingPartnerAPI();
		TradingProfileDataVector tProfileDV = tradingPartnerEjb.getTradingProfileByPartnerId(partnerId);
		TradingPartnerDescView configView = getTradingProfileConfig(((TradingProfileData)(tProfileDV.get(0))).getTradingProfileId(),setType, direction);
		if (configView != null){
			TradingPropertyMapDataVector v = configView.getTradingPropertyMapDataVector();
			Iterator ite = v.iterator();
			while(ite.hasNext()){
				TradingPropertyMapData data = (TradingPropertyMapData) ite.next();
				if(propertyName.equals(data.getPropertyTypeCd())){
					return data.getHardValue();
				}
			}
		}
		return null;
	}

	/**
     * Join collection's elements to one string.
     */
    private static String join(Collection collection, String delimiter) {
        if (collection == null || collection.size() == 0) {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        Iterator it = collection.iterator();
        while (it.hasNext()) {
            Object item = it.next();
            if (item == null) {
                continue;
            }
            if (sb.length() > 0) {
                sb.append(delimiter);
            }
            sb.append(item.toString());
        }
        return sb.toString();
    }

    /**
     * Calculate real cutoff date/time.
     */
    private final static Date getCutoffDate(int year, int week,
            int deliveryDay, int cutOffDay, int hours, int minutes, int second) {
        final Calendar c = new GregorianCalendar(year, Calendar.JANUARY, 1);
        int delta = c.get(Calendar.DAY_OF_WEEK) - 1;
        if (delta == 0) {
            //delta = 7;
        }
        c.add(Calendar.WEEK_OF_YEAR, week - 1);
        if (cutOffDay > deliveryDay) {
            c.add(Calendar.WEEK_OF_YEAR, -1);
        }
        c.add(Calendar.DAY_OF_YEAR, cutOffDay - 1 - delta);
        c.set(Calendar.HOUR_OF_DAY, hours);
        c.set(Calendar.MINUTE, minutes);
        c.set(Calendar.SECOND, second);
        return c.getTime();
    }

    /**
     * Calculate real delivery date/time.
     */
    private final static Date getDeliveryDate(int year, int week,
            int deliveryDay) {
        final Calendar c = new GregorianCalendar(year, Calendar.JANUARY, 1);
        int delta = c.get(Calendar.DAY_OF_WEEK) - 1;
        c.add(Calendar.WEEK_OF_YEAR, week - 1);
        c.add(Calendar.DAY_OF_YEAR, deliveryDay - delta - 1);
        return c.getTime();
    }

    class ItemInfo{
    	Connection conn = null;
    	int catalogId = 0;
    	int alterCatalogId = 0;
    	int itemId = 0;
    	int distId = 0;
    	String message;
    	boolean foundError = false;

    	ItemInfo(Connection conn, int partnerId, int siteId) throws Exception{
    		this.conn = conn;

    		Site siteEjb = getAPIAccess().getSiteAPI();
    		try{
    			catalogId = siteEjb.getShoppigCatalogIdForSite(siteId);
    		}catch(DataNotFoundException e){
    			log.info("No shopping catalog setup for site.  Continuing");
    		}
			alterCatalogId = getAlternativeCatalogId(partnerId);
			if(catalogId == 0 && alterCatalogId == 0){
				throw new RemoteException("No active shpping catalog setup for site: "+siteId+" and alternative catalog not set for trading partner");
			}
    	}
    	void reset(){
    		itemId = 0;
        	distId = 0;
        	message = null;
        	foundError = false;
    	}

    	ItemInfo getItemInfo(String distSku, String distUom, IdVector pDistributorIds, HashSet notesToLog) throws Exception{
    		reset();
    		ItemMappingDataVector imdv = new ItemMappingDataVector();
    		if(catalogId != 0){
    			imdv = getDistributorMappingForDistSku(conn,distSku, distUom, pDistributorIds, catalogId);
    		}
    		if (imdv.size() == 0){
				if (alterCatalogId > 0)
					imdv = getDistributorMappingForDistSku(conn,distSku, distUom, pDistributorIds, alterCatalogId);
			}

			//get the singular item id
			HashSet itemIds = new HashSet();
			HashSet distIds = new HashSet();
			Iterator it2 = imdv.iterator();
			while(it2.hasNext()){
				ItemMappingData map = (ItemMappingData) it2.next();
				itemId = map.getItemId();
				distId = map.getBusEntityId();
				Integer itemIdI = new Integer(map.getItemId());
				Integer distIdI = new Integer(map.getBusEntityId());
				if(!itemIds.contains(itemIdI)){
					itemIds.add(itemIdI);
				}
				if(!distIds.contains(distIdI)){
					distIds.add(distIdI);
				}
			}
			if(itemIds.size() == 0){
				String note = "No item found for distributor SKU = "+distSku + ", UOM=" + distUom + " in catalogId: " + catalogId;
				if (alterCatalogId > 0)
					note += " and alternative catalogId: " + alterCatalogId;
				notesToLog.add(note);
				message = note;
				foundError = true;
			}else if(itemIds.size() > 1){
				String note = "Multiple items found for distributor SKU = "+distSku + ", UOM=" + distUom + " in catalogId: " + catalogId;
				if (alterCatalogId > 0)
					note += " and alternative catalogId: " + alterCatalogId;
				notesToLog.add(note);
				message = note;
				foundError = true;
			}

			if(distIds.size() > 1){
				String note = "Multiple distributors found for distributor SKU = "+distSku + ", UOM=" + distUom + " in catalogId: " + catalogId;
				if (alterCatalogId > 0)
					note += " and alternative catalogId: " + alterCatalogId;
				notesToLog.add(note);
				message = note;
				foundError = true;
			}
    		return this;
    	}
    }

    public boolean isUniqCustomerPoNumber(String pCustPoNum) throws RemoteException {
        boolean result = true;
        Connection conn = null;
        try {
            conn = getConnection();
            DBCriteria dbc = new DBCriteria();
            dbc.addEqualTo(PreOrderDataAccess.CUSTOMER_PO_NUMBER, pCustPoNum);
            PreOrderDataVector v = PreOrderDataAccess.select(conn, dbc);
            result = (v.size() == 0);

        } catch (Exception exc) {
            log.error(exc);
            throw new RemoteException(exc.getMessage());
        } finally {
            closeConnection(conn);
        }
        return result;
    }
/*
    private static BigDecimal getDiscountByDistributorAndCatalog(Connection connection,
        int storeId, int catalogId, int distributorId, BigDecimal cost)
        throws SQLException, RemoteException {

    	log.info("***SVC(getDiscountByDistributorAndCatalog): storeId = " + storeId);
       	log.info("***SVC(getDiscountByDistributorAndCatalog): catalogId = " + catalogId);
       	log.info("***SVC(getDiscountByDistributorAndCatalog): distributorId = " + distributorId);
       	log.info("***SVC(getDiscountByDistributorAndCatalog): cost = " + cost);

        /// To get freight-tables by 'storeId' and 'distributorId'
        DBCriteria criteria = new DBCriteria();
        criteria.addEqualTo(FreightTableDataAccess.STORE_ID, storeId);
        criteria.addEqualTo(FreightTableDataAccess.DISTRIBUTOR_ID, distributorId);
        criteria.addOrderBy(FreightTableDataAccess.SHORT_DESC);
        FreightTableDataVector freightTables = FreightTableDataAccess.select(connection, criteria);

        if (freightTables == null || freightTables.size() == 0) {
            return null;
        }
        if (freightTables.size() == 1) {
            FreightTableData freightTable = (FreightTableData)freightTables.get(0);

            log.info("****SVC: calling getDiscountByFreightTable when freightTables.size() == 1");

            return getDiscountByFreightTable(connection, freightTable.getFreightTableId(), cost);
        }

        /// So we have more than one freight-tables for 'storeId' and 'distributorId'.
        if (catalogId <= 0) {
            throw new RemoteException("Multiple freight tables for store id " +
                storeId + " and distributor id " + distributorId);
        }

        /// To search freight-tables with 'catalogId' among 'freightTables'
        IdVector freightTableIds = new IdVector();
        for (int i = 0; i < freightTables.size(); ++i) {
            FreightTableData freightTable = (FreightTableData)freightTables.get(i);
            freightTableIds.add(new Integer(freightTable.getFreightTableId()));
        }
        criteria = new DBCriteria();
        criteria.addOneOf(ContractDataAccess.FREIGHT_TABLE_ID, freightTableIds);
        criteria.addEqualTo(ContractDataAccess.CATALOG_ID, catalogId);
        ContractDataVector contracts = ContractDataAccess.select(connection, criteria);

        if (contracts != null && contracts.size() == 1) {
            /// We found only one freight-table for 'storeId', 'catalogId' and 'distributorId'.
            ContractData contract = (ContractData)contracts.get(0);

            log.info("****SVC: calling getDiscountByFreightTable when contracts != null || contracts.size() == 1");

            return getDiscountByFreightTable(connection, contract.getFreightTableId(), cost);
        }
        if (contracts != null && contracts.size() > 1) {
            /// So we found more than one freight-tables for 'storeId', 'catalogId' and 'distributorId'.
            throw new RemoteException("Multiple freight tables for store id " +
                storeId + ", catalog id " + catalogId + " and distributor id " + distributorId);
        }

        /// So freight-tables for 'storeId' and for 'catalogId' and for 'distributorId' are not found.
        /// To search freight-tables among 'freightTables' which have not the relationship with any catalogs.
        criteria = new DBCriteria();
        criteria.addOneOf(ContractDataAccess.FREIGHT_TABLE_ID, freightTableIds);
        contracts = ContractDataAccess.select(connection, criteria);

        if (contracts == null || contracts.size() == 0) {
            /// So we found more than one freight-tables for 'storeId' and 'distributorId' which have not the relationship with any catalogs.
            throw new RemoteException("Multiple freight tables (which have not the relationship with any catalogs) for store id " +
                storeId + " and distributor id " + distributorId);
        }
        Integer freightTableIdResult = null;
        for (int i = 0; i < contracts.size(); ++i) {
            boolean notFound = true;
            ContractData contract = (ContractData)contracts.get(i);
            for (int j = 0; j < freightTables.size(); ++j) {
                FreightTableData freightTable = (FreightTableData)freightTables.get(j);
                if (contract.getFreightTableId() == freightTable.getFreightTableId()) {
                    notFound = false;
                    break;
                }
            }
            if (notFound) {
                if (freightTableIdResult == null) {
                    freightTableIdResult = new Integer(contract.getFreightTableId());
                } else {
                    /// So we found more than one freight-tables for 'storeId' and 'distributorId'
                    /// which have not the relationship with any catalogs.
                    throw new RemoteException("Multiple freight tables (which have not the relationship with any catalogs) for store id " +
                        storeId + " and distributor id " + distributorId);
                }
            }
        }
        if (freightTableIdResult == null) {
            return null;
        }
        return getDiscountByFreightTable(connection, freightTableIdResult.intValue(), cost);
    }
*/
    private static BigDecimal getDiscountByDistributorAndCatalog(Connection connection,
        int storeId, int catalogId, int distributorId, BigDecimal cost)
        throws SQLException, RemoteException {

		String sql =
			"SELECT ft.FREIGHT_TABLE_ID, ft.SHORT_DESC,  \n" +
			"		ft.FREIGHT_TABLE_STATUS_CD, ft.FREIGHT_TABLE_TYPE_CD,  \n" +
			"       ft.STORE_ID, ft.DISTRIBUTOR_ID, ft.FREIGHT_TABLE_CHARGE_CD,  \n" +
			"       c.CATALOG_ID  \n" +
			" FROM CLW_FREIGHT_TABLE ft  \n" +
			" LEFT JOIN CLW_CONTRACT c ON c.discount_table_id = ft.freight_table_id  \n" +
			" WHERE ft.DISTRIBUTOR_ID = "+ distributorId +"  \n" +
			" AND  ft.FREIGHT_TABLE_CHARGE_CD = 'DISCOUNT' \n" +
			" AND  ft.FREIGHT_TABLE_STATUS_CD = 'ACTIVE' \n";

    	log.info("****YK: SQL to pick discount table for the distributor: " + sql);

		Statement stmt = connection.createStatement();
	    ResultSet rs = stmt.executeQuery(sql);
		int nonCatalogFTCount = 0;
		int nonCatalogFreightTableId = 0;
		int catalogFreightTableId = 0;
		while (rs.next()) {
	        int catId = rs.getInt("CATALOG_ID");
			int ftId = rs.getInt("FREIGHT_TABLE_ID");
			if(catId == 0) {
				nonCatalogFTCount ++;
				nonCatalogFreightTableId = ftId;
			} else {
				if(catalogId == catId) {
					catalogFreightTableId = ftId;
				}
			}
		}
        rs.close();
        stmt.close();


        if (nonCatalogFreightTableId==0 && catalogFreightTableId==0) {
            return null;
        }
		if (catalogFreightTableId==0 && nonCatalogFTCount>1) {
            throw new RemoteException("Multiple freight tables for store id " +
                storeId + " and distributor id " + distributorId);
        }

		int freightTableId = catalogFreightTableId;

		if(freightTableId==0) freightTableId = nonCatalogFreightTableId;

		BigDecimal discountValue = getDiscountByFreightTable(connection, freightTableId, cost);
        return discountValue;
    }

    private static BigDecimal getDiscountByFreightTable(Connection connection,
        int freightTableId, BigDecimal cost) throws SQLException, RemoteException {

    	log.info("***SVC(getDiscountByFreightTable: freightTableId = " + freightTableId);
    	log.info("****SVC(getDiscountByFreightTable): cost = " + cost);

        FreightTableCriteriaDataVector freightCriterias = null;
        DBCriteria criteria = new DBCriteria();
        criteria.addEqualTo(FreightTableCriteriaDataAccess.FREIGHT_TABLE_ID, freightTableId);
        freightCriterias = FreightTableCriteriaDataAccess.select(connection, criteria);
        if (freightCriterias == null || freightCriterias.size() == 0) {
            return null;
        }
         return getDiscountByFreightTableCriterias(freightCriterias, cost); //commented by SVC until it is fixed
        //return null; // SVC
    }

    private static BigDecimal getDiscountByFreightTableCriterias(
        FreightTableCriteriaDataVector criterias, BigDecimal cost)
        throws SQLException, RemoteException {

    	log.info("***SVC(getDiscountByFreightTableCriterias): criterias.size() = " + criterias.size());
    	log.info("***SVC(getDiscountByFreightTableCriterias): criterias = " + criterias);
    	log.info("****SVC(getDiscountByFreightTableCriterias): cost = " + cost);

    	String freightDesc = null; // SVC

        if (criterias == null || criterias.size() == 0 || cost == null) {
            return null;
        }
        BigDecimal discountResult = null;
        boolean foundCriteria = false;
    	// SVC: missing => sort criteria by ShortDesc first; then compare the neighboring values
        for (int i = 0; i < criterias.size(); ++i) {
            FreightTableCriteriaData criteria = (FreightTableCriteriaData)criterias.get(i);
            if (criteria == null) {
                continue;
            }
            BigDecimal higherAmount = criteria.getHigherAmount();
            BigDecimal lowerAmount = criteria.getLowerAmount();
            if (higherAmount != null && higherAmount.longValue() > 0) {
                if (cost.compareTo(lowerAmount) > 0 && cost.compareTo(higherAmount) <= 0) {
                	// if (foundCriteria) { //SVC
                    if (foundCriteria && freightDesc.equals(criteria.getShortDesc())) { // SVC
                        throw new RemoteException("Multiple freight table criterias. Excessive freight table criteria id: " +
                            criteria.getFreightTableCriteriaId());
                    } else {
                        foundCriteria = true;
                        freightDesc = criteria.getShortDesc();
                        if (criteria.getDiscount() != null) {
                            discountResult = new BigDecimal(0);
                            discountResult = discountResult.add(criteria.getDiscount());
                        }
                    }
                }
            } else {
                if (cost.compareTo(lowerAmount) >= 0) {
                    if (foundCriteria) {
                        throw new RemoteException("Multiple freight table criterias. Excessive freight table criteria id: " +
                            criteria.getFreightTableCriteriaId());
                    } else {
                        foundCriteria = true;
                        if (criteria.getDiscount() != null) {
                            discountResult = new BigDecimal(0);
                            discountResult = discountResult.add(criteria.getDiscount());
                        }
                    }
                }
            }
        }
        return discountResult;
    }

    private int[] getContractAndCatalogIdBySiteId(Connection conn, int siteId) throws Exception{
    	Map itemIdPriceMap = new HashMap();
    	String selectSql = "select ct.contract_id, c.catalog_id" +
    			" from clw_catalog c, clw_catalog_assoc ca, clw_contract ct " +
    			"where ca.bus_entity_id = ? " +
    			"and c.catalog_id = ca.catalog_id " +
    			"and c.catalog_type_cd = 'SHOPPING' " +
    			"and c.catalog_status_cd = 'ACTIVE' " +
    			"and c.catalog_id = ct.catalog_id";
    	PreparedStatement pstmt = conn.prepareStatement(selectSql);
    	try {
    		pstmt = conn.prepareStatement(selectSql);
			pstmt.setInt(1, siteId);
			ResultSet rs = pstmt.executeQuery();
			if (rs.next()){
                int contractId = rs.getInt(1);
                int catalogId = rs.getInt(2);
                return new int[]{contractId, catalogId};
            }else{
				throw new RemoteException("Unable to get contract id for site id " + siteId);
			}
    	}finally{
    		pstmt.close();
    	}
    }

      private BigDecimal getContractItemPrice(Connection conn, int storeId, int siteId, int contractId, int catalogId, int itemId) throws Exception {
        try {
            BigDecimal price = ShoppingDAO.getContractItemPrice(conn,
                    storeId,
                    siteId,
                    contractId,
                    catalogId,
                    itemId);
            return price.setScale(2, BigDecimal.ROUND_HALF_UP);
        } catch (Exception e) {
            throw new RemoteException(e.getMessage());
        }
    }




    //***********************************************Manoj
    public void processSite(Connection conn, String siteloader, String siteActionAdd,String siteActionChange,
            String siteActionDelete, int storeNum,String tempTable) throws RemoteException{
boolean ifSiteExists;
//String busEntity_TyAcc = "ACCOUNT";
//String propertyShortDesc = "DIST_ACCT_REF_NUM";


//String propertyShortDescS = "SITE_REFERENCE_NUMBER";
//int storeID = 182241;

try{
    String selectNull = "select action,store_id,store_name,account_ref_num,site_name,site_ref_num," +
    "taxable,inventory_shopping_para,buyer_order_guide,address1,city,state,postal_code,country " +
    "from "+tempTable+" where add_by = ? " +
    "and (action is null " +
	"or store_id is null or store_name is null or account_ref_num is null or site_name is null " +
	"or site_ref_num is null or	taxable is null or inventory_shopping_para is null " +
	"or buyer_order_guide is null or address1 is null or city is null or state is null " +
	"or postal_code is null or country is null) ";

    String selectAcc = "select account_ref_num from "+tempTable+" where account_ref_num not in " +
    "(select clw_value from clw_property where bus_entity_id in " +
    "(select bus_Entity_id from clw_bus_entity where bus_entity_id in " +
    "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
    "and bus_entity_type_cd = ?) " +
    "and short_desc = ?) and add_by = ? " ;
   // "and action in(?,?)";

/*    String selectDistictAccA = "select distinct account_ref_num from clt_pollock_site_loader "+
    "where add_by = ? and action = ? and add_date >= trunc(sysdate)";*/

    String selectDistictAcc = "select distinct account_ref_num,site_ref_num, site_id, new_account_id, current_account_id from  "+tempTable+
    " where add_by = ? and action in(?,?) ";

  /*  String siteAction = "select distinct account_ref_num from clt_pollock_site_loader "+
    "where add_by = ? and action = ? and add_date >= trunc(sysdate)";*/

    String selectSiteSize = "select site_ref_num,site_name from  " + tempTable +
    		" where add_by = ?  and length(site_name) > 30";

    //Site to Inactivate
    String selectsiteInactivate = "select distinct account_ref_num,site_ref_num from  "+ tempTable +
    " where add_by = ? and action in(?) ";



	PreparedStatement pstmt = conn.prepareStatement(selectNull);
	pstmt.setString(1, siteloader);
	ResultSet rs = pstmt.executeQuery();
	int count = 0;
	boolean foundNull=false;
	StringBuffer missingData = new StringBuffer();
	while(rs.next()){
		foundNull = true;
		missingData.append(rs.getString(1));
		missingData.append(":");
		missingData.append(rs.getString(2));
		missingData.append(":");
		missingData.append(rs.getString(3));
		missingData.append(":");
		missingData.append(rs.getString(4));
		missingData.append(":");
		missingData.append(rs.getString(5));
		missingData.append(":");
		missingData.append(rs.getString(6));
		missingData.append(":");
		missingData.append(rs.getString(7));
		missingData.append(":");
		missingData.append(rs.getString(8));
		missingData.append(":");
		missingData.append(rs.getString(9));
		missingData.append(":");
		missingData.append(rs.getString(10));
		missingData.append(":");
		missingData.append(rs.getString(11));
		missingData.append(":");
		missingData.append(rs.getString(12));
		missingData.append(":");
		missingData.append(rs.getString(13));
		missingData.append(":");
		missingData.append(rs.getString(14));
		missingData.append("*************");
	}
	log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
	if (foundNull) {
		throw new IllegalArgumentException("Error Mandatory Field is null* action:store_id:store_name:" +
				"account_ref_num:site_name:site_ref_num:taxable:inventory_shopping_para:buyer_order_guide:" +
				"address1:city:state:postal_code:country" + missingData);
		//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
	} else{
		log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
	}
	pstmt.close();
	log.info("Check 2, check if any all accounts in spreadsheet exists  = " + selectAcc);

	pstmt = conn.prepareStatement(selectAcc);
	pstmt.setInt(1, storeNum);
	pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
	pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
	pstmt.setString(4, siteloader);
	//pstmt.setString(5, siteActionAdd);
	//pstmt.setString(6, siteActionChange);
	rs = pstmt.executeQuery();
	boolean foundMissingAccounts=false;
	StringBuffer missingAccounts = new StringBuffer();
	while(rs.next()){
		foundMissingAccounts = true;
		missingAccounts.append(rs.getString(1));
		missingAccounts.append(",");
	}

	if (foundMissingAccounts ) {
		throw new IllegalArgumentException("Could not find accounts using store id: "+storeNum+" and Dist Acc reference number: "+missingAccounts);
		//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
	} else{
		log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
	}
	pstmt.close();
	log.info("Check 3, check if size of site_name is greater then 30 Characters = " + selectSiteSize);

	pstmt = conn.prepareStatement(selectSiteSize);
	pstmt.setString(1, siteloader);
	rs = pstmt.executeQuery();
	boolean foundInvalidSiteSize=false;
	StringBuffer SiteSize = new StringBuffer();
	while(rs.next()){
		foundInvalidSiteSize = true;
		SiteSize.append(rs.getString(1));
		SiteSize.append(",");
		SiteSize.append(rs.getString(2));
		SiteSize.append("******");
	}
	if (foundMissingAccounts ) {
		throw new IllegalArgumentException("ERRORRRRRR site name is greater 30 character site_ref_num:site_name= "+SiteSize);
		//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
	} else{
		log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
	}
	pstmt.close();

	pstmt = conn.prepareStatement(selectDistictAcc);
	pstmt.setString(1, siteloader);
	pstmt.setString(2, siteActionAdd);
	pstmt.setString(3,siteActionChange);
	rs = pstmt.executeQuery();
	String accRefNum;
	String siteRefNum;
	String siteIdS;
	int newAccountId = 0;
	int currAccountId = 0;
	int siteId = 0;
	while(rs.next()){
		log.info("Check 4 Account ref num = " + rs.getString(1));
		accRefNum = rs.getString(1);
		siteRefNum = rs.getString(2);
		siteIdS = rs.getString(3);
		String newAccountIdS = rs.getString(4);
		String currAccountIdS = rs.getString(5);
		try {
            newAccountId = Integer.parseInt(newAccountIdS, 10);
            currAccountId = Integer.parseInt(currAccountIdS, 10);
            if (Utility.isSet(siteIdS)) {
                siteId = Integer.parseInt(siteIdS, 10);
            }
        } catch (Exception e) {
        }
		if (!Utility.isSet(siteIdS)) {
            currAccountId = newAccountId;
        }
		log.info("This is Account: = " + rs.getString(1) + "This is Siteeeeee:= " + rs.getString(2));
		log.info("SiteId="+siteIdS+" New Account Id="+newAccountId+" Current Account Id="+currAccountId);
		if (newAccountId == currAccountId) {
            ifSiteExists = siteCheck(siteloader,siteActionAdd,siteActionChange,siteActionDelete,storeNum,accRefNum,siteRefNum,conn,tempTable);
            log.info("PPPPPPPPPPPPPPPPPPPPPPTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" + ifSiteExists);
            if(ifSiteExists){
                log.info("TRRRRRRRRRRRRRRRRRUUUUUUUUUUUUUEEEEEEEEEEEEEEEE::::::::::UPDATE" + ifSiteExists);
                siteId = updateSite(siteloader,siteActionAdd,siteActionChange,siteActionDelete,storeNum,accRefNum,siteRefNum,conn,tempTable);

            } else {
                log.info("FAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLSSSSSSEEEEEEEEEEEEEEEE:::::::::: CREATE" + ifSiteExists);
                createSite(siteloader,siteActionAdd,siteActionChange,siteActionDelete,storeNum,accRefNum,siteRefNum,conn,tempTable);
            }
        } else {
                log.info("TRRRRRRRRRRRRRRRRRUUUUUUUUUUUUUEEEEEEEEEEEEEEEE::::::::::MOVE to another Account");
                moveSite(siteloader,storeNum,accRefNum,siteId, siteRefNum,currAccountId,newAccountId,conn,tempTable);
                log.info("TRRRRRRRRRRRRRRRRRUUUUUUUUUUUUUEEEEEEEEEEEEEEEE::::::::::UPDATE " + siteId);
                updateSite(siteloader,siteActionAdd,siteActionChange,siteActionDelete,storeNum,accRefNum,siteRefNum,conn,tempTable);
        }
	}
	pstmt.close();
	log.info("ACTionnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn  ===== " + siteActionAdd);

	pstmt = conn.prepareStatement(selectsiteInactivate);
	pstmt.setString(1, siteloader);
	pstmt.setString(2, siteActionDelete);
	rs = pstmt.executeQuery();
	while(rs.next()){
		log.info("Check 5555 Site to INACTIVATEEEEEEEEEEEEEEEEEEE acc_ref_num =" + rs.getString(1));
		log.info("Check 5555 Site to INACTIVATEEEEEEEEEEEEEEEEEEE site_ref_num =" + rs.getString(2));
		accRefNum = rs.getString(1);
		siteRefNum = rs.getString(2);
		inactivateSite(accRefNum,siteRefNum,storeNum,siteloader,conn);
	}
	pstmt.close();


}catch(Exception e){
e.printStackTrace();
//throw e;
   throw new RemoteException(
           "Error.IntegrationServicesBean.processSiteDelivery()=> "
                   + e.getMessage());
}finally{
if (conn != null)
	//conn.close();
	closeConnection(conn);
}
}
//****************

//////////**********************************
    public boolean siteCheck(String siteloader,String siteActionAdd,String siteActionChange,String siteActionDelete,
    int storeNum,String accRefNum,String siteRefNum, Connection conn, String tmpTableName) throws RemoteException{

        String selectCheckSite = "select count(*) from " + tmpTableName + " where add_by = ? " +
    	"and account_ref_num = ? and action in(?,?) " +
    	"and site_ref_num in " +
    	"(select clw_value from clw_property where short_desc = ? and clw_value = ?" +
    	"and bus_entity_id in " +
    	"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id in " +
    	"(select bus_entity_id from clw_property where short_desc = ? " +
    	"and clw_value = ? and bus_entity_id in(select bus_entity1_id " +
    	"from clw_bus_entity_assoc where bus_entity2_id = ?))))";

    	try{

    		int count = 0;
    		PreparedStatement pstmt1 = conn.prepareStatement(selectCheckSite);

			pstmt1.setString(1, siteloader);
			pstmt1.setString(2, accRefNum);
			pstmt1.setString(3, siteActionAdd);
			pstmt1.setString(4, siteActionChange);
			pstmt1.setString(5, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
			pstmt1.setString(6, siteRefNum);
			pstmt1.setString(7, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt1.setString(8, accRefNum);
			pstmt1.setInt(9,storeNum);
			ResultSet rs = pstmt1.executeQuery();
			while(rs.next()){
				count = rs.getInt(1);
			}
			pstmt1.close();
			log.info("SQQQQQQQQQLLLLLLLL to check " + selectCheckSite);
			log.info("siteloader =" + siteloader + "accRefNum =" + accRefNum + "siteActionAdd=" + siteActionAdd + "5=" + RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER + "6=" + RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM + "siteRefNum=" + siteRefNum);
			if (count > 0) {
				log.info("CHeck 44444444444444444 SITE ALREADY EXISTSSSSSSS UPDATEEEEE Return TRUE = " + accRefNum + "SITEEE REF num ==== " + siteRefNum);
				return true;
				//throw new IllegalArgumentException("Check 4 site name is greater then 30 characters = ");
			} else{
				log.info("Check 444444444444444 SITE DOES NOT EXISTS RETURN FALSE = " + count);
				return false;
			}





    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.siteCheck()=> "
                               + e.getMessage());
    	}
    }


    //**************************************

    public int createSite(String siteloader,String siteActionAdd,String siteActionChange,String siteActionDelete,int storeNum,String accountRefNum,String siteRefNum,Connection conn, String tmpTableName) throws RemoteException{

    	String accountName = "";
    	String siteName = "";
    	String taxableCd = "";
    	String invShop = "";
    	String buyerOrderGuide = "";
    	String firstName = "";
    	String lastName = "";
    	String address1Cd = "";
    	String address2Cd = "";
    	String address3Cd = "";
    	String address4Cd = "";
    	String cityCd = "";
    	String stateCd = "";
    	String postalCode = "";
    	String countryCd = "";
    	String shipMessage = "";
    	String ordComments = "";
    	String itemDisplayRestrict = "";
    	String storeID = "";
    	int busEntityId;
    	int accountId = 0;
    	int result = 0;
    	Date runDate = new Date();
    	String selectSql = "select account_name,site_name,taxable,inventory_shopping_para, " +
    	"buyer_order_guide,first_name,last_name,address1,address2,address3, " +
    	"address4,city,state,postal_code,country,ship_message,order_guide_comments,store_id,item_display_restrict " +
    	"from " + tmpTableName + " where add_by = ? "+
    	"and action in(?,?) and account_ref_num = ? and site_ref_num = ?";

    	String selectAccountId = "select b.bus_entity_id " +
    	"from CLW_BUS_ENTITY b, CLW_BUS_ENTITY_ASSOC ba, CLW_PROPERTY p " +
		"where b.bus_entity_id = ba.bus_entity1_id " +
		"and ba.bus_entity2_id = ? " +
		"and b.bus_entity_id = p.bus_entity_id " +
		"and p.short_desc = ? " +
		"and p.clw_value = ?";

    	String insertPropertySql = "Insert into clw_property (PROPERTY_ID,BUS_ENTITY_ID,USER_ID,SHORT_DESC," +
    	"CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY,LOCALE_CD) " +
		"values (clw_property_seq.NEXTVAL,?,null,?,?,'ACTIVE',?,sysdate,'" + siteloader + "',sysdate," +
		"'" + siteloader + "',null)";

     	try{
    		PreparedStatement pstmt = conn.prepareStatement(selectSql);
    		pstmt.setString(1, siteloader);
    		pstmt.setString(2, siteActionAdd);
			pstmt.setString(3, siteActionChange);
			pstmt.setString(4, accountRefNum);
			pstmt.setString(5, siteRefNum);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()) {

				accountName 	= rs.getString(1);
		    	siteName 		= rs.getString(2);
		    	taxableCd 		= rs.getString(3);
		    	invShop 		= rs.getString(4);
		    	buyerOrderGuide = rs.getString(5);
		    	firstName 		= rs.getString(6);
		    	lastName 		= rs.getString(7);
		    	address1Cd		= rs.getString(8);
		    	address2Cd 		= rs.getString(9);
		    	address3Cd 		= rs.getString(10);
		    	address4Cd 		= rs.getString(11);
		    	cityCd 			= rs.getString(12);
		    	stateCd 		= rs.getString(13);
		    	postalCode 		= rs.getString(14);
		    	countryCd 		= rs.getString(15);
		    	shipMessage 	= rs.getString(16);
		    	ordComments 	= rs.getString(17);
		    	storeID			= rs.getString(18);
		    	itemDisplayRestrict = rs.getString(19);

			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectAccountId);
			pstmt.setInt(1,storeNum);
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setString(3, accountRefNum);
			rs = pstmt.executeQuery();
			while(rs.next()) {
				accountId = rs.getInt(1);
			}
			pstmt.close();

			BusEntityData busEntityData = BusEntityData.createValue();
			busEntityData.setBusEntityStatusCd(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
			busEntityData.setWorkflowRoleCd("UNKNOWN");
			busEntityData.setLocaleCd("en_US");
			busEntityData.setAddBy(siteloader);
			busEntityData.setEffDate(runDate);
			busEntityData.setBusEntityTypeCd(RefCodeNames.BUS_ENTITY_TYPE_CD.SITE);
			busEntityData.setShortDesc(siteName);
			busEntityData = BusEntityDataAccess.insert(conn, busEntityData);
			busEntityId = busEntityData.getBusEntityId();
			busEntityData.setErpNum("#" + busEntityId);
			BusEntityDataAccess.update(conn, busEntityData);

			result = countryCd.compareToIgnoreCase("US");
			if(result == 0){
				countryCd = "UNITED STATES";
			}

			AddressData addressD = AddressData.createValue();
			addressD.setAddressStatusCd(RefCodeNames.ADDRESS_STATUS_CD.ACTIVE);
			addressD.setAddBy(siteloader);
			addressD.setPrimaryInd(true);
			addressD.setName1(firstName);
			addressD.setName2(lastName);
			addressD.setAddressTypeCd(RefCodeNames.ADDRESS_TYPE_CD.SHIPPING);
			addressD.setAddress1(address1Cd);
			addressD.setAddress2(address2Cd);
			addressD.setAddress3(address3Cd);
			addressD.setAddress4(address4Cd);
			addressD.setCity(cityCd);
			addressD.setStateProvinceCd(stateCd);
			addressD.setPostalCode(postalCode);
			addressD.setCountryCd(countryCd);
			addressD.setBusEntityId(busEntityId);
			addressD = AddressDataAccess.insert(conn, addressD);

//			log.info("[IntegrationServicesBean].updateSite() => check  :1111111111111");
			log.info("[IntegrationServicesBean].updateSite() => site_reference_num :=" + siteRefNum + "site_id := " + busEntityId + "Account_reference_num :=" + accountRefNum + "Account_id :=" + accountId );

			// create busEntityAssoc
			BusEntityAssocData busEntityAssocD = BusEntityAssocData.createValue();
			busEntityAssocD.setBusEntity1Id(busEntityId);
			busEntityAssocD.setBusEntity2Id(accountId);
			busEntityAssocD.setAddBy(siteloader);
			busEntityAssocD.setBusEntityAssocCd(RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT);
			busEntityAssocD = BusEntityAssocDataAccess.insert(conn, busEntityAssocD);


			//Create Property Data
			pstmt = conn.prepareStatement(insertPropertySql);
			pstmt.setInt(1, busEntityId);
			// site reference number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
			pstmt.setString(3, siteRefNum);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
			pstmt.addBatch();

			//Is Taxable
			result = taxableCd.compareToIgnoreCase("true");
			if(result == 0){
				taxableCd = "Y";
			}else {
				taxableCd = "N";
			}

			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR);
			pstmt.setString(3, taxableCd);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR);
			pstmt.addBatch();

			//Share buyer order guide
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES);
			pstmt.setString(3, buyerOrderGuide);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES);
			pstmt.addBatch();


			//Inv Shopping
			result = invShop.compareToIgnoreCase("true");
			if(result == 0){
				invShop = "on";
			}else {
				invShop = "off";
			}


			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING);
			pstmt.setString(3, invShop);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING);
			pstmt.addBatch();


			//Order Guide Comments

			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SITE_COMMENTS);
			pstmt.setString(3, ordComments);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Shipping Comments
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SITE_SHIP_MSG);
			pstmt.setString(3, shipMessage);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			String itemDisplayValue = "";
			String priceL = "P";
			String orderG= "O";

			if(itemDisplayRestrict == null || itemDisplayRestrict.equals("")){
				itemDisplayValue = "CATALOG";
			}else if(itemDisplayRestrict.equals(orderG)){
				itemDisplayValue = "ORDER_GUIDE";
			}else if(itemDisplayRestrict.equals(priceL)) {
				itemDisplayValue = "PRICE_LIST";
			}else{
				itemDisplayValue = "CATALOG";
			}
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SITE_PRODUCT_BUNDLE);
			pstmt.setString(3, itemDisplayValue);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();

                        return busEntityId;
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}

    }

    public int updateSite(String siteloader,String siteActionAdd,String siteActionChange,String siteActionDelete,int storeNum,String accountRefNum,String siteRefNum,Connection conn, String tmpTableName) throws RemoteException{
    	String accountName = "";
    	String siteName = "";
    	String taxableCd = "";
    	String invShop = "";
    	String buyerOrderGuide = "";
    	String firstName = "";
    	String lastName = "";
    	String address1Cd = "";
    	String address2Cd = "";
    	String address3Cd = "";
    	String address4Cd = "";
    	String cityCd = "";
    	String stateCd = "";
    	String postalCode = "";
    	String countryCd = "";
    	String shipMessage = "";
    	String ordComments = "";
    	String storeID = "";
    	String itemDisplayRestrict = "";
    	int busEntityId;
    	int accountId = 0;
    	int siteID = 0;

    	String sqlSiteSelect = "select bus_entity_id from clw_property " +
    	"where short_desc = ? and clw_value = ? " +
    	"and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id in " +
    	"(select bus_entity_id from clw_property where short_desc = ? and clw_value = ? " +
    	"and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)))";

    	//String catalogKeyFld = ("clt_nsc_site_loader".equalsIgnoreCase(tmpTableName))? ", catalog_key" : "";

        String selectSql = "select account_name,site_name,taxable,inventory_shopping_para, " +
    	"buyer_order_guide,first_name,last_name,address1,address2,address3, " +
    	"address4,city,state,postal_code,country,ship_message,order_guide_comments,store_id,item_display_restrict " +//catalogKeyFld+
    	"from " + tmpTableName + " where add_by = ? "+
    	"and action in(?,?) and account_ref_num = ? and site_ref_num = ?";

    	String updateBusEntity = "update clw_bus_entity set short_desc = ?,bus_entity_status_cd = ?," +
    			"mod_by=?,mod_date=sysdate where bus_entity_id = ?";

    	String updateAddress = "update clw_address set name1 = ?,name2 =?,address1=?,address2=?,address3=?," +
    			"address4=?,city=?,state_province_cd=?,country_cd=?,postal_code=?,mod_by=?,mod_date=sysdate " +
    			"where bus_entity_id = ?";

    	String updatePropertySql = "update clw_property set clw_value = ?,mod_by = ?,mod_date=sysdate " +
    			"where short_desc = ? " +
    			"and bus_entity_id = ?";

        String selectPropertySql = "select * from clw_property where short_desc = ? and bus_entity_id = ?";

    	String insertPropertySql = "Insert into clw_property (PROPERTY_ID,BUS_ENTITY_ID,USER_ID,SHORT_DESC," +
    	"CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY,LOCALE_CD) " +
		"values (clw_property_seq.NEXTVAL,?,null,?,?,'ACTIVE',?,sysdate,'" + siteloader + "',sysdate," +
		"'" + siteloader + "',null)";


    	try{

    		//PreparedStatement pstmt = conn.prepareStatement(selectSql);
    		log.info("[IntegrationServicesBean].updateSite() => check  :1111111111111");
		PreparedStatement pstmt = conn.prepareStatement(sqlSiteSelect);
		pstmt.setString(1, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
		pstmt.setString(2, siteRefNum);
		pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
		pstmt.setString(4, accountRefNum);
		pstmt.setInt(5, storeNum);

		ResultSet rs = pstmt.executeQuery();
		while(rs.next()){
			siteID = rs.getInt(1);
		}
		pstmt.close();
		log.info("[IntegrationServicesBean].updateSite() => check  :222222222222222222");
		pstmt = conn.prepareStatement(selectSql);
		pstmt.setString(1, siteloader);
		pstmt.setString(2, siteActionAdd);
		pstmt.setString(3, siteActionChange);
		pstmt.setString(4, accountRefNum);
		pstmt.setString(5, siteRefNum);
		rs = pstmt.executeQuery();
		while(rs.next()) {

			accountName 	= rs.getString(1);
	    	siteName 		= rs.getString(2);
	    	taxableCd 		= rs.getString(3);
	    	invShop 		= rs.getString(4);
	    	buyerOrderGuide = rs.getString(5);
	    	firstName 		= rs.getString(6);
	    	lastName 		= rs.getString(7);
	    	address1Cd		= rs.getString(8);
	    	address2Cd 		= rs.getString(9);
	    	address3Cd 		= rs.getString(10);
	    	address4Cd 		= rs.getString(11);
	    	cityCd 			= rs.getString(12);
	    	stateCd 		= rs.getString(13);
	    	postalCode 		= rs.getString(14);
	    	countryCd 		= rs.getString(15);
	    	shipMessage 	= rs.getString(16);
	    	ordComments 	= rs.getString(17);
	    	storeID			= rs.getString(18);
	    	itemDisplayRestrict = rs.getString(19);

		}
		pstmt.close();
		log.info("[IntegrationServicesBean].updateSite() =>  update BUS_ENTITY!!!!!!!! :3333333333333333");
		pstmt = conn.prepareStatement(updateBusEntity);
		pstmt.setString(1,siteName);
		pstmt.setString(2,RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
		pstmt.setString(3,siteloader);
		pstmt.setInt(4,siteID);
		pstmt.addBatch();
		pstmt.executeBatch();

		pstmt.close();

		log.info("[IntegrationServicesBean].updateSite() =>  UPDATE ADDRESS!!!!!!!! :444444444444444444444444");
		pstmt = conn.prepareStatement(updateAddress);
		pstmt.setString(1,firstName);
		pstmt.setString(2,lastName);
		pstmt.setString(3,address1Cd);
		pstmt.setString(4,address2Cd);
		pstmt.setString(5,address3Cd);
		pstmt.setString(6,address4Cd);
		pstmt.setString(7,cityCd);
		pstmt.setString(8,stateCd);
		pstmt.setString(9,countryCd);
		pstmt.setString(10,postalCode);
		pstmt.setString(11,siteloader);
		pstmt.setInt(12,siteID);
		pstmt.addBatch();

		pstmt.executeBatch();
		pstmt.close();


		log.info("[IntegrationServicesBean].updateSite() => check  :55555555555555555555555");

        // Taxable
		int result = taxableCd.compareToIgnoreCase("true");
		if(result == 0){
			taxableCd = "Y";
		}else {
			taxableCd = "N";
		}
		updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR,taxableCd, siteloader);

        // Share Order Guides
        updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES,buyerOrderGuide, siteloader);


		//Inv Shopping
		result = invShop.compareToIgnoreCase("true");
		if(result == 0){
			invShop = "on";
		}else {
			invShop = "off";
		}
        updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING,invShop, siteloader);


		//Order Guide Comments
        updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.SITE_COMMENTS,ordComments, siteloader);

		//Shipping Comments
		updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.SITE_SHIP_MSG,shipMessage, siteloader);

        // Product Bundle
		String itemDisplayValue = "";
		String priceL = "P";
		String orderG= "O";
		if(itemDisplayRestrict == null || itemDisplayRestrict.equals("")){
			itemDisplayValue = "CATALOG";
		}else if(itemDisplayRestrict.equals(orderG)){
			itemDisplayValue = "ORDER_GUIDE";
		}else if(itemDisplayRestrict.equals(priceL)) {
			itemDisplayValue = "PRICE_LIST";
		}else{
			itemDisplayValue = "CATALOG";
		}
        updateOrInsertProperty(conn,siteID,RefCodeNames.PROPERTY_TYPE_CD.SITE_PRODUCT_BUNDLE,itemDisplayValue, siteloader);

        return siteID;

       	} catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}


    }


    private void updateOrInsertProperty(Connection conn, int siteId, String propName, String propValue, String userName)
        throws SQLException
    {
        String selectPropertySql = "select * from clw_property where short_desc = ? " +
                "and bus_entity_id = ?";

    	String updatePropertySql = "update clw_property set clw_value = ?, mod_by = ? " +
    	        ",mod_date=sysdate " +
    			"where short_desc = ? " + 
    			"and bus_entity_id = ?";

    	String insertPropertySql = "Insert into clw_property (PROPERTY_ID,BUS_ENTITY_ID,USER_ID,SHORT_DESC," +
    	"CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY,LOCALE_CD) " +
		"values (clw_property_seq.NEXTVAL,?,null,?,?," +
                "'ACTIVE',?,sysdate,?,sysdate," +
		        "?,null)";

        PreparedStatement pstmt = conn.prepareStatement(selectPropertySql);
        pstmt.setString(1,propName);
        pstmt.setInt(2,siteId);
        ResultSet rs = pstmt.executeQuery();
        if (!rs.next()) {
        	rs.close();
        	pstmt.close();
        	
            pstmt = conn.prepareStatement(insertPropertySql);
            pstmt.setInt(1,siteId);
            pstmt.setString(2,propName);
            pstmt.setString(3,propValue);
            pstmt.setString(4,propName);
            pstmt.setString(5,userName);
            pstmt.setString(6,userName);
            
            
        } else {
        	rs.close();
        	pstmt.close();
        	
            pstmt = conn.prepareStatement(updatePropertySql);
            pstmt.setString(1,propValue);
            pstmt.setString(2,userName);
            pstmt.setString(3,propName);
            pstmt.setInt(4,siteId);
        }
        pstmt.executeUpdate();
        rs.close();
        pstmt.close();
    }


    public void moveSite(String siteloader, int storeNum, String accRefNum, int siteId, String siteRefNum,
                    int currAccountId, int newAccountId, Connection conn, String tempTable) throws RemoteException {



        String removeCatalogAssocSql = "delete clw_catalog_assoc where bus_entity_id=? and catalog_assoc_cd = ?";
        String removeSiteWorkflowSql = "delete clw_site_workflow w where w.site_id = ?";
        String selectSameWorkflowSql = "select neww.workflow_id as new_acc_wid " +
                "from (select w.workflow_id, w.short_desc, w.workflow_type_cd from clw_workflow w where w.bus_entity_id = ?) oldw, " +
                "(select w.workflow_id, w.short_desc, w.workflow_type_cd from clw_workflow w where w.bus_entity_id = ?) neww, " +
                "clw_site_workflow os "+
                "where UPPER(TRIM(oldw.short_desc)) = UPPER(TRIM(neww.short_desc)) " +
                "  and oldw.workflow_type_cd = neww.workflow_type_cd " +
                "  and os.workflow_id = oldw.workflow_id " +
                "  and os.site_id = ?";
        String insertSiteWorkflowSql = "insert into clw_site_workflow " +
                "(site_workflow_id, workflow_id, add_date, add_by, mod_date,mod_by,site_id) " +
                "values(clw_site_workflow_seq.nextval, ?, sysdate, ?, sysdate, ?, ?)";

        String updateBusEntAssocSql = "update clw_bus_entity_assoc ba set ba.bus_entity2_id = ?, " +
                " ba.mod_date = sysdate, ba.mod_by = ?" +
                " where ba.bus_entity1_id = ? and ba.bus_entity_assoc_cd = ?";

        String selectUserAssocSql = "select distinct u.user_id from clw_user_assoc u where u.user_assoc_cd = '"+RefCodeNames.USER_ASSOC_CD.ACCOUNT+
                "' and u.user_id in (" +
                    "select a.user_id from clw_user_assoc a where a.bus_entity_id = ? and a.user_assoc_cd = '"+RefCodeNames.USER_ASSOC_CD.SITE+"') " +
                        "and u.user_id not in ( select newu.user_id from clw_user_assoc newu where newu.bus_entity_id = ?)";
        String insertUserAssocSql = "insert into clw_user_assoc (user_assoc_id,user_id,bus_entity_id,user_assoc_cd,add_date,add_by,mod_date,mod_by) " +
                                        "values (clw_user_assoc_seq.nextval, ?,?,'" + RefCodeNames.USER_ASSOC_CD.ACCOUNT + "', " +
                                        "sysdate, ?, sysdate, ?)";

        String selectNewAccountAddresSql =
                "select b.short_desc,a.address1, a.address2, a.address3, a.address4, a.city, a.state_province_cd, " +
                    "a.country_cd, a.county_cd,a.postal_code, b.erp_num," +
                    "e.email_address, e.email_type_cd," +
                    "ph.phone_num, fax.phone_num as faxnum " +
                " from clw_bus_entity b, clw_address a, clw_email e, clw_phone ph, clw_phone fax " +
                " where b.bus_entity_id = ? and " +
                    "a.bus_entity_id = b.bus_entity_id and " +
                    "a.address_type_cd = '"+RefCodeNames.ADDRESS_TYPE_CD.BILLING+"' and " +
                    "e.bus_entity_id = b.bus_entity_id and  " +
                    "e.email_type_cd = '"+RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT+"' and " +
                    "ph.bus_entity_id = b.bus_entity_id and " +
                    "ph.phone_type_cd = '"+RefCodeNames.PHONE_TYPE_CD.PHONE+"' and " +
                    "fax.bus_entity_id = b.bus_entity_id and " +
                    "fax.phone_type_cd = '"+RefCodeNames.PHONE_TYPE_CD.FAX+"'";

        String updateOrderBillingAddressSql = "update clw_order_address set short_desc=?,address1=?,address2=?,address3=?," +
                    "address4=?,city=?,state_province_cd=?,country_cd=?,county_cd=?,postal_code=?,erp_num=?," +
                    "email_address=?,email_type_cd=?,phone_num=?,fax_phone_num=? " +
                    "where order_id in (select order_id from clw_order where site_id = ? and account_id = ?)" +
                    " and address_type_cd='" + RefCodeNames.ADDRESS_TYPE_CD.BILLING + "'";

        String updateOrderSql = "update clw_order o set o.account_id = ?, o.mod_date = sysdate, o.mod_by = ? " +
                "where o.site_id = ? and o.account_id = ?";

        String updateInvoiceDistSql = "update clw_invoice_dist d set d.account_id = ?, d.mod_date = sysdate, d.mod_by = ?    " +
                "where d.site_id = ? and d.account_id = ?";
        try {
            // Remove association site-catalog from clw_catalog_assoc table
            PreparedStatement pstmt = conn.prepareStatement(removeCatalogAssocSql);
		    pstmt.setInt(1, siteId);
		    pstmt.setString(2, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE);
		    pstmt.executeQuery();
		    pstmt.close();


		    // see if there is a workflow rule in the new account with the same name (ignoring white space and case)
		    // the such workflow shoud be configured to the site in the old account
            pstmt = conn.prepareStatement(selectSameWorkflowSql);
            pstmt.setInt(1, currAccountId);
            pstmt.setInt(2, newAccountId);
            pstmt.setInt(3, siteId);
            ResultSet rs = pstmt.executeQuery();
            List<Integer> workflowIds = new ArrayList();
            while (rs.next()) {
                workflowIds.add(new Integer(rs.getInt(1)));
            }
            rs.close();
            pstmt.close();

            // Remove site related records from clw_site_workflow table
            pstmt = conn.prepareStatement(removeSiteWorkflowSql);
		    pstmt.setInt(1, siteId);
		    pstmt.executeQuery();
		    pstmt.close();

            // map the site to the new workflow rule
            if (workflowIds.size() > 0) {
                pstmt = conn.prepareStatement(insertSiteWorkflowSql);

                for (int i=0; i<workflowIds.size(); i++) {
                    Integer wId = workflowIds.get(i);

                    pstmt.setInt(1, wId);
                    pstmt.setString(2, siteloader);
                    pstmt.setString(3, siteloader);
                    pstmt.setInt(4, siteId);

                    pstmt.addBatch();

                }
                pstmt.executeBatch();
                pstmt.close();
            }


            // Update site related record in clw_bus_entity_assoc table
            pstmt = conn.prepareStatement(updateBusEntAssocSql);
            pstmt.setInt(1, newAccountId);
            pstmt.setString(2, siteloader);
            pstmt.setInt(3, siteId);
            pstmt.setString(4, RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT);
            pstmt.executeUpdate();
            pstmt.close();

            //Insert records User-account records into clw_user_assoc  table for the users associated with the site
            // but do not have association with the new account (populate columns add_date with sysdate and add_by
            // with value of siteloader variable)

            pstmt = conn.prepareStatement(selectUserAssocSql);
            pstmt.setInt(1, siteId);
            pstmt.setInt(2, newAccountId);

            List<Integer> userIds = new ArrayList();
            rs = pstmt.executeQuery();
            while (rs.next()) {
                int userId = rs.getInt(1);
                userIds.add(new Integer(userId));
            }
            rs.close();

            pstmt = conn.prepareStatement(insertUserAssocSql);
            for (int i=0; i<userIds.size(); i++) {
                Integer userId = userIds.get(i);

                pstmt.setInt(1, userId);
                pstmt.setInt(2, newAccountId);
                pstmt.setString(3, siteloader);
                pstmt.setString(4, siteloader);

                pstmt.addBatch();

            }
            pstmt.executeBatch();
            pstmt.close();


            // Update BILLING  type site related records in clw_order_address table with new account address data
            // get new account address
            pstmt = conn.prepareStatement(selectNewAccountAddresSql);
            pstmt.setInt(1, newAccountId);
            rs = pstmt.executeQuery();
            OrderAddressData orderAddressD =  OrderAddressData.createValue();

            if (rs.next()) {
                orderAddressD.setShortDesc(rs.getString("short_desc"));
                orderAddressD.setAddress1(rs.getString("address1"));
                orderAddressD.setAddress2(rs.getString("address2"));
                orderAddressD.setAddress3(rs.getString("address3"));
                orderAddressD.setAddress4(rs.getString("address4"));
                orderAddressD.setCity(rs.getString("city"));
                orderAddressD.setStateProvinceCd(rs.getString("state_province_cd"));
                orderAddressD.setCountryCd(rs.getString("country_cd"));
                orderAddressD.setCountyCd(rs.getString("county_cd"));
                orderAddressD.setPostalCode(rs.getString("postal_code"));
                orderAddressD.setErpNum(rs.getString("erp_num"));
                orderAddressD.setEmailAddress(rs.getString("email_address"));
                orderAddressD.setEmailTypeCd(rs.getString("email_type_cd"));
                orderAddressD.setPhoneNum(rs.getString("phone_num"));
                orderAddressD.setFaxPhoneNum(rs.getString("faxnum"));
            }
            pstmt.close();

            // update
            pstmt = conn.prepareStatement(updateOrderBillingAddressSql);
            pstmt.setString(1, orderAddressD.getShortDesc());
            pstmt.setString(2, orderAddressD.getAddress1());
            pstmt.setString(3, orderAddressD.getAddress2());
            pstmt.setString(4, orderAddressD.getAddress3());
            pstmt.setString(5, orderAddressD.getAddress4());
            pstmt.setString(6, orderAddressD.getCity());
            pstmt.setString(7, orderAddressD.getStateProvinceCd());
            pstmt.setString(8, orderAddressD.getCountryCd());
            pstmt.setString(9, orderAddressD.getCountyCd());
            pstmt.setString(10, orderAddressD.getPostalCode());
            pstmt.setString(11, orderAddressD.getErpNum());
            pstmt.setString(12, orderAddressD.getEmailAddress());
            pstmt.setString(13, orderAddressD.getEmailTypeCd());
            pstmt.setString(14, orderAddressD.getPhoneNum());
            pstmt.setString(15, orderAddressD.getFaxPhoneNum());
            pstmt.setInt(16, siteId);
            pstmt.setInt(17, currAccountId);
            pstmt.executeQuery();
            pstmt.close();

            // Update site related records in clw_order table. Set account_id = new_account_id
            pstmt = conn.prepareStatement(updateOrderSql);
            pstmt.setInt(1, newAccountId);
            pstmt.setString(2, siteloader);
            pstmt.setInt(3, siteId);
            pstmt.setInt(4, currAccountId);
            pstmt.executeUpdate();
            pstmt.close();

            // Update site related records in clw_invoice_dist table. Set account_id = new_account_id
            pstmt = conn.prepareStatement(updateInvoiceDistSql);
            pstmt.setInt(1, newAccountId);
            pstmt.setString(2, siteloader);
            pstmt.setInt(3, siteId);
            pstmt.setInt(4, currAccountId);
            pstmt.executeUpdate();
            pstmt.close();


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateAndMoveSite()=> "
                               + e.getMessage());
    	}


    }

    public void inactivateSite(String accRefNum, String siteRefNum, int storeNum, String siteloader, Connection conn) throws RemoteException{
    	int siteId = 0;

        String selectCheckSite = "select bus_entity_id from clw_property where short_desc = ? " +
        		"and clw_value = ? and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc " +
        		"where bus_entity2_id in(select bus_entity_id from clw_property where short_desc = ? " +
        		"and clw_value = ? and bus_entity_id in " +
                "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)))";

    	/*String selectCheckSite = "select bus_entity_id from clw_bus_entity where bus_entity_id in " +
    			"(select bus_entity_id from clw_property where short_desc = ? " +
    			"and clw_value = ? and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc " +
    			"where bus_entity2_id in(select bus_entity1_id from clw_bus_entity_assoc " +
    			"where bus_entity2_id = ?)))";*/


        String updateSite = "update clw_bus_entity set bus_entity_status_cd = ?,mod_by = ?,mod_date = sysdate " +
    	"where bus_entity_type_cd = ? and bus_entity_id = ?";

    	try{
        	PreparedStatement pstmt = conn.prepareStatement(selectCheckSite);
        	pstmt.setString(1,RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
        	pstmt.setString(2,siteRefNum);
        	pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
        	pstmt.setString(4, accRefNum);
        	pstmt.setInt(5,storeNum);
        	ResultSet rs = pstmt.executeQuery();

        	while(rs.next()){
    			siteId = rs.getInt(1);
    		}
        	pstmt.close();

        	log.info("SITE TO INACTIVATE 3333 SITE ID  = " + siteId);
        	pstmt = conn.prepareStatement(updateSite);
    		pstmt.setString(1,RefCodeNames.BUS_ENTITY_STATUS_CD.INACTIVE);
    		pstmt.setString(2,siteloader);
    		pstmt.setString(3,RefCodeNames.BUS_ENTITY_TYPE_CD.SITE);
    		pstmt.setInt(4,siteId);
    		pstmt.addBatch();
    		pstmt.executeBatch();
    		pstmt.close();


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}


    }

    private void createSites(Connection conn,  List actionList,  String siteloader, String tmpTableName) throws RemoteException{
         String actions = IdVector.toCommaString(actionList);
         String insertBusEntity = "insert into clw_bus_entity be (BE.BUS_ENTITY_ID, BE.BUS_ENTITY_STATUS_CD, BE.BUS_ENTITY_TYPE_CD, BE.EFF_DATE, "+
                    "BE.SHORT_DESC, BE.LOCALE_CD, BE.ERP_NUM, BE.WORKFLOW_ROLE_CD, BE.ADD_BY, BE.ADD_DATE, BE.MOD_BY, BE.MOD_DATE) "+
                    " select t.site_id, '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"', "+
                    " '"+RefCodeNames.BUS_ENTITY_TYPE_CD.SITE+"', sysdate, T.SITE_NAME, 'en_US', '#'||t.site_id, 'UNKNOWN',"+
                    " '"+siteloader+"', sysdate, '"+siteloader+"', sysdate "+
                    " from "+ tmpTableName +" t " +
                    " where t.action in ("+actions+") and t.site_id is not null and t.update_fl = 'NEW' ";

         String insertAddress = "insert into clw_address a ( address_id, address_status_cd, address_type_cd, bus_entity_id,  name1 ,name2 ,address1,address2,address3,address4, primary_ind," +
                    " city,state_province_cd,country_cd,postal_code,add_by, add_date, mod_by,mod_date  ) " +
                    " select CLW_ADDRESS_SEQ.nextval, '"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"', '"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"',"+
                    " T.SITE_ID,  T.FIRST_NAME, T.LAST_NAME, T.ADDRESS1, T.ADDRESS2, T.ADDRESS3, T.ADDRESS4, 1, " +
                    " T.CITY,T.STATE, T.COUNTRY, T.POSTAL_CODE, '"+siteloader+"', sysdate , '"+siteloader+"', sysdate from "+ tmpTableName +" t  " +
                    " WHERE  t.action in ("+actions+") and t.site_id is not null and update_fl = 'NEW'";

          String insertBusEntityAssoc = "insert into clw_bus_entity_assoc bea (BEA.BUS_ENTITY_ASSOC_ID, BEA.BUS_ENTITY_ASSOC_CD, BEA.BUS_ENTITY1_ID, BEA.BUS_ENTITY2_ID, "+
                  " BEA.ADD_BY, BEA.ADD_DATE, BEA.MOD_BY, BEA.MOD_DATE  ) "+
                  " select clw_bus_entity_assoc_seq.nextval, '"+RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT+"', t.site_id, t.account_id, '"+siteloader+"', sysdate, '"+siteloader+"', sysdate  "+
                  " from "+ tmpTableName +" t  "+
                  " where t.action in ("+actions+") and t.site_id is not null and t.update_fl = 'NEW' ";


         try{
                 log.info("[IntegrationServicesBean].createSite() => createBusEntity SQL :" + insertBusEntity);
                 PreparedStatement pstmt = conn.prepareStatement(insertBusEntity);
                 int n = pstmt.executeUpdate();
                 log.info("[IntegrationServicesBean].createSites() CLW_BUS_ENTITY : inserted " + n + " records");
                 //-----------------------------------------------------//
                 log.info("[IntegrationServicesBean].createSite() => createBusEntityAssoc SQL :" + insertBusEntityAssoc);
                  pstmt = conn.prepareStatement(insertBusEntityAssoc);
                  n = pstmt.executeUpdate();
                  log.info("[IntegrationServicesBean].createSites() CLW_BUS_ENTITY_ASSOC : inserted " + n + " records");
                 //-----------------------------------------------------//
                 log.info("[IntegrationServicesBean].createSite() => createAddress SQL :" + insertAddress);
                 pstmt = conn.prepareStatement(insertAddress);
                 n = pstmt.executeUpdate();
                 log.info("[IntegrationServicesBean].createSites() CLW_ADDRESS : inserted " + n + " records");
                 //-----------------------------------------------------//

                 //Create Property Data
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER, "site_ref_num",actions, siteloader,  tmpTableName, true);
                 //Create Taxable Property
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR, "decode(upper(taxable),'TRUE', 'Y','N')",actions, siteloader,  tmpTableName, true);
                 //Create Share buyer Order guide
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES, "buyer_order_guide",actions, siteloader,  tmpTableName, true);
                 //Create Inv Shopping
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING, "decode(upper(inventory_shopping_para),'TRUE', 'ON', 'OFF')",actions, siteloader,  tmpTableName, true);
                 //Create Order Guide Comments
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_COMMENTS, "order_guide_comments", actions,siteloader,  tmpTableName, true);
                 //Create Shipping Comments
                 createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_SHIP_MSG, "ship_message",actions, siteloader,  tmpTableName, true);


         }catch(Exception e){
                 e.printStackTrace();
                 //throw e;
                    throw new RemoteException(
                        "Error.IntegrationServicesBean.createSites()=> "
                                + e.getMessage());
         }

     }

    private void updateSites(Connection conn,  List actionList,  String siteloader, String tmpTableName) throws RemoteException{
     String actions = IdVector.toCommaString(actionList);
     String updateBusEntity = "update clw_bus_entity be set ( short_desc, bus_entity_status_cd, mod_by, mod_date) = "+
                              " ( select t.site_name, '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"', '"+siteloader+"', sysdate "+
                              " from "+ tmpTableName +" t "+
                              " where  BE.BUS_ENTITY_ID = t.site_id "+
                              ")  where  "+
                              " BE.BUS_ENTITY_ID in (select distinct site_id from "+ tmpTableName +" t " +
                              " where t.action in ("+actions+") and be.short_desc <> t.site_name and BE.BUS_ENTITY_ID = t.site_id) ";
/*
     String matchSql =   "(   nvl(A.NAME1,'null') <> nvl(T.FIRST_NAME,'null') "+
                         " OR nvl(A.NAME2,'null')  <> nvl(T.LAST_NAME,'null') "+
                         " OR nvl(A.ADDRESS1,'null') <> nvl(T.ADDRESS1,'null') "+
                         " OR nvl(A.ADDRESS2,'null') <> nvl(T.ADDRESS2,'null') "+
                         " OR nvl(A.ADDRESS3, 'null')<> nvl(T.ADDRESS3,'null') "+
                         " OR nvl(A.ADDRESS4,'null') <> nvl(T.ADDRESS4,'null') "+
                         " OR nvl(A.CITY,'null')     <> nvl(T.CITY,'null') "+
                         " OR nvl(A.STATE_PROVINCE_CD,'null') <> nvl(T.STATE,'null') "+
                         " OR nvl(A.COUNTRY_CD,'null') <> nvl(T.COUNTRY,'null') "+
                         " OR nvl(A.POSTAL_CODE,'null') <> nvl(T.POSTAL_CODE,'null')) ";

     String updateAddress = "update clw_address a set ( name1 ,name2 ,address1,address2,address3,address4, "+
                              "   city,state_province_cd,country_cd,postal_code,mod_by,mod_date ) = ( "+
                              " select  T.FIRST_NAME, T.LAST_NAME, T.ADDRESS1, T.ADDRESS2, T.ADDRESS3, T.ADDRESS4, "+
                              " T.CITY,T.STATE, T.COUNTRY, T.POSTAL_CODE, '"+siteloader+"', sysdate from "+ tmpTableName +" t "+
                              " where  A.BUS_ENTITY_ID = T.site_id "+
               //               " and t.action in ("+actions+") and A.ADDRESS_STATUS_CD='"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"' and A.ADDRESS_TYPE_CD ='"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"' and " +  matchSql +
                              ") where  A.BUS_ENTITY_ID  in ( select distinct site_id from "+ tmpTableName +" t "+
                              " where t.action in ("+actions+") and A.BUS_ENTITY_ID = t.site_id and A.ADDRESS_STATUS_CD='"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"' and A.ADDRESS_TYPE_CD ='"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"' and " +
                               matchSql +")";


        String insertAddress = "insert into clw_address a ( address_id, address_status_cd, address_type_cd, bus_entity_id,  name1 ,name2 ,address1,address2,address3,address4, primary_ind," +
                               "  city,state_province_cd,country_cd,postal_code,add_by, add_date, mod_by,mod_date  ) " +
                               " select CLW_ADDRESS_SEQ.nextval, '"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"', '"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"',"+
                               " T.SITE_ID,  T.FIRST_NAME, T.LAST_NAME, T.ADDRESS1, T.ADDRESS2, T.ADDRESS3, T.ADDRESS4, 1," +
                               " T.CITY,T.STATE, T.COUNTRY, T.POSTAL_CODE, '"+siteloader+"', sysdate , '"+siteloader+"', sysdate from "+ tmpTableName +" t  " +
                               " WHERE  t.action in ("+actions+") and t.site_id is not null and NOT EXISTS "+
                               "    (SELECT 1  FROM clw_address a WHERE  A.BUS_ENTITY_ID = t.site_id and A.ADDRESS_STATUS_CD='"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"' and A.ADDRESS_TYPE_CD ='"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"')  " ;
 */

        try{

               //--------------------------------CLW_BUS_ENTITY---------------------------//
               log.info("[IntegrationServicesBean].updateSite() => updateBusEntity SQL :" + updateBusEntity);
               PreparedStatement pstmt = conn.prepareStatement(updateBusEntity);
               int n = pstmt.executeUpdate();
               log.info("[IntegrationServicesBean].updateSite() => clw_bus_entity : updated " + n + " records");
               //--------------------------------CLW_ADDRESS----------------------------//
               updateSiteAddress (conn, actions, siteloader,  tmpTableName);
               createSiteAddress (conn, actions, siteloader,  tmpTableName);
               //-------------------------------------------------------------------------//
               //Update Taxable Property
               updateSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR, "decode(upper(taxable),'TRUE', 'Y','N')",actions, siteloader,  tmpTableName);
               createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR, "decode(upper(taxable),'TRUE', 'Y','N')",actions, siteloader,  tmpTableName);
               //Update Share buyer Order guide
               updateSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES, "buyer_order_guide",actions, siteloader,  tmpTableName);
               createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SHARE_ORDER_GUIDES, "buyer_order_guide",actions, siteloader,  tmpTableName);
               //Inv Shopping
               updateSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING, "decode(upper(inventory_shopping_para),'TRUE', 'ON', 'OFF')",actions, siteloader,  tmpTableName);
               createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_SHOPPING, "decode(upper(inventory_shopping_para),'TRUE', 'ON', 'OFF')",actions, siteloader,  tmpTableName);
               //Order Guide Comments
               updateSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_COMMENTS, "order_guide_comments", actions,siteloader,  tmpTableName);
               createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_COMMENTS, "order_guide_comments", actions,siteloader,  tmpTableName);
               //Shipping Comments
               updateSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_SHIP_MSG, "ship_message",actions, siteloader,  tmpTableName);
               createSiteProperty  (conn, RefCodeNames.PROPERTY_TYPE_CD.SITE_SHIP_MSG, "ship_message",actions, siteloader,  tmpTableName);


       }catch(Exception e){
               e.printStackTrace();
               //throw e;
                  throw new RemoteException(
                      "Error.IntegrationServicesBean.updateSite()=> "
                              + e.getMessage());
       }


   }
   private void createSiteAddress (Connection conn,  String actions, String siteloader, String tmpTableName) throws Exception{
     String insertAddress = "insert into clw_address a ( address_id, address_status_cd, address_type_cd, bus_entity_id,  name1 ,name2 ,address1,address2,address3,address4, primary_ind," +
                           "  city,state_province_cd,country_cd,postal_code,add_by, add_date, mod_by,mod_date  ) " +
                           " select CLW_ADDRESS_SEQ.nextval, '"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"', '"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"',"+
                           " T.SITE_ID,  T.FIRST_NAME, T.LAST_NAME, T.ADDRESS1, T.ADDRESS2, T.ADDRESS3, T.ADDRESS4, 1," +
                           " T.CITY,T.STATE, T.COUNTRY, T.POSTAL_CODE, '"+siteloader+"', sysdate , '"+siteloader+"', sysdate from "+ tmpTableName +" t  " +
                           " WHERE  t.action in ("+actions+") and t.site_id is not null and NOT EXISTS "+
                           "    (SELECT 1  FROM clw_address a WHERE  A.BUS_ENTITY_ID = t.site_id and A.ADDRESS_STATUS_CD='"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"' and A.ADDRESS_TYPE_CD ='"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"')  " ;
     log.info("[IntegrationServicesBean].updateSite() => insertAddress SQL :" + insertAddress);
     PreparedStatement pstmt = conn.prepareStatement(insertAddress);
     int n = pstmt.executeUpdate();
     log.info("[IntegrationServicesBean].updateSite() => clw_address : inserted " + n + " records");

   }

    private void updateSiteAddress (Connection conn,  String actions, String siteloader, String tmpTableName) throws Exception{
      String updFlag = "UPDA";
      String matchSql =  "update "+ tmpTableName +" t set t.update_fl =  ( "+
                         " SELECT '"+updFlag+"' "+
                         " FROM clw_address a "+
                         " WHERE  t.action IN ("+actions+") "+
                         " AND t.site_id is not null " +
                         " AND A.BUS_ENTITY_ID = t.site_id "+
                         " AND A.ADDRESS_STATUS_CD = '"+RefCodeNames.ADDRESS_STATUS_CD.ACTIVE+"' "+
                         "AND A.ADDRESS_TYPE_CD = '"+RefCodeNames.ADDRESS_TYPE_CD.SHIPPING+"' "+
                         "AND ( nvl(A.NAME1,'null') <> nvl(T.FIRST_NAME,'null') "+
                          " OR nvl(A.NAME2,'null')  <> nvl(T.LAST_NAME,'null') "+
                          " OR nvl(A.ADDRESS1,'null') <> nvl(T.ADDRESS1,'null') "+
                          " OR nvl(A.ADDRESS2,'null') <> nvl(T.ADDRESS2,'null') "+
                          " OR nvl(A.ADDRESS3, 'null')<> nvl(T.ADDRESS3,'null') "+
                          " OR nvl(A.ADDRESS4,'null') <> nvl(T.ADDRESS4,'null') "+
                          " OR nvl(A.CITY,'null')     <> nvl(T.CITY,'null') "+
                          " OR nvl(A.STATE_PROVINCE_CD,'null') <> nvl(T.STATE,'null') "+
                          " OR nvl(A.COUNTRY_CD,'null') <> nvl(T.COUNTRY,'null') "+
                          " OR nvl(A.POSTAL_CODE,'null') <> nvl(T.POSTAL_CODE,'null')) )";

      String updateAddress = "update clw_address a set ( name1 ,name2 ,address1,address2,address3,address4, "+
                               "   city,state_province_cd,country_cd,postal_code,mod_by,mod_date ) = ( "+
                               " select  T.FIRST_NAME, T.LAST_NAME, T.ADDRESS1, T.ADDRESS2, T.ADDRESS3, T.ADDRESS4, "+
                               " T.CITY,T.STATE, T.COUNTRY, T.POSTAL_CODE, '"+siteloader+"', sysdate from "+ tmpTableName +" t "+
                               " where  A.BUS_ENTITY_ID = T.site_id "+
                               ") where  A.BUS_ENTITY_ID  in ( select distinct site_id from "+ tmpTableName +" t "+
                               " where  update_fl = '"+updFlag+"')";
       log.info("[IntegrationServicesBean].updateSite() => matchSql SQL :" + matchSql);
       PreparedStatement pstmt = conn.prepareStatement(matchSql);
       int n = pstmt.executeUpdate();
       log.info("[IntegrationServicesBean].updateSite() => to update Address flag : updated " + n + " records");

       log.info("[IntegrationServicesBean].updateSite() => updateAddress SQL :" + updateAddress);
       pstmt = conn.prepareStatement(updateAddress);
       n = pstmt.executeUpdate();
       log.info("[IntegrationServicesBean].updateSite() => clw_address : updated " + n + " records");

    }


    private void updateSiteProperty  (Connection conn, String propertyTypeCd, String tmpTableFldName, String actions, String siteloader, String tmpTableName) throws Exception{
      String updatePropertySql = "update clw_property p set (  clw_value , mod_by ,mod_date) "+
         " = ( select "+tmpTableFldName+ " ,  '"+siteloader+"', sysdate  "+
         "  from "+ tmpTableName +" t  "+
         "  where p.BUS_ENTITY_ID = t.site_id "+
//         " and t.action in ("+actions+") and nvl(upper(p.clw_value),'null') <> nvl("+tmpTableFldName+ ",'null') "+
         ")  "+
         " where   p.short_desc ='"+ propertyTypeCd +"' "+
         " and p.BUS_ENTITY_ID  in (select distinct site_id from "+ tmpTableName +" t  where t.action in ("+actions+") and nvl(upper(p.clw_value),'null') <>  nvl("+tmpTableFldName+ ",'null') and p.BUS_ENTITY_ID = t.site_id) ";

     String insertPropertySql = "";
     log.info("[IntegrationServicesBean].updateSiteProperty() ======================> propertyTypeCd :" + propertyTypeCd);
     log.info("[IntegrationServicesBean].updateSiteProperty() => updateProperty SQL :" + updatePropertySql);
     PreparedStatement pstmt = conn.prepareStatement(updatePropertySql);
     int n = pstmt.executeUpdate();
     log.info("[IntegrationServicesBean].updateSiteProperty() => clw_property : updated " + n + " records");
    }

    private void createSiteProperty  (Connection conn, String propertyTypeCd, String tmpTableFldName, String actions, String siteloader, String tmpTableName ) throws Exception{
      createSiteProperty  ( conn,  propertyTypeCd, tmpTableFldName,  actions,  siteloader,  tmpTableName, false );
    }

    private void createSiteProperty  (Connection conn, String propertyTypeCd, String tmpTableFldName, String actions, String siteloader, String tmpTableName, boolean newSiteFl ) throws Exception{
      String whereSql = (newSiteFl)? "t.update_fl = 'NEW'" : "NOT EXISTS ( SELECT 1  FROM clw_property p WHERE  t.site_id = p.BUS_ENTITY_ID and property_type_cd ='"+ propertyTypeCd +"' )";
       String insertPropertySql = "insert into  clw_property p (PROPERTY_ID,BUS_ENTITY_ID,SHORT_DESC,CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY) "+
      " select clw_property_seq.NEXTVAL,t.site_id, '"+ propertyTypeCd + "' , "+tmpTableFldName+ " ,'ACTIVE','"+ propertyTypeCd +"', " +
      " sysdate,'"+siteloader+"',sysdate, '"+siteloader+"' from  "+ tmpTableName +" t " +
      " where  t.action in ("+actions+") and t.site_id is not null and NOT EXISTS ( SELECT 1  FROM clw_property p WHERE  t.site_id = p.BUS_ENTITY_ID and property_type_cd ='"+ propertyTypeCd +"' ) ";

      log.info("[IntegrationServicesBean].createSiteProperty() ======================> propertyTypeCd :" + propertyTypeCd);
      log.info("[IntegrationServicesBean].createSiteProperty() => createProperty SQL :" + insertPropertySql);
      PreparedStatement pstmt = conn.prepareStatement(insertPropertySql);
      int n = pstmt.executeUpdate();
      log.info("[IntegrationServicesBean].createSiteProperty() => clw_property : created " + n + " records");

     }

     private void inactivateSites(Connection conn, String siteActionDelete, int storeNum, String siteloader, String tempTableName) throws RemoteException{
         log.info("inactivateSites() ====> BEGIN. ");

         String updateSite = "update clw_bus_entity set bus_entity_status_cd = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.INACTIVE+"', " +
             " mod_by = '" + siteloader + "', mod_date = sysdate " +
             " where bus_entity_type_cd = '"+RefCodeNames.BUS_ENTITY_TYPE_CD.SITE+"' "+
             " and bus_entity_id in " +
             "(select distinct site_id from " + tempTableName + " "+
             " where action in ('"+siteActionDelete+"'))";

         try{
                log.info("inactivateSites() ====> SQL : " + updateSite );
                PreparedStatement pstmt = conn.prepareStatement(updateSite);
                int n= pstmt.executeUpdate();
                pstmt.close();
                log.info("inactivateSites() ====> END. updated :" + n);


         }catch(Exception e){
                 e.printStackTrace();
                 //throw e;
                    throw new RemoteException(
                        "Error.IntegrationServicesBean.inactivateSites()=> "
                                + e.getMessage());
         }


     }

    public void processAccount(Connection conn, String accountloader, String accountActionAdd,String accountActionChange, String accountActionDelete, int storeNum, String tempTable) throws RemoteException{
    	String country1 = "US";
    	String country2 = "USA";
    	String country3 = "UNITED STATES";
    	boolean ifaccountExists;

    	try{
    	    String selectNull = "select count(*) from CLT_POLLARD_ACCOUNT_LOADER where add_by = ? " +
			"and (VERSION is null or ACTION is null or STORE_ID is null or STORE_NAME is null or ACCOUNT_REF_NUM is null or " +
			"ACCOUNT_NAME is null or BUDGET_TYPE is null or SITE_LLC_OVERRIDE is null or DEFAULT_EMAIL is null or " +
			"DIST_ACCOUNT_REF_NUM is null or BILLING_ADDESS1 is null or BILLING_CITY is null or BILLING_COUNTRY is null or " +
			"ORDER_CONTACT_PHONE is null or ORDER_CONTACT_FAX is null or ORDER_ITEM_ACTION is null or TAXABLE is null or " +
			"ALLOW_USER_TO_CHANGE_PASSWORD is null or ENABLE_INVENTORY_ORDER_PROCESS is null or ALLOW_CUSTOMER_PO_NUM is null or " +
			"AUTHORIZED_RESELLING_ITEMS is null or SHOW_DIST_SKU_NUM is null or SHOW_DIST_DELIVERY_DATE is null or " +
			"MODIFY_ORDER_QTY_COST_CENTER is null or ALLOW_REORDER is null or CREATE_ORDER_BY_ORDER_ACK is null or " +
			"SHOW_INVENTORY_ITEM_PRICE is null or DISPLAY_MY_SHOPPING_LIST is null or EXPRESS_ORDER is null or " +
			"DELIVERY_CUTOFF_DAYS is null or AUTO_ORDER_QTY_FACTOR is null or ALLOW_ORD_INV_ITEM is null or " +
			"USER_PHYSICAL_ING is null or INVENTORY_PROPERTY_BUDGET is null or INV_PROP_DONOT_PLACE_INV_ORDER is null or " +
			"INV_PROP_DIST_PO_TYPE is null or ADD_BY is null or ADD_DATE is null)";

			String selectAccountSize = "select count(*) from CLT_POLLARD_ACCOUNT_LOADER " +
    	    		"where add_by = ? and length(ACCOUNT_NAME) > 30";


			String selectBillingAdd = "select count(*) from CLT_POLLARD_ACCOUNT_LOADER where add_by = ? " +
			"and upper(BILLING_COUNTRY) in(?,?,?) " +
			"and (BILLING_STATE is null or BILLING_POSTAL_CODE is null)";

			//action = A or C
			String selectDistinctAccount = "select account_ref_num from CLT_POLLARD_ACCOUNT_LOADER " +
			"where add_by = ? and action in(?,?)";

			String selectDistinctAccountCancel = "select account_ref_num from CLT_POLLARD_ACCOUNT_LOADER " +
			"where add_by = ? and action in(?)";

    	   	PreparedStatement pstmt = conn.prepareStatement(selectNull);
			pstmt.setString(1, accountloader);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}
			pstmt.close();
			log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 1111111111111111111111 Oneeeeee of the mandatory field is null");
			} else{
				log.info("CHECK 1111111111111111111111 Counttttt is zero continue = " + count);
			}

			log.info("Check 2, check if size of account_name is greater then 30 Characters = " + selectAccountSize);

			pstmt = conn.prepareStatement(selectAccountSize);
			pstmt.setString(1, accountloader);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				log.info("Check 2 COUNTTTTTTTTTTTTTT = " + count);

			}
			pstmt.close();
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 222222222222222 ERRORRRRRR account name is greater then 30 characters = ");
			} else{
				log.info("CHECK 2222 is success continue = " + count);
			}

			log.info("Check 3, check if Billing state and zip is not null for country = USA = " + selectBillingAdd);
			pstmt = conn.prepareStatement(selectBillingAdd);
			pstmt.setString(1, accountloader);
			pstmt.setString(2, country1);
			pstmt.setString(3, country2);
			pstmt.setString(4, country3);
			rs = pstmt.executeQuery();

			count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				log.info("Check 2 COUNTTTTTTTTTTTTTT = " + count);

			}
			pstmt.close();

			if (count > 0) {
				throw new IllegalArgumentException("CHECK 3333333333 ERRORRRRRR billing zip or state is null = ");
			} else{
				log.info("CHECK 333 is success continue = " + count);
			}

			pstmt = conn.prepareStatement(selectDistinctAccount);
			pstmt.setString(1,accountloader);
			pstmt.setString(2,accountActionAdd);
			pstmt.setString(3,accountActionChange);
			rs = pstmt.executeQuery();

			String accRefNum = "";
			while(rs.next()){
				log.info("Check 4 if Account Already Exists = " + rs.getString(1));
				accRefNum = rs.getString(1);

				log.info("This is Account: = " + rs.getString(1) );
				ifaccountExists = accountCheck(accountloader,accountActionAdd,accountActionChange,accountActionDelete,storeNum,accRefNum,conn);
				log.info("PPPPPPPPPPPPPPPPPPPPPPTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT" + ifaccountExists);
				if(ifaccountExists){
					log.info("TRRRRRRRRRRRRRRRRRUUUUUUUUUUUUUEEEEEEEEEEEEEEEE::::::::::UPDATE" + ifaccountExists);
					updateAccount(accountloader,accountActionAdd,accountActionChange,storeNum,accRefNum,conn, tempTable);

				} else {
					log.info("FAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLSSSSSSEEEEEEEEEEEEEEEE:::::::::: CREATE" + ifaccountExists);
					log.info("FAAAAAAAAAAAAAAALLLLLLLLLLLLLLLLLSSSSSSEEEEEEEEEEEEEEEE:::::::::: ACCOUNT REF NUM::" + accRefNum);
					createAccount(accountloader,accountActionAdd,accountActionChange,storeNum,accRefNum,conn, tempTable);
				}
			}
			pstmt.close();

			log.info("ACCOUNT TO INACTIVATE ================================================================");
			log.info("ACCOUNT TO INACTIVATE ================================================================");
			log.info("ACCOUNT TO INACTIVATE ================================================================");
			log.info("ACCOUNT TO INACTIVATE ================================================================");
			log.info("ACCOUNT TO INACTIVATE =======" + selectDistinctAccountCancel);
			log.info("ACCOUNT TO INACTIVATE 1,accountloader " + accountloader);
			log.info("ACCOUNT TO INACTIVATE 2,accountActionDelete" + accountActionDelete);
			pstmt = conn.prepareStatement(selectDistinctAccountCancel);
			pstmt.setString(1,accountloader);
			pstmt.setString(2,accountActionDelete);
			rs = pstmt.executeQuery();

			while(rs.next()){
				log.info("ACCOUNT TO INACTIVATE 1111111111111111111111111111111111111111111111111111111111111");
				log.info("ACCOUNT TO INACTIVATE 1111111111111111111111111111111111111111111111111111111111111");
				log.info("ACCOUNT TO INACTIVATE 1111111111111111111111111111111111111111111111111111111111111");
				log.info("ACCOUNT TO INACTIVATE 1111111111111111111111111111111111111111111111111111111111111");
				log.info("ACCOUNT TO INACTIVATE 1111111111111111111111111111111111111111111111111111111111111");
				log.info("ACCOUNT account_reference_num TO Delete(Inactivate) = " + rs.getString(1));
				accRefNum = rs.getString(1);
				inactivateAccount(accountloader,accountActionDelete,storeNum,accRefNum,conn);

				}

			pstmt.close();




	}catch(Exception e){
		e.printStackTrace();
		//throw e;
		   throw new RemoteException(
                   "Error.IntegrationServicesBean.processAccountDelivery()=> "
                           + e.getMessage());
	}finally{
		if (conn != null)
			//conn.close();
			closeConnection(conn);
	}
    }

    public boolean accountCheck(String accountloader,String accountActionAdd,String accountActionChange,String accountActionDelete,int storeNum,String accRefNum,Connection conn) throws RemoteException{

        String selectCheckAccount = "select count(*) from clw_bus_entity where bus_entity_type_cd = ? " +
        "and bus_entity_id in(select bus_entity_id from clw_property where bus_entity_id in " +
        "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
        "and short_desc = ? and clw_value = ?)";

        try{

    		int count = 0;
    		PreparedStatement pstmt1 = conn.prepareStatement(selectCheckAccount);

			pstmt1.setString(1, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			pstmt1.setInt(2,storeNum);
			pstmt1.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt1.setString(4, accRefNum);
			ResultSet rs = pstmt1.executeQuery();
			while(rs.next()){
				count = rs.getInt(1);
			}
			pstmt1.close();
			log.info("SQQQQQQQQQLLLLLLLL to check " + selectCheckAccount);
			log.info("1 BUS_ENTITY_TYPE_CD = " + RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT + "2 StoreID = " + storeNum +  "3 PROPERTY SHORT_DESC = " + RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM + "4 Account Ref Num = " + accRefNum);
			if (count > 0) {
				log.info("CHeck 44444444444444444 Account ALREADY EXISTSSSSSSS UPDATEEEEE Return TRUE = " + accRefNum);
				return true;
				//throw new IllegalArgumentException("Check 4 site name is greater then 30 characters = ");
			} else{
				log.info("Check 444444444444444 ACCOUNT DOES NOT EXISTS RETURN FALSE = " + count);
				return false;
			}

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}
    }

    public void createAccount(String accountloader,String accountActionAdd,String accountActionChange,int storeNum,String accountRefNum,Connection conn, String tmpTableName) throws RemoteException{
    	boolean isPollock = accountloader.equals("pollockAccountLoader");
    	String accountName 					= "";
    	String accountType					= "";
    	String budgetType 					= "";
    	String timeZone 					= "";
    	String siteLlcOverride 				= "";
    	String customerServiceEmail 		= "";
    	String contactCcEmail 				= "";
    	String defaultEmail 				= "";
    	String distAccountRefNum 			= "";
    	String primaryContactFirstName 		= "";
    	String primaryContactLastName 		= "";
    	String primaryContactPhone 			= "";
    	String primaryContactFax 			= "";
    	String primaryContactEmail 			= "";
    	String primaryContactAddress1 		= "";
    	String primaryContactAddress2 		= "";
    	String primaryContactAddress3 		= "";
    	String primaryContactCity 			= "";
    	String primaryContactState 			= "";
    	String primaryContactCountry 		= "";
    	String primaryContactPostalCode 	= "";
    	String billingAddress1 				= "";
    	String billingAddress2 				= "";
    	String billingAddress3 				= "";
    	String billingCity 					= "";
    	String billingState 				= "";
    	String billingCountry 				= "";
    	String billingPostalCode 			= "";
    	String purchaseOrderAccountName 	= "";
    	String orderContactPhone 			= "";
    	String orderContactFax 				= "";
    	String orderGuideComments 			= "";
    	String orderGuideNotes 				= "";
    	String orderGuideSkuHeading 		= "";
    	String orderItemAction 				= "";
    	String taxableCd 					= "";
    	String allowUserToChangePasswd 		= "";
    	String enableInvOrderProcess 		= "";
    	String allowCustomerPoNum 			= "";
    	String authorizedResellingItems 	= "";
    	String showDistSkuNum 				= "";
    	String showDistDeliveryDate 		= "";
    	String modifyOrderQtyCostCenter 	= "";
    	String allowReorder					= "";
    	String createOrderByOrderAck 		= "";
    	String modernShoppingFolder 		= "";
    	String showInvItemPrice 			= "";
    	String displayMyShoppingList 		= "";
    	String expressOrder 				= "";
    	String deliveryCutoffDays 			= "";
    	String accountFolder 				= "";
    	String autoOrderQtyFactor 			= "";
    	String allowOrdInvItem 				= "";
    	String userPhysicalIng 				= "";
    	String shopUiType 					= "";
    	String faqLink 						= "";
    	String pdfOrderClassName 			= "";
    	String pdfOrderStatusName 			= "";
    	String reminderEmailSubject 		= "";
    	String reminderEmailMessage 		= "";
    	//Note - this method is not being updated for task 5107, since this method is only used
    	//by classes in the dataexchange package which Brook said can be ignored for this task.
    	String orderConfirmEmailGen 		= "";
    	String orderNotificationEmailGen 	= "";
    	String orderRejectedEmailGen 		= "";
    	String pendingApprovalEmail 		= "";
    	String invPropertyBudget 			= "";
    	String invPropertyPoSuffix 			= "";
    	String invPropertyOg	 			= "";
    	String invPropSendNotification 		= "";
    	String invPropDonotPlaceInvOrd 		= "";
    	String invPropDistPoType 			= "";
    	String fiscalCalendarYear 			= "";
    	String fiscalCalendarStart 			= "";
    	String fiscalCalendarPeriod		 	= "";
    	String allowToSetWorkorderPo 		= "";
    	String workOrderPoNumReq 			= "";
    	String userAssignedAsserNum 		= "";
    	String allowOrdPartsWorkOrder 		= "";
    	String populateContactInfo 			= "";
    	String productUiTemplate			= "";
    	String modifyCustPoNumBy855 		= isPollock ? "TRUE" : "FALSE";
    	int busEntityId;
    	int fiscalCalenderId;
    	Date runDate = new Date();
    	int result = 0;

    	String selectSql = "select ACCOUNT_REF_NUM,ACCOUNT_NAME,ACCOUNT_TYPE,BUDGET_TYPE,TIME_ZONE, " +
    	    "SITE_LLC_OVERRIDE,CUSTOMER_SERVICE_EMAIL,CONTACT_CC_EMAIL,DEFAULT_EMAIL,DIST_ACCOUNT_REF_NUM, " +
    	    "PRIMARY_CONTACT_FIRST_NAME,PRIMARY_CONTACT_LAST_NAME,PRIMARY_CONTACT_PHONE,PRIMARY_CONTACT_FAX, " +
    	    "PRIMARY_CONTACT_EMAIL,PRIMARY_CONTACT_ADDESS1,PRIMARY_CONTACT_ADDESS2,PRIMARY_CONTACT_ADDESS3, " +
    	    "PRIMARY_CONTACT_CITY,PRIMARY_CONTACT_STATE,PRIMARY_CONTACT_COUNTRY,PRIMARY_CONTACT_POSTAL_CODE, " +
    	    "BILLING_ADDESS1,BILLING_ADDESS2,BILLING_ADDESS3,BILLING_CITY,BILLING_STATE,BILLING_COUNTRY, " +
    	    "BILLING_POSTAL_CODE,PURCHASE_ORDER_ACCOUNT_NAME,ORDER_CONTACT_PHONE,ORDER_CONTACT_FAX, " +
    	    "ORDER_GUIDE_COMMENTS,ORDER_GUIDE_NOTES,ORDER_GUIDE_SKU_HEADING,ORDER_ITEM_ACTION,TAXABLE, " +
    	    "ALLOW_USER_TO_CHANGE_PASSWORD,ENABLE_INVENTORY_ORDER_PROCESS,ALLOW_CUSTOMER_PO_NUM, " +
    	    "AUTHORIZED_RESELLING_ITEMS,SHOW_DIST_SKU_NUM,SHOW_DIST_DELIVERY_DATE,MODIFY_ORDER_QTY_COST_CENTER, " +
    	    "ALLOW_REORDER,CREATE_ORDER_BY_ORDER_ACK,MODER_SHOPPING_FOLDER,SHOW_INVENTORY_ITEM_PRICE, " +
    	    "DISPLAY_MY_SHOPPING_LIST,EXPRESS_ORDER,DELIVERY_CUTOFF_DAYS,ACCOUNT_FOLDER,AUTO_ORDER_QTY_FACTOR, " +
    	    "ALLOW_ORD_INV_ITEM,USER_PHYSICAL_ING,SHOP_UI_TYPE,FAQ_LINK,PDF_ORDER_CLASS_NAME,PDF_ORDER_STATUS_NAME, " +
    	    "REMINDER_EMAIL_SUBJECT,REMINDER_EMAIL_MESSAGE,ORDER_CONFIRM_EMAIL_GEN,ORDER_NOTIFICATION_EMAIL_GEN, " +
    	    "ORDER_REJECTED_EMAIL_GEN,PENDING_APPROVAL_EMAIL,INVENTORY_PROPERTY_BUDGET,INVENTORY_PROPERTY_PO_SUFFIX, " +
    	    "INVENTORY_PROPERTY_OG,INV_PROPERTY_SEND_NOTIFICATION,INV_PROP_DONOT_PLACE_INV_ORDER,INV_PROP_DIST_PO_TYPE, " +
    	    "FISCAL_CALENDAR_YEAR,FISCAL_CALENDAR_START,FISCAL_CALENDAR_PERIOD,ALLOW_TO_SET_WORKORDER_PO, " +
    	    "WORK_ORDER_PO_NUM_REQ,USER_ASSIGNED_ASSET_NUM,ALLOW_ORDER_PARTS_WORKORDER,POPULATE_CONTACT_INFO,PRODUCT_UI_TEMPLATE " +
    	    "from " + tmpTableName + " where ACCOUNT_REF_NUM = ?";



    	String insertAddress = "insert into clw_address(address_id,bus_entity_id,name1,name2,address1,address2," +
    			"address3,city,state_province_cd,country_cd,postal_code,address_status_cd," +
    			"address_type_cd,primary_ind,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_address_seq.nextval,?,?,?,?,?,?,?,?,?,?,?,?,?,sysdate,?,sysdate,?)";

    	String insertPropertySql = "Insert into clw_property (PROPERTY_ID,BUS_ENTITY_ID,USER_ID,SHORT_DESC," +
    	"CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY,LOCALE_CD) " +
		"values (clw_property_seq.NEXTVAL,?,null,?,?,'ACTIVE',?,sysdate,'" + accountloader + "',sysdate," +
		"'" + accountloader + "',null)";

    	String insertEmail = "insert into clw_email(email_id,bus_entity_id,short_desc,email_type_cd," +
    			"email_status_cd,email_Address,primary_ind,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_email_seq.nextval,?,?,?,'ACTIVE',?,?,sysdate,'" + accountloader + "',sysdate,'" + accountloader + "')";

    	String insertPhone = "insert into clw_phone(phone_id,bus_entity_id,phone_num,short_desc,phone_type_cd," +
    			"phone_status_cd,primary_ind,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_phone_seq.nextval,?,?,?,?,'ACTIVE',?,sysdate,'" + accountloader + "'," +
    			"sysdate,'" + accountloader + "')";

    	String insertFiscalCalenderDetail = "insert into clw_fiscal_calender_detail(fiscal_calender_detail_id," +
    			"fiscal_calender_id,period,mmdd,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_fiscal_calender_detail_seq.nextval,?,?,?,sysdate,'" + accountloader + "'," +
    			"sysdate,'" + accountloader + "')";

     	try{
    		PreparedStatement pstmt = conn.prepareStatement(selectSql);
    		pstmt.setString(1, accountRefNum);
    		ResultSet rs = pstmt.executeQuery();
    		while(rs.next()) {

    			accountRefNum 				= rs.getString(1);
    			accountName 		 		= rs.getString(2);
    			accountType 		 		= rs.getString(3);
    			budgetType 		 			= rs.getString(4);
    			timeZone 		 			= rs.getString(5);
    			siteLlcOverride 		 	= rs.getString(6);
    			customerServiceEmail 	 	= rs.getString(7);
    			contactCcEmail 		 		= rs.getString(8);
    			defaultEmail 		 		= rs.getString(9);
    			distAccountRefNum 	 		= rs.getString(10);
    			primaryContactFirstName 	= rs.getString(11);
    			primaryContactLastName 	 	= rs.getString(12);
    			primaryContactPhone 	 	= rs.getString(13);
    			primaryContactFax 	 		= rs.getString(14);
    			primaryContactEmail 	 	= rs.getString(15);
    			primaryContactAddress1 	 	= rs.getString(16);
    			primaryContactAddress2 	 	= rs.getString(17);
    			primaryContactAddress3 	 	= rs.getString(18);
    			primaryContactCity 	 		= rs.getString(19);
    			primaryContactState 	 	= rs.getString(20);
    			primaryContactCountry 	 	= rs.getString(21);
    			primaryContactPostalCode  	= rs.getString(22);
    			billingAddress1 			= rs.getString(23);
    			billingAddress2 			= rs.getString(24);
    			billingAddress3 			= rs.getString(25);
    			billingCity 		 		= rs.getString(26);
    			billingState 		 		= rs.getString(27);
    			billingCountry 		 		= rs.getString(28);
    			billingPostalCode 	 		= rs.getString(29);
    			purchaseOrderAccountName  	= rs.getString(30);
    			orderContactPhone 	 		= rs.getString(31);
    			orderContactFax 			= rs.getString(32);
    			orderGuideComments 	 		= rs.getString(33);
    			orderGuideNotes 			= rs.getString(34);
    			orderGuideSkuHeading 	 	= rs.getString(35);
    			orderItemAction 			= rs.getString(36);
    			taxableCd 		 			= rs.getString(37);
    			allowUserToChangePasswd 	= rs.getString(38);
    			enableInvOrderProcess 	 	= rs.getString(39);
    			allowCustomerPoNum 	 		= rs.getString(40);
    			authorizedResellingItems  	= rs.getString(41);
    			showDistSkuNum 		 		= rs.getString(42);
    			showDistDeliveryDate 	 	= rs.getString(43);
    			modifyOrderQtyCostCenter  	= rs.getString(44);
    			allowReorder 		 		= rs.getString(45);
    			createOrderByOrderAck 	 	= rs.getString(46);
    			modernShoppingFolder 	 	= rs.getString(47);
    			showInvItemPrice 	 		= rs.getString(48);
    			displayMyShoppingList 	 	= rs.getString(49);
    			expressOrder 		 		= rs.getString(50);
    			deliveryCutoffDays 	 		= rs.getString(51);
    			accountFolder 		 		= rs.getString(52);
    			autoOrderQtyFactor 	 		= rs.getString(53);
    			allowOrdInvItem 			= rs.getString(54);
    			userPhysicalIng 			= rs.getString(55);
    			shopUiType 		 			= rs.getString(56);
    			faqLink 					= rs.getString(57);
    			pdfOrderClassName 	 		= rs.getString(58);
    			pdfOrderStatusName 	 		= rs.getString(59);
    			reminderEmailSubject 	 	= rs.getString(60);
    			reminderEmailMessage 	 	= rs.getString(61);
    			orderConfirmEmailGen 	 	= rs.getString(62);
    			orderNotificationEmailGen 	= rs.getString(63);
    			orderRejectedEmailGen 	 	= rs.getString(64);
    			pendingApprovalEmail 	 	= rs.getString(65);
    			invPropertyBudget 	 		= rs.getString(66);
    			invPropertyPoSuffix 	 	= rs.getString(67);
    			invPropertyOg 		 		= rs.getString(68);
    			invPropSendNotification 	= rs.getString(69);
    			invPropDonotPlaceInvOrd 	= rs.getString(70);
    			invPropDistPoType 	 		= rs.getString(71);
    			fiscalCalendarYear 	 		= rs.getString(72);
    			fiscalCalendarStart 	 	= rs.getString(73);
    			fiscalCalendarPeriod 	 	= rs.getString(74);
    			allowToSetWorkorderPo 	 	= rs.getString(75);
    			workOrderPoNumReq 	 		= rs.getString(76);
    			userAssignedAsserNum 	 	= rs.getString(77);
    			allowOrdPartsWorkOrder 	 	= rs.getString(78);
    			populateContactInfo 	 	= rs.getString(79);
    			productUiTemplate 			= rs.getString(80);

			}

    		pstmt.close();

			BusEntityData busEntityData = BusEntityData.createValue();
			busEntityData.setBusEntityStatusCd(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
			busEntityData.setWorkflowRoleCd("UNKNOWN");
			busEntityData.setLocaleCd("en_US");
			busEntityData.setAddBy(accountloader);
			busEntityData.setEffDate(runDate);
			busEntityData.setBusEntityTypeCd(RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			busEntityData.setShortDesc(accountName);
			busEntityData = BusEntityDataAccess.insert(conn, busEntityData);
			busEntityId = busEntityData.getBusEntityId();
			busEntityData.setErpNum("#" + busEntityId);
			BusEntityDataAccess.update(conn, busEntityData);


			//BusEntityAssoc
			BusEntityAssocData busEntityAssocD = BusEntityAssocData.createValue();
			busEntityAssocD.setBusEntity1Id(busEntityId);
			busEntityAssocD.setBusEntity2Id(storeNum);
			busEntityAssocD.setAddBy(accountloader);
			busEntityAssocD.setBusEntityAssocCd(RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE);
			busEntityAssocD = BusEntityAssocDataAccess.insert(conn, busEntityAssocD);

			//Add Billing Address
			//
			result = billingCountry.compareToIgnoreCase("US");
			if(result == 0){
				billingCountry = "UNITED STATES";
			}

			pstmt = conn.prepareStatement(insertAddress);
			pstmt.setInt(1, busEntityId);
			pstmt.setString(2,primaryContactFirstName);
			pstmt.setString(3,primaryContactLastName);
			pstmt.setString(4,billingAddress1);
			pstmt.setString(5,billingAddress2);
			pstmt.setString(6,billingAddress3);
			pstmt.setString(7,billingCity);
			pstmt.setString(8,billingState);
			pstmt.setString(9,billingCountry);
			pstmt.setString(10,billingPostalCode);
			pstmt.setString(11,RefCodeNames.ADDRESS_STATUS_CD.ACTIVE);
			pstmt.setString(12,RefCodeNames.ADDRESS_TYPE_CD.BILLING);
			pstmt.setInt(13,0);
			pstmt.setString(14,accountloader);
			pstmt.setString(15,accountloader);
			pstmt.addBatch();

			if(primaryContactCountry != null){
/*				log.info("Primary Contact Country is NULLLLLLLLLLLLLLLLLLLLLLLLLLLL = \n");
				pstmt.setInt(1, busEntityId);
				pstmt.setString(2,primaryContactFirstName);
				pstmt.setString(3,primaryContactLastName);
				pstmt.setString(4,billingAddress1);
				pstmt.setString(5,billingAddress2);
				pstmt.setString(6,billingAddress3);
				pstmt.setString(7,billingCity);
				pstmt.setString(8,billingState);
				pstmt.setString(9,billingCountry);
				pstmt.setString(10,billingPostalCode);
				pstmt.setString(11,RefCodeNames.ADDRESS_STATUS_CD.ACTIVE);
				pstmt.setString(12,RefCodeNames.ADDRESS_TYPE_CD.PRIMARY_CONTACT);
				pstmt.setInt(13,1);
				pstmt.setString(14,accountloader);
				pstmt.setString(15,accountloader);
				pstmt.addBatch();
			}else{*/
			//Add Primary Address
			pstmt.setInt(1, busEntityId);
			pstmt.setString(2,primaryContactFirstName);
			pstmt.setString(3,primaryContactLastName);
			pstmt.setString(4,primaryContactAddress1);
			pstmt.setString(5,primaryContactAddress2);
			pstmt.setString(6,primaryContactAddress3);
			pstmt.setString(7,primaryContactCity);
			pstmt.setString(8,primaryContactState);
			pstmt.setString(9,primaryContactCountry);
			pstmt.setString(10,primaryContactPostalCode);
			pstmt.setString(11,RefCodeNames.ADDRESS_STATUS_CD.ACTIVE);
			pstmt.setString(12,RefCodeNames.ADDRESS_TYPE_CD.PRIMARY_CONTACT);
			pstmt.setInt(13,1);
			pstmt.setString(14,accountloader);
			pstmt.setString(15,accountloader);
			pstmt.addBatch();
			}
			pstmt.executeBatch();
			pstmt.close();

			//Add Email default
			pstmt = conn.prepareStatement(insertEmail);
			pstmt.setInt(1,busEntityId);

			if(defaultEmail != null){
			pstmt.setString(2,RefCodeNames.EMAIL_TYPE_CD.DEFAULT);
			pstmt.setString(3,RefCodeNames.EMAIL_TYPE_CD.DEFAULT);
			pstmt.setString(4,defaultEmail);
			pstmt.setInt(5,1);
			pstmt.addBatch();
			}

			//Add Email Customer Service
			if(customerServiceEmail != null){
			pstmt.setString(2,RefCodeNames.EMAIL_TYPE_CD.CUSTOMER_SERVICE);
			pstmt.setString(3,RefCodeNames.EMAIL_TYPE_CD.CUSTOMER_SERVICE);
			pstmt.setString(4,customerServiceEmail);
			pstmt.setInt(5,0);
			pstmt.addBatch();
			}

			//Add Email Primary
			if(primaryContactFirstName == null){
				primaryContactFirstName = RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT;
			}
			pstmt.setString(2,primaryContactFirstName);
			pstmt.setString(3,RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT);
			pstmt.setString(4,primaryContactEmail);
			pstmt.setInt(5,0);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();

			//Add Phone Primary
			pstmt = conn.prepareStatement(insertPhone);
			pstmt.setInt(1,busEntityId);
			pstmt.setString(2,primaryContactPhone);
			pstmt.setString(3,RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT);
			pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.PHONE);
			pstmt.setInt(5,1);
			pstmt.addBatch();

			//Add Fax Primary
			pstmt.setString(2,primaryContactFax);
			pstmt.setString(3,RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT);
			pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.FAX);
			pstmt.setInt(5,1);
			pstmt.addBatch();

			//Add Order Contact Phone
			pstmt.setString(2,orderContactPhone);
			pstmt.setString(3,"Order Phone");
			pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.ORDERPHONE);
			pstmt.setInt(5,1);
			pstmt.addBatch();

			//Add Order Contact Fax
			pstmt.setString(2,orderContactFax);
			pstmt.setString(3,"Order Fax");
			pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.ORDERFAX);
			pstmt.setInt(5,1);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();
			//Add Property
			pstmt = conn.prepareStatement(insertPropertySql);
			pstmt.setInt(1, busEntityId);
			// Account reference number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setString(3, accountRefNum);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.addBatch();

			//Add Property Budget Type
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.BUDGET_ACCRUAL_TYPE_CD);
			pstmt.setString(3,budgetType);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.BUDGET_ACCRUAL_TYPE_CD);
			pstmt.addBatch();

			//Add Property Account Type
			if(accountType == null){
				accountType = "Other";
			}

			result = accountType.compareToIgnoreCase("Other");
			if(result == 0){
				accountType = "Other";
			}

			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ACCOUNT_TYPE);
			pstmt.setString(3,accountType);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.ACCOUNT_TYPE);
			pstmt.addBatch();


			//Add Property ALLOW_SITE_LLC
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_SITE_LLC);
			pstmt.setString(3,siteLlcOverride);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Order guide Notes
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ORDER_GUIDE_NOTE);
			pstmt.setString(3,orderGuideNotes);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Order guide Comments
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.COMMENTS);
			pstmt.setString(3,orderGuideComments);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.COMMENTS);
			pstmt.addBatch();

			//Add Property order guide sku headings
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SKU_TAG);
			pstmt.setString(3,orderGuideSkuHeading);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.SKU_TAG);
			pstmt.addBatch();

			//Add Property Taxable
			result = taxableCd.compareToIgnoreCase("true");
			if(result == 0){
				taxableCd = "Y";
			}else {
				taxableCd = "N";
			}

			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR);
			pstmt.setString(3,taxableCd);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR);
			pstmt.addBatch();

			//Add Property Allow Users to Change Password
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_USER_CHANGE_PASSWORD);
			pstmt.setString(3,allowUserToChangePasswd);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Enable Inventory Order Processing
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_SCHED_DELIVERY);
			pstmt.setString(3,enableInvOrderProcess);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Allow Customer to enter PO Number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_CUSTOMER_PO_NUMBER);
			pstmt.setString(3,allowCustomerPoNum);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_CUSTOMER_PO_NUMBER);
			pstmt.addBatch();

			//Add Property Authorize Customer for Resell
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.AUTHORIZED_FOR_RESALE);
			pstmt.setString(3,authorizedResellingItems);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.AUTHORIZED_FOR_RESALE);
			pstmt.addBatch();

			//Add Property Display Rebill Order in Checkout
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_REBILL_ORDER);
			pstmt.setString(3,authorizedResellingItems);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Add Property Show Distributor SKU Number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_DIST_SKU_NUM);
			pstmt.setString(3,showDistSkuNum);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Show Distributor Delivery Date
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_DIST_DELIVERY_DATE);
			pstmt.setString(3,showDistDeliveryDate);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Modify Order Qty and cost by order Acknowledgement(855)
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ADJUST_QTY_BY_855);
			pstmt.setString(3,modifyOrderQtyCostCenter);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Allow Reorder
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_REORDER);
			pstmt.setString(3,allowReorder);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Create Order by Order Acknowledgement 855
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_BY_855);
			pstmt.setString(3,createOrderByOrderAck);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Moder Shopping Folder
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_MODERN_SHOPPING);
			pstmt.setString(3,modernShoppingFolder);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Show inventory items price in cart total
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_INV_CART_TOTAL);
			pstmt.setString(3,showInvItemPrice);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Display my Shopping List
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_MY_SHOPPING_LISTS);
			pstmt.setString(3,displayMyShoppingList);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Express Order
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOW_EXPRESS_ORDER);
			pstmt.setString(3,expressOrder);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Delivery Cutt Off Days
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SCHEDULE_CUTOFF_DAYS);
			pstmt.setString(3,deliveryCutoffDays);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Account Folder
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ACCOUNT_FOLDER);
			pstmt.setString(3,accountFolder);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Auto Order Qty Factor
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.AUTO_ORDER_FACTOR);
			pstmt.setString(3,autoOrderQtyFactor);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Allow Order Inventory items in schedule cart period
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_ORDER_INV_ITEMS);
			pstmt.setString(3,allowOrdInvItem);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Use Physical Inventory
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.USE_PHYSICAL_INVENTORY);
			pstmt.setString(3,userPhysicalIng);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Shop UI Type
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.SHOP_UI_TYPE);
			pstmt.setString(3,shopUiType);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Order Class Name
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.PDF_ORDER_CLASS);
			pstmt.setString(3,pdfOrderClassName);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Order Status Class Name
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.PDF_ORDER_STATUS_CLASS);
			pstmt.setString(3,pdfOrderStatusName);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Reminder Email Subject
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.REMINDER_EMAIL_SUBJECT);
			pstmt.setString(3,reminderEmailSubject);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Reminder Email Mesaage
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.REMINDER_EMAIL_MSG);
			pstmt.setString(3,reminderEmailMessage);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Reminder Email Mesaage
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.CONFIRM_ORDER_EMAIL_GENERATOR);
			pstmt.setString(3,orderConfirmEmailGen);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Order notification Email generator
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.NOTIFY_ORDER_EMAIL_GENERATOR);
			pstmt.setString(3,orderNotificationEmailGen);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Order Rejected Email generator
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.REJECT_ORDER_EMAIL_GENERATOR);
			pstmt.setString(3,orderRejectedEmailGen);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Pending Approval Email Generator
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.PENDING_APPROV_EMAIL_GENERATOR);
			pstmt.setString(3,pendingApprovalEmail);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property PO Suffix
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_PO_SUFFIX);
			pstmt.setString(3,invPropertyPoSuffix);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property OG UI
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_OG_LIST_UI);
			pstmt.setString(3,invPropertyOg);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property Send Notification If Auto Order Applies(hours)
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_MISSING_NOTIFICATION);
			pstmt.setString(3,invPropSendNotification);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property Do not place Inv order if site order exists(days)
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_CHECK_PLACED_ORDER);
			pstmt.setString(3,invPropDonotPlaceInvOrd);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property Distributor PO Type
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.DISTR_PO_TYPE);
			pstmt.setString(3,invPropDistPoType);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Inventory Property Budget(off)
			//OFF means property box i checked
			result = invPropertyBudget.compareToIgnoreCase("true");
			if(result == 0){
				invPropertyBudget = "OFF";
			}else {
				invPropertyBudget = "ON";
			}

			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_LEDGER_SWITCH);
			pstmt.setString(3,invPropertyBudget);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Allow to set Work order PO Number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_SET_WORKORDER_PO_NUMBER);
			pstmt.setString(3,allowToSetWorkorderPo);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Add Property Work order PO Number is Required
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.WORK_ORDER_PO_NUM_REQUIRED);
			pstmt.setString(3,workOrderPoNumReq);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Add Property User Assigned Asset Number
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.USER_ASSIGNED_ASSET_NUMBER);
			pstmt.setString(3,userAssignedAsserNum);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Add Property Allow to order parts for work order
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOW_BUY_WORK_ORDER_PARTS);
			pstmt.setString(3,allowOrdPartsWorkOrder);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();

			//Add Property Modify customer po num by Order Acknowledgement 855
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.MODIFY_CUST_PO_NUM_BY_855);
			pstmt.setString(3,modifyCustPoNumBy855);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.EXTRA);
			pstmt.addBatch();


			//Add Order Item Action Property
			String sp[] = orderItemAction.split(",");
			for(String s:sp) {
				s = s.trim();
			   	pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOWED_RUNTIME_ORD_ITM_ACT);
				pstmt.setString(3, s);
				pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.ALLOWED_RUNTIME_ORD_ITM_ACT);
				pstmt.addBatch();

			}


			pstmt.executeBatch();
			pstmt.close();


		//ADD FISCAL Calender
			if(fiscalCalendarYear != null){
			log.info("FISCALLLLLLLLLLL CALENDER YEAR");
			int fiscalYear = Integer.parseInt(fiscalCalendarYear);
			log.info("FISCALLLLLLLLLLL CALENDER YEAR ========== " + fiscalYear);
			DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
			log.info("FISCALLLLLLLLLLL CALENDER START DATE");
			Date FiscalStarDate = df.parse(fiscalCalendarStart);
			log.info("FISCALLLLLLLLLLL CALENDER START DATE ========" + FiscalStarDate);
			FiscalCalenderData fiscalCalenderData = FiscalCalenderData.createValue();
			fiscalCalenderData.setBusEntityId(busEntityId);
			fiscalCalenderData.setShortDesc(fiscalCalendarYear);
			fiscalCalenderData.setPeriodCd("MONTHLY");
			fiscalCalenderData.setEffDate(FiscalStarDate);
			fiscalCalenderData.setAddDate(runDate);
			fiscalCalenderData.setAddBy(accountloader);
			fiscalCalenderData.setModDate(runDate);
			fiscalCalenderData.setModBy(accountloader);
			fiscalCalenderData.setFiscalYear(fiscalYear);
			fiscalCalenderData = FiscalCalenderDataAccess.insert(conn, fiscalCalenderData);
			fiscalCalenderId = fiscalCalenderData.getFiscalCalenderId();


		///========Add Fiscal Calender Detail====================
			pstmt = conn.prepareStatement(insertFiscalCalenderDetail);
			pstmt.setInt(1,fiscalCalenderId);
			String fcd[] = fiscalCalendarPeriod.split(",");
			int fPeriod = 0;
			for(String fc:fcd) {
				fc = fc.trim();
				fPeriod = fPeriod + 1;
			    pstmt.setInt(2,fPeriod);
			   	pstmt.setString(3, fc);
				pstmt.addBatch();

			}


			pstmt.executeBatch();
		}

			pstmt.close();

	if(productUiTemplate == null){
		log.info("PRODUCT UT TEMPLATE is NULL=" + productUiTemplate + "=");
	}else{
		createProductUiTemplate(conn,storeNum,busEntityId,productUiTemplate,accountloader);
	}


     	}catch(Exception e){
		e.printStackTrace();
		//throw e;
		   throw new RemoteException(
                   "Error.IntegrationServicesBean.processSiteDelivery()=> "
                           + e.getMessage());
	}


    }

    public void updateAccount(String accountloader,String accountActionAdd,String accountActionChange,int storeNum,String accountRefNum,Connection conn, String tmpTableName) throws RemoteException{
    	String accountName 					= "";
    	String accountType					= "";
    	String budgetType 					= "";
    	String timeZone 					= "";
    	String siteLlcOverride 				= "";
    	String customerServiceEmail 		= "";
    	String contactCcEmail 				= "";
    	String defaultEmail 				= "";
    	String distAccountRefNum 			= "";
    	String primaryContactFirstName 		= "";
    	String primaryContactLastName 		= "";
    	String primaryContactPhone 			= "";
    	String primaryContactFax 			= "";
    	String primaryContactEmail 			= "";
    	String primaryContactAddress1 		= "";
    	String primaryContactAddress2 		= "";
    	String primaryContactAddress3 		= "";
    	String primaryContactCity 			= "";
    	String primaryContactState 			= "";
    	String primaryContactCountry 		= "";
    	String primaryContactPostalCode 	= "";
    	String billingAddress1 				= "";
    	String billingAddress2 				= "";
    	String billingAddress3 				= "";
    	String billingCity 					= "";
    	String billingState 				= "";
    	String billingCountry 				= "";
    	String billingPostalCode 			= "";
    	String purchaseOrderAccountName 	= "";
    	String orderContactPhone 			= "";
    	String orderContactFax 				= "";
    	String orderGuideComments 			= "";
    	String orderGuideNotes 				= "";
    	String orderGuideSkuHeading 		= "";
    	String orderItemAction 				= "";
    	String taxableCd 					= "";
    	String allowUserToChangePasswd 		= "";
    	String enableInvOrderProcess 		= "";
    	String allowCustomerPoNum 			= "";
    	String authorizedResellingItems 	= "";
    	String showDistSkuNum 				= "";
    	String showDistDeliveryDate 		= "";
    	String modifyOrderQtyCostCenter 	= "";
    	String allowReorder					= "";
    	String createOrderByOrderAck 		= "";
    	String modernShoppingFolder 		= "";
    	String showInvItemPrice 			= "";
    	String displayMyShoppingList 		= "";
    	String expressOrder 				= "";
    	String deliveryCutoffDays 			= "";
    	String accountFolder 				= "";
    	String autoOrderQtyFactor 			= "";
    	String allowOrdInvItem 				= "";
    	String userPhysicalIng 				= "";
    	String shopUiType 					= "";
    	String faqLink 						= "";
    	String pdfOrderClassName 			= "";
    	String pdfOrderStatusName 			= "";
    	String reminderEmailSubject 		= "";
    	String reminderEmailMessage 		= "";
    	//Note - this method is not being updated for task 5107, since this method is only used
    	//by classes in the dataexchange package which Brook said can be ignored for this task.
    	String orderConfirmEmailGen 		= "";
    	String orderNotificationEmailGen 	= "";
    	String orderRejectedEmailGen 		= "";
    	String pendingApprovalEmail 		= "";
    	String invPropertyBudget 			= "";
    	String invPropertyPoSuffix 			= "";
    	String invPropertyOg	 			= "";
    	String invPropSendNotification 		= "";
    	String invPropDonotPlaceInvOrd 		= "";
    	String invPropDistPoType 			= "";
    	String fiscalCalendarYear 			= "";
    	String fiscalCalendarStart 			= "";
    	String fiscalCalendarPeriod		 	= "";
    	String allowToSetWorkorderPo 		= "";
    	String workOrderPoNumReq 			= "";
    	String userAssignedAsserNum 		= "";
    	String allowOrdPartsWorkOrder 		= "";
    	String populateContactInfo 			= "";
    	String productUiTemplate			= "";
    	String modifyCustPoNumBy855 		= "";
    	Date runDate = new Date();
    	int result = 0;

    	String selectSql = "select ACCOUNT_REF_NUM,ACCOUNT_NAME,ACCOUNT_TYPE,BUDGET_TYPE,TIME_ZONE, " +
    	    "SITE_LLC_OVERRIDE,CUSTOMER_SERVICE_EMAIL,CONTACT_CC_EMAIL,DEFAULT_EMAIL,DIST_ACCOUNT_REF_NUM, " +
    	    "PRIMARY_CONTACT_FIRST_NAME,PRIMARY_CONTACT_LAST_NAME,PRIMARY_CONTACT_PHONE,PRIMARY_CONTACT_FAX, " +
    	    "PRIMARY_CONTACT_EMAIL,PRIMARY_CONTACT_ADDESS1,PRIMARY_CONTACT_ADDESS2,PRIMARY_CONTACT_ADDESS3, " +
    	    "PRIMARY_CONTACT_CITY,PRIMARY_CONTACT_STATE,PRIMARY_CONTACT_COUNTRY,PRIMARY_CONTACT_POSTAL_CODE, " +
    	    "BILLING_ADDESS1,BILLING_ADDESS2,BILLING_ADDESS3,BILLING_CITY,BILLING_STATE,BILLING_COUNTRY, " +
    	    "BILLING_POSTAL_CODE,PURCHASE_ORDER_ACCOUNT_NAME,ORDER_CONTACT_PHONE,ORDER_CONTACT_FAX, " +
    	    "ORDER_GUIDE_COMMENTS,ORDER_GUIDE_NOTES,ORDER_GUIDE_SKU_HEADING,ORDER_ITEM_ACTION,TAXABLE, " +
    	    "ALLOW_USER_TO_CHANGE_PASSWORD,ENABLE_INVENTORY_ORDER_PROCESS,ALLOW_CUSTOMER_PO_NUM, " +
    	    "AUTHORIZED_RESELLING_ITEMS,SHOW_DIST_SKU_NUM,SHOW_DIST_DELIVERY_DATE,MODIFY_ORDER_QTY_COST_CENTER, " +
    	    "ALLOW_REORDER,CREATE_ORDER_BY_ORDER_ACK,MODER_SHOPPING_FOLDER,SHOW_INVENTORY_ITEM_PRICE, " +
    	    "DISPLAY_MY_SHOPPING_LIST,EXPRESS_ORDER,DELIVERY_CUTOFF_DAYS,ACCOUNT_FOLDER,AUTO_ORDER_QTY_FACTOR, " +
    	    "ALLOW_ORD_INV_ITEM,USER_PHYSICAL_ING,SHOP_UI_TYPE,FAQ_LINK,PDF_ORDER_CLASS_NAME,PDF_ORDER_STATUS_NAME, " +
    	    "REMINDER_EMAIL_SUBJECT,REMINDER_EMAIL_MESSAGE,ORDER_CONFIRM_EMAIL_GEN,ORDER_NOTIFICATION_EMAIL_GEN, " +
    	    "ORDER_REJECTED_EMAIL_GEN,PENDING_APPROVAL_EMAIL,INVENTORY_PROPERTY_BUDGET,INVENTORY_PROPERTY_PO_SUFFIX, " +
    	    "INVENTORY_PROPERTY_OG,INV_PROPERTY_SEND_NOTIFICATION,INV_PROP_DONOT_PLACE_INV_ORDER,INV_PROP_DIST_PO_TYPE, " +
    	    "FISCAL_CALENDAR_YEAR,FISCAL_CALENDAR_START,FISCAL_CALENDAR_PERIOD,ALLOW_TO_SET_WORKORDER_PO, " +
    	    "WORK_ORDER_PO_NUM_REQ,USER_ASSIGNED_ASSET_NUM,ALLOW_ORDER_PARTS_WORKORDER,POPULATE_CONTACT_INFO,PRODUCT_UI_TEMPLATE " +
    	    "from " + tmpTableName + " where ACCOUNT_REF_NUM = ? and action in(?,?)";

        String selectCheckAccount = "select bus_Entity_id from clw_bus_entity where bus_entity_type_cd = ? " +
        "and bus_entity_id in(select bus_entity_id from clw_property where bus_entity_id in " +
        "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
        "and short_desc = ? and clw_value = ?)";

    	String updateAccount = "update clw_bus_entity set short_desc = ?,mod_by=?,bus_entity_status_cd = ?," +
    			"mod_date=sysdate where bus_entity_id = ?";

    	String updateAddress = "update clw_address set name1 = ?,name2 =?,address1=?,address2=?,address3=?," +
		"city=?,state_province_cd=?,country_cd=?,postal_code=?,mod_by=?,mod_date=sysdate " +
		"where bus_entity_id = ? and address_type_cd = ?";

    	String updatePhone = "update clw_phone set phone_num = ?,mod_by = ?,mod_date=sysdate " +
    			"where bus_entity_id = ? and phone_type_cd = ?";

    	String updateEmail = "update clw_email set email_address = ?,mod_by = ?,mod_date = sysdate " +
    	"where bus_entity_id = ? and email_type_cd = ?";

    	String updateProperty = "update clw_property set clw_value = ?,mod_by = ?,mod_date = sysdate " +
    			"where bus_entity_id = ? and short_desc = ?";

    	String deleteOrderItemAction = "delete from clw_property where bus_entity_id = ? and short_desc = ?";

    	String insertPropertySql = "Insert into clw_property (PROPERTY_ID,BUS_ENTITY_ID,USER_ID,SHORT_DESC," +
    	"CLW_VALUE,PROPERTY_STATUS_CD,PROPERTY_TYPE_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY,LOCALE_CD) " +
		"values (clw_property_seq.NEXTVAL,?,null,?,?,'ACTIVE',?,sysdate,'" + accountloader + "',sysdate," +
		"'" + accountloader + "',null)";

/*
    	String selectFiscalCalenderId = "select fiscal_calender_id from clw_fiscal_calender where bus_entity_id = ? " +
    			" and fiscal_year = ?";

    	String deleteFiscalCalenderDetail = "delete from clw_fiscal_calender_detail where fiscal_calender_id = ?";

    	String insertFiscalCalenderDetail = "insert into clw_fiscal_calender_detail(fiscal_calender_detail_id," +
		"fiscal_calender_id,period,mmdd,add_date,add_by,mod_date,mod_by) " +
		"values(clw_fiscal_calender_detail_seq.nextval,?,?,?,sysdate,'" + accountloader + "'," +
		"sysdate,'" + accountloader + "')";
*/
        int accountId = 0;
        try{

    		int count = 0;
    		PreparedStatement pstmt = conn.prepareStatement(selectCheckAccount);

			pstmt.setString(1, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			pstmt.setInt(2,storeNum);
			pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setString(4, accountRefNum);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				accountId = rs.getInt(1);
			}
			pstmt.close();

        pstmt = conn.prepareStatement(selectSql);
		pstmt.setString(1, accountRefNum);
		pstmt.setString(2, accountActionAdd);
		pstmt.setString(3, accountActionChange);

		rs = pstmt.executeQuery();
		while(rs.next()) {

			accountRefNum 				= rs.getString(1);
			accountName 		 		= rs.getString(2);
			accountType 		 		= rs.getString(3);
			budgetType 		 			= rs.getString(4);
			timeZone 		 			= rs.getString(5);
			siteLlcOverride 		 	= rs.getString(6);
			customerServiceEmail 	 	= rs.getString(7);
			contactCcEmail 		 		= rs.getString(8);
			defaultEmail 		 		= rs.getString(9);
			distAccountRefNum 	 		= rs.getString(10);
			primaryContactFirstName 	= rs.getString(11);
			primaryContactLastName 	 	= rs.getString(12);
			primaryContactPhone 	 	= rs.getString(13);
			primaryContactFax 	 		= rs.getString(14);
			primaryContactEmail 	 	= rs.getString(15);
			primaryContactAddress1 	 	= rs.getString(16);
			primaryContactAddress2 	 	= rs.getString(17);
			primaryContactAddress3 	 	= rs.getString(18);
			primaryContactCity 	 		= rs.getString(19);
			primaryContactState 	 	= rs.getString(20);
			primaryContactCountry 	 	= rs.getString(21);
			primaryContactPostalCode  	= rs.getString(22);
			billingAddress1 			= rs.getString(23);
			billingAddress2 			= rs.getString(24);
			billingAddress3 			= rs.getString(25);
			billingCity 		 		= rs.getString(26);
			billingState 		 		= rs.getString(27);
			billingCountry 		 		= rs.getString(28);
			billingPostalCode 	 		= rs.getString(29);
			purchaseOrderAccountName  	= rs.getString(30);
			orderContactPhone 	 		= rs.getString(31);
			orderContactFax 			= rs.getString(32);
			orderGuideComments 	 		= rs.getString(33);
			orderGuideNotes 			= rs.getString(34);
			orderGuideSkuHeading 	 	= rs.getString(35);
			orderItemAction 			= rs.getString(36);
			taxableCd 		 			= rs.getString(37);
			allowUserToChangePasswd 	= rs.getString(38);
			enableInvOrderProcess 	 	= rs.getString(39);
			allowCustomerPoNum 	 		= rs.getString(40);
			authorizedResellingItems  	= rs.getString(41);
			showDistSkuNum 		 		= rs.getString(42);
			showDistDeliveryDate 	 	= rs.getString(43);
			modifyOrderQtyCostCenter  	= rs.getString(44);
			allowReorder 		 		= rs.getString(45);
			createOrderByOrderAck 	 	= rs.getString(46);
			modernShoppingFolder 	 	= rs.getString(47);
			showInvItemPrice 	 		= rs.getString(48);
			displayMyShoppingList 	 	= rs.getString(49);
			expressOrder 		 		= rs.getString(50);
			deliveryCutoffDays 	 		= rs.getString(51);
			accountFolder 		 		= rs.getString(52);
			autoOrderQtyFactor 	 		= rs.getString(53);
			allowOrdInvItem 			= rs.getString(54);
			userPhysicalIng 			= rs.getString(55);
			shopUiType 		 			= rs.getString(56);
			faqLink 					= rs.getString(57);
			pdfOrderClassName 	 		= rs.getString(58);
			pdfOrderStatusName 	 		= rs.getString(59);
			reminderEmailSubject 	 	= rs.getString(60);
			reminderEmailMessage 	 	= rs.getString(61);
			orderConfirmEmailGen 	 	= rs.getString(62);
			orderNotificationEmailGen 	= rs.getString(63);
			orderRejectedEmailGen 	 	= rs.getString(64);
			pendingApprovalEmail 	 	= rs.getString(65);
			invPropertyBudget 	 		= rs.getString(66);
			invPropertyPoSuffix 	 	= rs.getString(67);
			invPropertyOg 		 		= rs.getString(68);
			invPropSendNotification 	= rs.getString(69);
			invPropDonotPlaceInvOrd 	= rs.getString(70);
			invPropDistPoType 	 		= rs.getString(71);
			fiscalCalendarYear 	 		= rs.getString(72);
			fiscalCalendarStart 	 	= rs.getString(73);
			fiscalCalendarPeriod 	 	= rs.getString(74);
			allowToSetWorkorderPo 	 	= rs.getString(75);
			workOrderPoNumReq 	 		= rs.getString(76);
			userAssignedAsserNum 	 	= rs.getString(77);
			allowOrdPartsWorkOrder 	 	= rs.getString(78);
			populateContactInfo 	 	= rs.getString(79);
			productUiTemplate			= rs.getString(80);
		}

		pstmt.close();

		//Update account name
		log.info("1111111111111111111111 Update update BUS_ENTITY short_desc!!!!! account_id =:" + accountId);
		pstmt = conn.prepareStatement(updateAccount);
		pstmt.setString(1,accountName);
		pstmt.setString(2,accountloader);
		pstmt.setString(3,RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
		pstmt.setInt(4,accountId);
		pstmt.addBatch();
		pstmt.executeBatch();
		pstmt.close();

		//Update Primary address

		if(primaryContactCountry != null){
		pstmt = conn.prepareStatement(updateAddress);
		log.info("2222222222222 Update update PRIMARY ADDRESS short_desc!!!!! account_id =:" + accountId);
		pstmt = conn.prepareStatement(updateAddress);
		pstmt.setString(1,primaryContactFirstName);
		pstmt.setString(2,primaryContactLastName);
		pstmt.setString(3,primaryContactAddress1);
		pstmt.setString(4,primaryContactAddress2);
		pstmt.setString(5,primaryContactAddress3);
		pstmt.setString(6,primaryContactCity);
		pstmt.setString(7,primaryContactState);
		pstmt.setString(8,primaryContactCountry);
		pstmt.setString(9,primaryContactPostalCode);
		pstmt.setString(10,accountloader);
		pstmt.setInt(11,accountId);
		pstmt.setString(12,RefCodeNames.ADDRESS_TYPE_CD.PRIMARY_CONTACT);
		pstmt.addBatch();
		pstmt.executeBatch();
		pstmt.close();
		}
		//Update Billing Address
		pstmt = conn.prepareStatement(updateAddress);
		log.info("33333333333 Update update Billing ADDRESS short_desc!!!!! account_id =:" + accountId);
		pstmt.setString(1,primaryContactFirstName);
		pstmt.setString(2,primaryContactLastName);
		pstmt.setString(3,billingAddress1);
		pstmt.setString(4,billingAddress2);
		pstmt.setString(5,billingAddress3);
		pstmt.setString(6,billingCity);
		pstmt.setString(7,billingState);
		pstmt.setString(8,billingCountry);
		pstmt.setString(9,billingPostalCode);
		pstmt.setString(10,accountloader);
		pstmt.setInt(11,accountId);
		pstmt.setString(12,RefCodeNames.ADDRESS_TYPE_CD.BILLING);
		pstmt.addBatch();
		pstmt.executeBatch();
		pstmt.close();
		//Update Phone Numbers


		pstmt = conn.prepareStatement(updatePhone);
		log.info("444444444444 Update update PRIMARY phone short_desc!!!!! account_id =:" + accountId);
		//Update Phone Primary
		pstmt.setString(1,primaryContactPhone);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.PHONE);
		pstmt.addBatch();

		log.info("555555555555 Update update PRIMARY fax short_desc!!!!! account_id =:" + accountId);
		//Update Fax Primary
		pstmt.setString(1,primaryContactFax);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.FAX);
		pstmt.addBatch();

		//Update Order Contact Phone
		log.info("6666666666666 Update update order contact phone short_desc!!!!! account_id =:" + accountId);
		pstmt.setString(1,orderContactPhone);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.ORDERPHONE);
		pstmt.addBatch();

		log.info("777777777777777 Update update order contact fax short_desc!!!!! account_id =:" + accountId);
		//Update Order Contact Fax
		pstmt.setString(1,orderContactFax);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.ORDERFAX);
		pstmt.addBatch();

		pstmt.executeBatch();
		pstmt.close();

		//Update Email Address
		pstmt = conn.prepareStatement(updateEmail);
		log.info("8888888888888 Update update DEFAULT Email short_desc!!!!! account_id =:" + accountId);
		//Update Email default
		pstmt.setString(1,defaultEmail);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.EMAIL_TYPE_CD.DEFAULT);
		pstmt.addBatch();
		//pstmt.executeBatch();

		//Update Customer Service
		log.info("99999999999999 Update update Customer Service Email short_desc!!!!! account_id =:" + accountId);
		pstmt.setString(1,customerServiceEmail);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.EMAIL_TYPE_CD.CUSTOMER_SERVICE);
		pstmt.addBatch();
		//pstmt.executeBatch();

		//Update Primary Email
		log.info("10101010101010 Update update Primary Contact Email short_desc!!!!! account_id =:" + accountId);
		pstmt.setString(1,primaryContactEmail);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT);
		pstmt.addBatch();

		pstmt.executeBatch();
		pstmt.close();

		//Update ALL Properties
		pstmt = conn.prepareStatement(updateProperty);
		//Update Property Budget Type
		log.info("11111111111 1111  11111 11111 Update update Primary Contact Email short_desc!!!!! account_id =:" + accountId);
		pstmt.setString(1,budgetType);
		pstmt.setString(2,accountloader);
		pstmt.setInt(3,accountId);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.BUDGET_ACCRUAL_TYPE_CD);
		pstmt.addBatch();

		//Update Property Account Type

		log.info("12 12 12 12 12 12 12 12 12 Update update Primary Contact Email short_desc!!!!! account_id =:" + accountId);
		if(accountType == null){
			accountType = "Other";
		}

		pstmt.setString(1,accountType);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ACCOUNT_TYPE);
		pstmt.addBatch();



		//Update Property ALLOW_SITE_LLC
		pstmt.setString(1,siteLlcOverride);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_SITE_LLC);
		pstmt.addBatch();

		//Update Property Order guide Notes
		pstmt.setString(1,orderGuideNotes);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ORDER_GUIDE_NOTE);
		pstmt.addBatch();

		//Update Property Order guide Comments
		pstmt.setString(1,orderGuideComments);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.COMMENTS);
		pstmt.addBatch();

		//Update Property order guide sku headings
		pstmt.setString(1,orderGuideSkuHeading);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SKU_TAG);
		pstmt.addBatch();

		//Update Property Taxable
		result = taxableCd.compareToIgnoreCase("true");
		if(result == 0){
			taxableCd = "Y";
		}else {
			taxableCd = "N";
		}

		pstmt.setString(1,taxableCd);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.TAXABLE_INDICATOR);
		pstmt.addBatch();


		//Update Property Allow Users to Change Password
		pstmt.setString(1,allowUserToChangePasswd);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_USER_CHANGE_PASSWORD);
		pstmt.addBatch();


		//Update Property Enable Inventory Order Processing
		pstmt.setString(1,enableInvOrderProcess);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_SCHED_DELIVERY);
		pstmt.addBatch();


		//Update Property Allow Customer to enter PO Number
		pstmt.setString(1,allowCustomerPoNum);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_CUSTOMER_PO_NUMBER);
		pstmt.addBatch();

		//Update Property Authorize Customer for Resell
		pstmt.setString(1,authorizedResellingItems);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.AUTHORIZED_FOR_RESALE);
		pstmt.addBatch();

		//Update Property Display Rebill Order in Checkout
		pstmt.setString(1,authorizedResellingItems);
		pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.SHOW_REBILL_ORDER);
		pstmt.addBatch();

		//Update Property Show Distributor SKU Number
		pstmt.setString(1,showDistSkuNum);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_DIST_SKU_NUM);
		pstmt.addBatch();

		//Update Property Show Distributor Delivery Date
		pstmt.setString(1,showDistDeliveryDate);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_DIST_DELIVERY_DATE);
		pstmt.addBatch();


		//Update Property Modify Order Qty and cost by order Acknowledgement(855)
		pstmt.setString(1,modifyOrderQtyCostCenter);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ADJUST_QTY_BY_855);
		pstmt.addBatch();

		//Update Property Allow Reorder
		pstmt.setString(1,allowReorder);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_REORDER);
		pstmt.addBatch();

		//Update Property Create Order by Order Acknowledgement 855
		pstmt.setString(1,createOrderByOrderAck);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.CREATE_ORDER_BY_855);
		pstmt.addBatch();


		//Update Property Moder Shopping Folder
		pstmt.setString(1,modernShoppingFolder);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_MODERN_SHOPPING);
		pstmt.addBatch();

		//Update Property Show inventory items price in cart total
		pstmt.setString(1,showInvItemPrice);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_INV_CART_TOTAL);
		pstmt.addBatch();


		//Update Property Display my Shopping List
		pstmt.setString(1,displayMyShoppingList);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_MY_SHOPPING_LISTS);
		pstmt.addBatch();

		//Update Property Express Order
		pstmt.setString(1,expressOrder);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOW_EXPRESS_ORDER);
		pstmt.addBatch();

		//Update Property Delivery Cutt Off Days
		pstmt.setString(1,deliveryCutoffDays);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SCHEDULE_CUTOFF_DAYS);
		pstmt.addBatch();


		//Update Property Account Folder
		pstmt.setString(1,accountFolder);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ACCOUNT_FOLDER);
		pstmt.addBatch();

		//Update Property Auto Order Qty Factor
		pstmt.setString(1,autoOrderQtyFactor);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.AUTO_ORDER_FACTOR);
		pstmt.addBatch();

		//Update Property Allow Order Inventory items in schedule cart period
		pstmt.setString(1,allowOrdInvItem);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_ORDER_INV_ITEMS);
		pstmt.addBatch();

		//Update Property Use Physical Inventory
		pstmt.setString(1,userPhysicalIng);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.USE_PHYSICAL_INVENTORY);
		pstmt.addBatch();

		//Update Property Shop UI Type
		pstmt.setString(1,shopUiType);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.SHOP_UI_TYPE);
		pstmt.addBatch();

		//Update Property Order Class Name
		pstmt.setString(1,pdfOrderClassName);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.PDF_ORDER_CLASS);
		pstmt.addBatch();

		//Update Property Order Status Class Name
		pstmt.setString(1,pdfOrderStatusName);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.PDF_ORDER_STATUS_CLASS);
		pstmt.addBatch();


		//Update Property Reminder Email Subject
		pstmt.setString(1,reminderEmailSubject);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.REMINDER_EMAIL_SUBJECT);
		pstmt.addBatch();


		//Update Property Reminder Email Mesaage
		pstmt.setString(1,reminderEmailMessage);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.REMINDER_EMAIL_MSG);
		pstmt.addBatch();


		//Update Property Reminder Email Mesaage
		pstmt.setString(1,orderConfirmEmailGen);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.CONFIRM_ORDER_EMAIL_GENERATOR);
		pstmt.addBatch();

		//Update Property Order notification Email generator
		pstmt.setString(1,orderNotificationEmailGen);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.NOTIFY_ORDER_EMAIL_GENERATOR);
		pstmt.addBatch();

		//Update Property Order Rejected Email generator
		pstmt.setString(1,orderRejectedEmailGen);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.REJECT_ORDER_EMAIL_GENERATOR);
		pstmt.addBatch();

		//Update Property Pending Approval Email Generator
		pstmt.setString(1,pendingApprovalEmail);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.PENDING_APPROV_EMAIL_GENERATOR);
		pstmt.addBatch();

		//Update Property Inventory Property PO Suffix
		pstmt.setString(1,invPropertyPoSuffix);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_PO_SUFFIX);
		pstmt.addBatch();

		//Update Property Inventory Property OG UI
		pstmt.setString(1,invPropertyOg);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_OG_LIST_UI);
		pstmt.addBatch();

		//Update Property Inventory Property Send Notification If Auto Order Applies(hours)
		pstmt.setString(1,invPropSendNotification);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_MISSING_NOTIFICATION);
		pstmt.addBatch();

		//Update Property Inventory Property Do not place Inv order if site order exists(days)
		pstmt.setString(1,invPropDonotPlaceInvOrd);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_CHECK_PLACED_ORDER);
		pstmt.addBatch();

		//Update Property Inventory Property Distributor PO Type
		pstmt.setString(1,invPropDistPoType);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.DISTR_PO_TYPE);
		pstmt.addBatch();

		//Update Property Inventory Property Budget(off)
		result = invPropertyBudget.compareToIgnoreCase("true");
		if(result == 0){
			invPropertyBudget = "ON";
		}else {
			invPropertyBudget = "OFF";
		}
		pstmt.setString(1,invPropertyBudget);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.INVENTORY_LEDGER_SWITCH);
		pstmt.addBatch();

		//Update Property Allow to set Work order PO Number
		pstmt.setString(1,allowToSetWorkorderPo);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_SET_WORKORDER_PO_NUMBER);
		pstmt.addBatch();

		//Update Property Work order PO Number is Required
		pstmt.setString(1,workOrderPoNumReq);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.WORK_ORDER_PO_NUM_REQUIRED);
		pstmt.addBatch();

		//Update Property User Assigned Asset Number
		pstmt.setString(1,userAssignedAsserNum);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.USER_ASSIGNED_ASSET_NUMBER);
		pstmt.addBatch();

		//Update Property Allow to order parts for work order
		pstmt.setString(1,allowOrdPartsWorkOrder);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.ALLOW_BUY_WORK_ORDER_PARTS);
		pstmt.addBatch();

		//Update Property Modify customer po number by Order Acknowledgement 855
		pstmt.setString(1,createOrderByOrderAck);
		pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.MODIFY_CUST_PO_NUM_BY_855);
		pstmt.addBatch();

		pstmt.executeBatch();
		pstmt.close();

		//Delete All order Item action and Add then Again

		pstmt = conn.prepareStatement(deleteOrderItemAction);
		pstmt.setInt(1,accountId);
		pstmt.setString(2,RefCodeNames.PROPERTY_TYPE_CD.ALLOWED_RUNTIME_ORD_ITM_ACT);
		pstmt.addBatch();
		pstmt.executeBatch();
		pstmt.close();

		//Add Order Item Action Property
		pstmt = conn.prepareStatement(insertPropertySql);
		pstmt.setInt(1,accountId);
		String sp[] = orderItemAction.split(",");
		  for(String s:sp) {
			s = s.trim();
		   	pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.ALLOWED_RUNTIME_ORD_ITM_ACT);
			pstmt.setString(3, s);
			pstmt.setString(4, RefCodeNames.PROPERTY_TYPE_CD.ALLOWED_RUNTIME_ORD_ITM_ACT);
			pstmt.addBatch();
		  }

		  pstmt.executeBatch();
		  pstmt.close();

         updateFiscalCalendar(conn, accountId, fiscalCalendarYear, fiscalCalendarStart, fiscalCalendarPeriod, accountloader );

         if(productUiTemplate == null){
        	 log.info("PRODUCT UT TEMPLATE is NULL=" + productUiTemplate + "=");
     	}else{
     		updateProductUiTemplate(conn,storeNum,accountId,productUiTemplate,accountloader);
     	}

        }catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateAccount()=> "
                               + e.getMessage());
    	}

    }

    public void createProductUiTemplate(Connection conn,int storeNum,int accountId,String accountNameTemplate,String accountloader) throws RemoteException{
    	log.info("Start createProductUiTemplate");
    	int accountTemplateId = 0;

    	accountTemplateId = getAccountIdByName(conn,accountNameTemplate,storeNum);
    	if(accountTemplateId == 0){
    		throw new IllegalArgumentException("Error.IntegrationServicesBean.createProductUiTemplate() account not found or inactive acctName = " + accountNameTemplate + "storeId=" + storeNum);
    	}

    	String insertProductView = "insert into clw_product_view_def(product_view_def_id,status_cd,account_id, " +
    				"attributename,sort_order,width,style_class,product_view_cd,add_date,add_by,mod_date,mod_by) " +
    				"select clw_product_view_def_seq.nextval,status_cd," + accountId + ",attributename,sort_order, " +
    				"width,style_class,product_view_cd,sysdate,'" + accountloader + "',sysdate,'" + accountloader + "' from " +
    				"clw_product_view_def where account_id =" + accountTemplateId + " and status_cd = 'ACTIVE' and product_view_cd in('SHOP_UI_DEFAULT','SHOP_UI_DETAIL')";


    	try{

    	PreparedStatement pstmt = conn.prepareStatement(insertProductView);
    	pstmt.executeUpdate();
    	pstmt.close();

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createProductUiTemplate()=> "
                               + e.getMessage());
    	}

    }


    public void updateProductUiTemplate(Connection conn,int storeNum,int accountId,String accountNameTemplate,String accountloader) throws RemoteException{
    	log.info("Start updateProductUiTemplate");
    	int accountTemplateId = 0;

    	String deleteProductView = "delete from clw_product_view_def where account_id = ?";

    	accountTemplateId = getAccountIdByName(conn,accountNameTemplate,storeNum);
    	if(accountTemplateId == 0){
    		throw new IllegalArgumentException("Error.IntegrationServicesBean.updateProductUiTemplate() account not found or inactive acctName = " + accountNameTemplate + "storeId=" + storeNum);
    	}

    	String insertProductView = "insert into clw_product_view_def(product_view_def_id,status_cd,account_id, " +
    				"attributename,sort_order,width,style_class,product_view_cd,add_date,add_by,mod_date,mod_by) " +
    				"select clw_product_view_def_seq.nextval,status_cd," + accountId + ",attributename,sort_order, " +
    				"width,style_class,product_view_cd,sysdate,'" + accountloader + "',sysdate,'" + accountloader + "' from " +
    				"clw_product_view_def where account_id =" + accountTemplateId + " and status_cd = 'ACTIVE' and product_view_cd in('SHOP_UI_DEFAULT','SHOP_UI_DETAIL')";


    	try{

    	PreparedStatement pstmt = conn.prepareStatement(deleteProductView);
    	pstmt.setInt(1, accountId);
    	pstmt.executeUpdate();
    	pstmt.close();

    	pstmt = conn.prepareStatement(insertProductView);
    	pstmt.executeUpdate();
    	pstmt.close();

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateProductUiTemplate()=> "
                               + e.getMessage());
    	}

    }

    public int getAccountIdByName(Connection conn,String accountName,int storeNum) throws RemoteException{
    	 	String selectAccount = "select bus_entity_id from clw_bus_entity where upper(short_desc) = ? " +
    		 "and bus_entity_id in(select bus_entity_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
    		 "and bus_entity_type_cd = 'ACCOUNT' and bus_entity_status_cd = 'ACTIVE'";

    	 	int accountId = 0;
    	 	accountName = accountName.toUpperCase();
    	 	try{
    	 		PreparedStatement pstmt = conn.prepareStatement(selectAccount);
    	 		pstmt.setString(1, accountName);
    	 		pstmt.setInt(2,storeNum);
    	 		ResultSet rs = pstmt.executeQuery();
    			while(rs.next()){
    				accountId = rs.getInt(1);
    			}

    			pstmt.close();
    			return accountId;
    	 	}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.getAccountIdByName()=> "
                                   + e.getMessage());
        	}


    }

    public void inactivateAccount(String accountloader,String accountActionDelete,int storeNum,String accRefNum,Connection conn) throws RemoteException{

    	String selectAccount = "select bus_entity_id from clw_bus_entity where bus_entity_type_cd = ? " +
    	        "and bus_entity_id in(select bus_entity_id from clw_property where bus_entity_id in " +
    	        "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
    	        "and short_desc = ? and clw_value = ?)";

    	String updateAccount = "update clw_bus_entity set bus_entity_status_cd = ?,mod_by = ?,mod_date = sysdate " +
    	"where bus_entity_type_cd = ? and bus_entity_id = ?";

    	int accountId = 0;
    	log.info("ACCOUNT TO INACTIVATE sql =" + selectAccount);
    	try{
    	PreparedStatement pstmt = conn.prepareStatement(selectAccount);
		pstmt.setString(1, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
		pstmt.setInt(2,storeNum);
		pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
		pstmt.setString(4, accRefNum);
		ResultSet rs = pstmt.executeQuery();
		while(rs.next()){
			accountId = rs.getInt(1);
		}

		pstmt.close();
		log.info("ACCOUNT TO INACTIVATE 33333333333333333333333333333333333333333333333333333333333");
		log.info("ACCOUNT TO INACTIVATE 33333333333333333333333333333333333333333333333333333333333");
		log.info("ACCOUNT TO INACTIVATE 33333333333333333333333333333333333333333333333333333333333");
		log.info("ACCOUNT TO INACTIVATE 3333 account id = " + accountId);

		log.info("ACCOUNT TO INACTIVATE 4444444444444444444444444444444 sql update " + updateAccount);
		pstmt = conn.prepareStatement(updateAccount);
		pstmt.setString(1,RefCodeNames.BUS_ENTITY_STATUS_CD.INACTIVE);
		pstmt.setString(2,accountloader);
		pstmt.setString(3,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
		pstmt.setInt(4,accountId);
		pstmt.addBatch();
		pstmt.executeBatch();
		pstmt.close();


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.inactivateAccount()=> "
                               + e.getMessage());
    	}
    }

    public void updateCategorySortOrder(Connection conn, String itemloader, int storeNum, int storeCatalogId, List allCategories) throws RemoteException{
    	
		log.info("Updating category sort order START");
    	
    	String updateSortOrder = "update clw_catalog_structure "+
    			"set sort_order = ? , mod_date = ? , mod_by = ? "+
    			"where item_id = ? and sort_order != ?"+
    			"and catalog_id in "+
    			"( "+
    			"select distinct c.catalog_id "+
    			"from clw_catalog c, clw_catalog_assoc ca "+
    			"where ca.catalog_id = c.catalog_id "+
    			"and c.catalog_status_cd= ? "+
    			"and c.catalog_type_cd in (?,?) "+
    			"and ca.bus_entity_id = ? "+
    			")";
    	
    	HashMap categorySortOrderMap = new HashMap();
    	try{
    		//Get category sort order from store catalog
    		DBCriteria crit = new DBCriteria();
        	crit.addEqualTo(CatalogStructureDataAccess.CATALOG_ID, storeCatalogId);
        	crit.addOneOf(CatalogStructureDataAccess.ITEM_ID, Utility.toCommaSting(allCategories));
        	crit.addEqualTo(CatalogStructureDataAccess.STATUS_CD, RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
        	
        	CatalogStructureDataVector csDV = (CatalogStructureDataVector)CatalogStructureDataAccess.select(conn, crit);
        	
        	Iterator it = csDV.iterator();
        	while(it.hasNext()){
        		CatalogStructureData csD = (CatalogStructureData)it.next();
        		if(!categorySortOrderMap.containsKey(csD.getItemId())){
        			categorySortOrderMap.put(csD.getItemId(), csD.getSortOrder());
        		}
        	}
        	
        	//Update all catalogs structures where sort order is different from store catalog

    		PreparedStatement pstmt = conn.prepareStatement(updateSortOrder);
    		
        	Iterator it2 = allCategories.iterator();
        	while(it2.hasNext()){
        		int thisCat = ((Integer)it2.next()).intValue();
        		int thisSortOrder = ((Integer)categorySortOrderMap.get(thisCat)).intValue();
        		
        		pstmt.setInt(1, thisSortOrder);
        		pstmt.setTimestamp(2,DBAccess.toSQLTimestamp(new Date()));
        		pstmt.setString(3, itemloader);
        		pstmt.setInt(4, thisCat);
        		pstmt.setInt(5, thisSortOrder);
        		pstmt.setString(6, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
        		pstmt.setString(7, RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
        		pstmt.setString(8, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
        		pstmt.setInt(9, storeNum);
        		
        		pstmt.addBatch();
        		
        	}
        	pstmt.executeBatch();
			pstmt.close();
    		
			log.info("Updating category sort order END");
    		
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateCategorySortOrder()=> "
                               + e.getMessage());
    	}
    	
    }
    
    public void updateItemInCatalogs(Connection conn, int storeNum, String itemloader, int itemId) throws RemoteException{
    	
    	String itemAssocs = "select item_assoc_id, item1_id, item2_id, catalog_id, item_assoc_cd from clw_item_assoc "+
    			"where item1_id = ? "+
    			"and item_assoc_cd= ? "+
    			"and catalog_id in "+
    			"( "+
    			"select distinct c.catalog_id "+
    			"from clw_catalog c, clw_catalog_assoc ca "+
    			"where ca.catalog_id = c.catalog_id "+
    			"and c.catalog_status_cd= ? "+
    			"and c.catalog_type_cd in (?,?) "+
    			"and ca.bus_entity_id = ? "+
    			")";
    	
    	String catalogStructures = "select catalog_id from( "+
    			"select c.catalog_id, cs.item_id, cs1.item_id as categ_id "+
    			"from clw_catalog c, "+
    			"clw_catalog_assoc ca, "+
    			"clw_catalog_structure cs, "+
    			"clw_catalog_structure cs1 "+
    			"where "+
    			"ca.bus_entity_id = ? "+
    			"and c.catalog_id = ca.catalog_id "+
    			"and c.catalog_type_cd in (?,?) "+
    			"and c.catalog_status_cd = ? "+
    			"and cs.catalog_id = c.catalog_id "+
    			"and cs.item_id = ? "+
    			"and cs1.catalog_id(+) = c.catalog_id "+
    			"and cs1.item_id(+) = ? "+
    			") where categ_id is null" ;
    	
		IdVector itemV = new IdVector();
		itemV.add(itemId);
    	try{
    		
    		int storeCatalogId = getStoreCatalog(conn,storeNum);
    		HashMap itemChainByProductMap = getItemChainByProduct(conn,  itemV,  storeCatalogId);
    		int lowestLevelCat = 0;
    		List allCategories = new ArrayList();
    		List allCatalogs = new ArrayList();
    			
    		ItemAssocDataVector iaDV = (ItemAssocDataVector)itemChainByProductMap.get(itemId);
    		Iterator it = iaDV.iterator();
    		while(it.hasNext()){
    			ItemAssocData iaD = (ItemAssocData)it.next();
    			if(iaD.getItemAssocCd().equals(RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY)){
    				lowestLevelCat = iaD.getItem2Id();
    			}
    			allCategories.add(iaD.getItem2Id());
    			
    		}
    		
    		//Update item assocs for account,shopping catalogs
    		
			PreparedStatement pstmt = conn.prepareStatement(itemAssocs);
			pstmt.setInt(1, itemId);
			pstmt.setString(2, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
			pstmt.setString(3,RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			pstmt.setString(4, RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
			pstmt.setString(5, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
			pstmt.setInt(6, storeNum);
			
			ResultSet rs = pstmt.executeQuery();
			ItemAssocDataVector updateItemAssocV = new ItemAssocDataVector();
			while(rs.next()){
				
				int catalogId = rs.getInt(4);
				if(!allCatalogs.contains(catalogId)){
					allCatalogs.add(catalogId);
				}
				
				int thisCategory = rs.getInt(3);
				
				if(thisCategory != lowestLevelCat){
					
					ItemAssocData iaD = ItemAssocData.createValue();
					iaD.setItemAssocId(rs.getInt(1));
					iaD.setItem1Id(itemId);
					iaD.setItem2Id(lowestLevelCat);
					iaD.setItemAssocCd(rs.getString(5));
					iaD.setCatalogId(catalogId);
					iaD.setModBy(itemloader);
					iaD.setModDate(new Date());
					updateItemAssocV.add(iaD);
				}
			}
			
			pstmt.close();
			
			log.info("Updating itemAssocs START");
			if(Utility.isSet(updateItemAssocV)){
				String updateSql = "update clw_item_assoc "+
						"set item2_id = ? , mod_by = ? , mod_date= ? "+
						"where item_assoc_id = ?";
				pstmt = conn.prepareStatement(updateSql);
				Iterator it2 = updateItemAssocV.iterator();
				while(it2.hasNext()){
					ItemAssocData iaD = (ItemAssocData)it2.next();
					pstmt.setInt(1, iaD.getItem2Id());
					pstmt.setString(2, iaD.getModBy());
					pstmt.setTimestamp(3,DBAccess.toSQLTimestamp(iaD.getModDate()));
					pstmt.setInt(4, iaD.getItemAssocId());
					pstmt.addBatch();
				}
				pstmt.executeBatch();
				pstmt.close();
			}
			log.info("Updating itemAssocs END");
			
    		//Check if all categories exists in these account,shopping catalogs which contain itemId
			List insertCatalogStructures = new ArrayList();
			
			Iterator it3 = allCategories.iterator();
			while(it3.hasNext()){
				
				Integer categoryId = (Integer) it3.next();
				
				pstmt = conn.prepareStatement(catalogStructures);
				pstmt.setInt(1, storeNum);
				pstmt.setString(2, RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
				pstmt.setString(3, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
				pstmt.setString(4,RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
				pstmt.setInt(5, itemId);
				pstmt.setInt(6, categoryId.intValue());
				
				rs = pstmt.executeQuery();
				
				while(rs.next()){
					int thisCatalogId = rs.getInt(1);
					CatalogStructureData csD = CatalogStructureData.createValue();
					csD.setItemId(categoryId.intValue());
					csD.setCatalogId(thisCatalogId);
					csD.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
					csD.setAddBy(itemloader);
					csD.setAddDate(new Date());
					insertCatalogStructures.add(csD);
				}
				
				pstmt.close();
			}
			
			log.info("Insert catalogStructures START");
			if(Utility.isSet(insertCatalogStructures)){
				Iterator it2 = insertCatalogStructures.iterator();
				while(it2.hasNext()){
					CatalogStructureDataAccess.insert(conn, (CatalogStructureData)it2.next());
				}
			}
			log.info("Insert catalogStructures END");
			
			updateCategorySortOrder(conn, itemloader, storeNum, storeCatalogId, allCategories);
			
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateItemInCatalogs()=> "
                               + e.getMessage());
    	}
    }

    public void processItem(Connection conn, String itemloader, String itemActionAdd,String itemActionChange, String itemActionDelete, int storeNum, int tradingPartnerId) throws RemoteException{
    	log.info("Start Data Checking");

    	String versiionNumber = "";
    	String actionCd = "";
    	String assetCd = "";
    	String storeID = "";
    	String storeName = "";
    	String distSku = "";
    	String mfgSku = "";
    	String manufacturerName = "";
    	String distributorName = "";
    	String packCd = "";
    	String uomCd = "";
    	String categoryName = "";
    	String subcat1Cd = "";
    	String subcat2Cd = "";
    	String subcat3Cd = "";
    	String multiProductName = "";
    	String itemSize = "";
    	String longDesc = "";
    	String shortDesc = "";
    	String productUpc = "";
    	String packUpc = "";
    	String unspscCode = "";
    	String colorCd = "";
    	String shippingWeight = "";
    	String weightUnit = "";
    	String nsnCd = "";
    	String shippingCubicSize = "";
    	String hazmatCd = "";
    	String certifiedCompanies = "";
    	String imageCd = "";
    	String msdsCd = "";
    	String specificationCd = "";
    	String assetName = "";
    	String modelNumber = "";
    	String associateDoc1 = "";
    	String associateDoc2 = "";
    	String associateDoc3 = "";
    	String sortOrderMain = "";


    	String altCatalogType = "ALTERNATIVE_CATALOG_ID";
    	int alternateCatalogId = 0;

    	String selectNull = "select count(*) from CLT_POLLACK_ITEM_LOADER " +
		"where add_by = ? and( " +
		"VERSION_NUMBER is null or ACTION is null or STORE_ID is null or STORE_NAME is null or " +
		"DIST_SKU is null or MFG_SKU is null or MANUFACTURER is null or DISTRIBUTOR is null or " +
		"PACK is null or UOM is null or CATEGORY_NAME is null or LONG_DESCRIPTION is null or " +
		"SHORT_DESCRIPTION is null or HAZMAT is null)";

    	String selectManufCheck = "select distinct manufacturer from CLT_POLLACK_ITEM_LOADER t where add_by = ? " +
    			"and not exists " +
        "(select short_desc from clw_bus_entity cbe where bus_entity_type_cd = ? and " +
        "upper(cbe.short_desc) = upper(t.manufacturer) " +
        "and cbe.bus_entity_id in " +
        "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))";

    	String selectDistCheck = "select count(*) from CLT_POLLACK_ITEM_LOADER t where add_by = ? " +
		"and not exists " +
		"(select short_desc from clw_bus_entity cbe where bus_entity_type_cd = ? and " +
		"upper(cbe.short_desc) = upper(t.distributor) " +
		"and cbe.bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))";

    	String selectDistSkuSize = "select count(*) from CLT_POLLACK_ITEM_LOADER " +
    	" where add_by = ?  and length(dist_sku) > 30";

    	String selectDistManufSize = "select count(*) from CLT_POLLACK_ITEM_LOADER " +
    	" where add_by = ? and length(mfg_sku) > 30";

    	String selectManufSize = "select count(*) from CLT_POLLACK_ITEM_LOADER " +
    	" where add_by = ? and length(manufacturer) > 30";

    	String selectDistSku = " select VERSION_NUMBER,ACTION,ASSET,STORE_ID,STORE_NAME,DIST_SKU," +
    			"MFG_SKU,MANUFACTURER,DISTRIBUTOR,PACK,UOM,CATEGORY_NAME,SUBCAT1,SUBCAT2,SUBCAT3," +
    			"MULTI_PRODUCT_NAME,ITEM_SIZE,LONG_DESCRIPTION,SHORT_DESCRIPTION,PRODUCT_UPC,PACK_UPC," +
    			"UNSPSC_CODE,COLOR,SHIPPING_WEIGHT,WEIGHT_UNIT,NSN,SHIPPING_CUBIC_SIZE,HAZMAT," +
    			"CERTIFIED_COMPANIES,IMAGE,MSDS,SPECIFICATION,ASSET_NAME,MODEL_NUMBER," +
    			"ASSOCIATE_DOC1,ASSOCIATE_DOC2,ASSOCIATE_DOC3,SORT_ORDER_MAIN,SUBCAT1_ORDER," +
    			"SUBCAT2_ORDER,SUBCAT3_ORDER from CLT_POLLACK_ITEM_LOADER " +
    			"where add_by = ? and action in(?,?)";

    	String selectDistSkuInactivate = " select STORE_ID,DIST_SKU,DISTRIBUTOR from CLT_POLLACK_ITEM_LOADER " +
    			"where add_by = ? and action in(?)";



    	String selectAltCatalog = "select hard_value from clw_trading_property_map " +
    			"where trading_profile_id in(select trading_profile_id from clw_trading_profile " +
    			"where trading_partner_id = ?) and property_type_cd = ?";

    	try{
    	PreparedStatement pstmt = conn.prepareStatement(selectNull);
		pstmt.setString(1, itemloader);
		ResultSet rs = pstmt.executeQuery();
		int count = 0;
		while(rs.next()){
			count = rs.getInt(1);
		}
		pstmt.close();
		log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
		if (count > 0) {
			throw new IllegalArgumentException("CHECK 1111111111111111111111 Oneeeeee of the mandatory field is null");
		} else{
			log.info("CHECK 1111111111111111111111 Counttttt is zero continue = " + count);
		}

		///Create Manufacturer if does not exists
		pstmt = conn.prepareStatement(selectManufCheck);
		pstmt.setString(1, itemloader);
		pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
		pstmt.setInt(3, storeNum);
		rs = pstmt.executeQuery();
		count = 0;

		while(rs.next()){
			String ManuFName = rs.getString(1);
			if(ManuFName != null){
			BusEntityData busEntityData = BusEntityData.createValue();
			busEntityData.setBusEntityStatusCd(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
			busEntityData.setWorkflowRoleCd("UNKNOWN");
			busEntityData.setLocaleCd("en_US");
			busEntityData.setAddBy(itemloader);
			//busEntityData.setEffDate(runDate);
			busEntityData.setBusEntityTypeCd(RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
			busEntityData.setShortDesc(ManuFName);
			busEntityData = BusEntityDataAccess.insert(conn, busEntityData);
			int busEntityId = busEntityData.getBusEntityId();
			busEntityData.setErpNum("#" + busEntityId);
			BusEntityDataAccess.update(conn, busEntityData);

			BusEntityAssocData busEntityAssocD = BusEntityAssocData.createValue();
			busEntityAssocD.setBusEntity1Id(busEntityId);
			busEntityAssocD.setBusEntity2Id(storeNum);
			busEntityAssocD.setAddBy(itemloader);
			busEntityAssocD.setBusEntityAssocCd(RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE);
			busEntityAssocD = BusEntityAssocDataAccess.insert(conn, busEntityAssocD);

			}
		//	log.info("Check 2, check if All the manufacturer is Present  = " + selectManufCheck);
		}
		pstmt.close();

		/*if (count > 0) {
			throw new IllegalArgumentException("CHECK 2222222 Manufacturer does not exists");
		} else{
			log.info("CHECK 22222222222222222 Counttttt is zero continue = " + selectManufCheck);
		}*/


		pstmt = conn.prepareStatement(selectDistCheck);
		pstmt.setString(1, itemloader);
		pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
		pstmt.setInt(3, storeNum);
		rs = pstmt.executeQuery();
		count = 0;
		while(rs.next()){
			count = rs.getInt(1);

		}
		pstmt.close();
		log.info("Check 3, check if all the Distributor are present  = " + selectDistCheck);
		if (count > 0) {
			throw new IllegalArgumentException("Error CHECK 333333333333 Distributor does not exists");
		} else{
			log.info("CHECK 333333333333333 Counttttt is zero continue = " + selectDistCheck);
		}

		//Check the dist sku size
		pstmt = conn.prepareStatement(selectDistSkuSize);
		pstmt.setString(1, itemloader);
		rs = pstmt.executeQuery();
		count = 0;
		while(rs.next()){
			count = rs.getInt(1);
			}
		pstmt.close();

		if (count > 0) {
			throw new IllegalArgumentException("CHECK 4444444 ERROR Dist Sku is greater then 30 characters = " + selectDistSkuSize);
		} else{
			log.info("CHECK 444444 is success continue = ");
		}


		//Check manuf sku size
		pstmt = conn.prepareStatement(selectDistManufSize);
		pstmt.setString(1, itemloader);
		rs = pstmt.executeQuery();
		count = 0;
		while(rs.next()){
			count = rs.getInt(1);
			}
		pstmt.close();

		if (count > 0) {
			throw new IllegalArgumentException("CHECK 5555 ERROR manuf sku is greater then 30 characters = " + selectDistManufSize);
		} else{
			log.info("CHECK 55555 is success continue = ");
		}

		//Check manufacturer
		pstmt = conn.prepareStatement(selectManufSize);
		pstmt.setString(1, itemloader);
		rs = pstmt.executeQuery();
		count = 0;
		while(rs.next()){
			count = rs.getInt(1);
			}
		pstmt.close();

		if (count > 0) {
			throw new IllegalArgumentException("CHECK 66666 ERROR manufacturer name is greater then 30 characters = " + selectManufSize);
		} else{
			log.info("CHECK 66666 is success continue = ");
		}

		//Get Alternate catalog ID
		pstmt = conn.prepareStatement(selectAltCatalog);
		pstmt.setInt(1, tradingPartnerId);
		pstmt.setString(2, altCatalogType);
		rs = pstmt.executeQuery();

		while(rs.next()){
			alternateCatalogId = rs.getInt(1);
			}
		pstmt.close();
		if(alternateCatalogId == 0){
			throw new IllegalArgumentException("CHECK 777 Alternate catalog not found = " + selectAltCatalog);
		}

		pstmt = conn.prepareStatement(selectDistSku);
		pstmt.setString(1, itemloader);
		pstmt.setString(2, itemActionAdd);
		pstmt.setString(3, itemActionChange);
		rs = pstmt.executeQuery();
		//List ifItemExists = new ArrayList();
		int[] ifItemExists = new int[2];
		while(rs.next()){

			PollockItemView pollockItemView = PollockItemView.createValue();
			pollockItemView.setversiionNumber(rs.getString(1));
			pollockItemView.setactionCd(rs.getString(2));
			pollockItemView.setassetCd(rs.getString(3));
			pollockItemView.setstoreID(rs.getString(4));
			pollockItemView.setstoreName(rs.getString(5));
			pollockItemView.setdistSku(rs.getString(6));
			pollockItemView.setmfgSku(rs.getString(7));
			pollockItemView.setmanufacturerName(rs.getString(8));
			pollockItemView.setdistributorName(rs.getString(9));
			pollockItemView.setpackCd(rs.getString(10));
			pollockItemView.setuomCd(rs.getString(11));
			pollockItemView.setcategoryName(rs.getString(12));
			pollockItemView.setsubcat1Cd(rs.getString(13));
			pollockItemView.setsubcat2Cd(rs.getString(14));
			pollockItemView.setsubcat3Cd(rs.getString(15));
			pollockItemView.setmultiProductName(rs.getString(16));
			pollockItemView.setitemSize(rs.getString(17));
			pollockItemView.setlongDesc(rs.getString(18));
			pollockItemView.setshortDesc(rs.getString(19));
			pollockItemView.setproductUpc(rs.getString(20));
			pollockItemView.setpackUpc(rs.getString(21));
			pollockItemView.setunspscCode(rs.getString(22));
			pollockItemView.setcolorCd(rs.getString(23));
			pollockItemView.setshippingWeight(rs.getString(24));
			pollockItemView.setweightUnit(rs.getString(25));
			pollockItemView.setnsnCd(rs.getString(26));
			pollockItemView.setshippingCubicSize(rs.getString(27));
			pollockItemView.sethazmatCd(rs.getString(28));
			pollockItemView.setcertifiedCompanies(rs.getString(29));
			pollockItemView.setimageCd(rs.getString(30));
			pollockItemView.setmsdsCd(rs.getString(31));
			pollockItemView.setspecificationCd(rs.getString(32));
			pollockItemView.setassetName(rs.getString(33));
			pollockItemView.setmodelNumber(rs.getString(34));
			pollockItemView.setassociateDoc1(rs.getString(35));
			pollockItemView.setassociateDoc2(rs.getString(36));
			pollockItemView.setassociateDoc3(rs.getString(37));
			pollockItemView.setsortOrderMain(rs.getString(38));
			pollockItemView.setsubCat1Order(rs.getString(39));
			pollockItemView.setsubCat2Order(rs.getString(40));
			pollockItemView.setsubCat3Order(rs.getString(41));

			//pollockItemView.setversiionNumber(versiionNumber);
			//pollockItemView.setdistSku(distSku);
			//pollockItemView.setdistributorName(distributorName);

			//String distName = pollockItemView.getdistributorName();
			//String distSku = pollockItemView.getdistSku();
			log.info("WATCHHHHHHHHHHHHHHHHHH DIST NAMEEEEEEEEEEEEEEEEE ===== " + pollockItemView.getdistributorName());
			log.info("WATCHHHHHHHHHHHHHHHHHH DIST SKUUUUUUUUUUUUUUUUUU ===== " + pollockItemView.getdistSku());

			ifItemExists = itemCheck(conn,pollockItemView.getdistSku(),pollockItemView.getdistributorName(),pollockItemView.getuomCd(),storeNum);

			int itemID = ifItemExists[0];
			int distID = ifItemExists[1];
			log.info("froooooommmmmmmmm itemID = " + itemID + "distID = " + distID);
			if(distID == 0){
				log.info("DISTRIBUTOR DOes not Exists distname=" + pollockItemView.getdistributorName());
			}
			else{
			if(itemID == 0 ){
				log.info("1111111 Create Item");
				createItem(conn,storeNum,distID,pollockItemView,itemloader,alternateCatalogId);
			}else{
				log.info("1111111 Update Item");
				updateItem(conn,itemID,distID,pollockItemView,itemloader,storeNum);
				
				//search all catalogs that contain this item and update			
				updateItemInCatalogs(conn, storeNum,itemloader, itemID);				
			}

			}

			}
		pstmt.close();
		//Inactivate Items
			pstmt = conn.prepareStatement(selectDistSkuInactivate);
			pstmt.setString(1, itemloader);
			pstmt.setString(2, itemActionDelete);
			rs = pstmt.executeQuery();
			int[] ifItemExist = new int[2];
			while(rs.next()){

				PollockItemView pollockItemView = PollockItemView.createValue();
				pollockItemView.setstoreID(rs.getString(4));
				pollockItemView.setdistSku(rs.getString(6));
				pollockItemView.setdistributorName(rs.getString(9));

				ifItemExist = itemCheck(conn,pollockItemView.getdistSku(),pollockItemView.getdistributorName(),pollockItemView.getuomCd(),storeNum);
				int itemID = ifItemExists[0];
				int distID = ifItemExists[1];
				if(itemID == 0 ){
					throw new IllegalArgumentException("Item ID not Found for dist sku=" + pollockItemView.getdistSku() + "distname=" + pollockItemView.getdistributorName());
				}else{
					inactivateItem(conn,itemID,itemloader);
				}

			}
			pstmt.close();

    }catch(Exception e){
		e.printStackTrace();
		//throw e;
		   throw new RemoteException(
                   "Error.IntegrationServicesBean.processItem()=> "
                           + e.getMessage());
	}
    //pollockItemPostProcess(conn,itemloader,storeNum);
    }

    public void pollockItemPostProcess(Connection conn,String itemloader,int storeNum) throws RemoteException{
    	log.info("Start pollockItemPostProcess-----");
    	String InsertCatalog = "INSERT INTO CLT_NSC_CATEGORY_SORT_ORDER1 " +
    	" SELECT ca.bus_entity_id, " +
    	"(SELECT c1.catalog_id FROM clw_catalog c1, clw_catalog_assoc ca1 " +
    	"WHERE ca1.bus_entity_id = ca.bus_entity_id AND c1.catalog_id = ca1.catalog_id AND " +
    	"c1.catalog_type_cd = 'STORE') store_catalog_id," +
    	"cs.item_id,0,cs.catalog_id,cs.catalog_structure_id,cs.sort_order " +
    	"FROM clw_catalog_assoc ca, clw_catalog_structure cs " +
    	"WHERE 1=1 " +
    	"AND ca.bus_entity_id = ? " +
    	"AND cs.catalog_id = ca.catalog_id";

    	String updateCatalog = "UPDATE CLT_NSC_CATEGORY_SORT_ORDER1 t " +
    	"SET sort_order = (SELECT cs.sort_order FROM clw_catalog_structure cs " +
    	"WHERE cs.catalog_id = t.store_catalog_id " +
    	"AND cs.item_id = t.category_id)";

    	String mergeCatalog = "MERGE INTO   clw_catalog_structure cs " +
    	"USING   CLT_NSC_CATEGORY_SORT_ORDER1 t " +
        "ON   (t.catalog_structure_id = cs.catalog_structure_id) " +
        "WHEN MATCHED " +
        "THEN " +
        "UPDATE SET  cs.sort_order = t.sort_order, cs.mod_by = ?, cs.mod_date = sysdate ";


    	try{
    		PreparedStatement pstmt = conn.prepareStatement(InsertCatalog);
    		pstmt.setInt(1, storeNum);
    		pstmt.executeUpdate();
			pstmt.close();

			pstmt = conn.prepareStatement(updateCatalog);
    		pstmt.executeUpdate();
			pstmt.close();

			pstmt = conn.prepareStatement(mergeCatalog);
    		pstmt.setString(1, itemloader);
    		pstmt.executeUpdate();
			pstmt.close();


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.pollockItemPostProcess()=> "
                               + e.getMessage());
    	}

    }

    public int[] itemCheck(Connection conn, String distSku, String distName,String uomCd, int storeNum) throws RemoteException{
    	log.info("Check if Item Exists: dist_sku =" + distSku + "Dist Name =" + distName);

    	int itemId = 0;
		int distId = 0;
		//List<int> list = new ArrayList<int>();
		int[] list = new int[2];
    	String itemDistCheck = "select cim.item_id,cbe.bus_entity_id " +
    			"from clw_item_mapping cim,clw_bus_entity cbe,clw_bus_entity_assoc cbea " +
		    	"where cbe.bus_entity_id = cbea.bus_entity1_id " +
		    	"and cbe.bus_entity_id = cim.bus_entity_id(+) " +
		    	"and cbea.bus_entity2_id = ? " +
				"and upper(cbe.short_desc) = ? " +
				"and cim.item_mapping_cd(+) = ? " +
				"and cim.item_num(+) = ?" +
				"and cim.item_uom(+) = ? " +
				"and cbe.bus_entity_type_cd = ?" +
				"order by cim.item_id ";

    	try{
    		distName = distName.toUpperCase();
        	PreparedStatement pstmt = conn.prepareStatement(itemDistCheck);
        	pstmt.setInt(1, storeNum);
        	pstmt.setString(2, distName);
        	pstmt.setString(3, RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
        	pstmt.setString(4, distSku);
        	pstmt.setString(5, uomCd);
        	pstmt.setString(6, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
    		ResultSet rs = pstmt.executeQuery();
    		while(rs.next()){
    			itemId = rs.getInt(1);
    			distId = rs.getInt(2);
    			log.info("distSku = " + distSku + "distName = " + distName + "item_id =" + itemId + "dist_id =" + distId + "uom=" + uomCd);
    			list[0] = itemId;
        		list[1] = distId;

    		}
    	//	if(itemId == 0){
    	//		return false;
    	//	}else{
    //			return true;
    //		}
    		pstmt.close();
    		return list;

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}




    }

    public void createItem(Connection conn,int storeNum, int distID, PollockItemView pollockItemView, String itemloader,int alternateCatalogId) throws RemoteException{
    	log.info("CREATTTTTTTTTTTTTTTTTTEEEEEEEEEEEEEEEEEEEEE ITEMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM");


    	String insertItemMapping = "insert into clw_item_mapping(item_mapping_id,item_id,bus_entity_id," +
    			"item_num,item_uom,item_pack,item_mapping_cd,eff_date,add_date,add_by,mod_Date,mod_by) " +
    			"values(clw_item_mapping_seq.nextval,?,?,?,?,?,?,sysdate,sysdate,?,sysdate,?)";

    	String insertItemMeta = "insert into clw_item_meta(item_meta_id,item_id,value_id,name_value,clw_value," +
    			"add_Date,add_by,mod_date,mod_by) " +
    			"values(clw_item_meta_seq.nextval,?,0,?,?,sysdate,?,sysdate,?)";


    	String insertCretifiedCompanies = "insert into clw_item_mapping(item_mapping_id,item_id,bus_entity_id," +
    			"item_mapping_cd,status_cd,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_item_mapping_seq.nextval,?,?,?,?,sysdate,?,sysdate,?)";

    	String insertAltCatalogStru = "insert into clw_catalog_structure(catalog_structure_id," +
    			"catalog_id,catalog_structure_cd,item_id,customer_sku_num,eff_date," +
    			"status_cd,add_date,add_by,mod_date,mod_by) " +
    			"values(clw_catalog_structure_seq.nextval,?,?,?,?,sysdate,?,sysdate,?,sysdate,?)";

    	String selectAltContract = "select contract_id from clw_contract where catalog_id = ?";

    	String insertAltContractItem = "insert into clw_contract_item(contract_item_id,contract_id," +
    			"item_id,amount,dist_cost,eff_date,add_date,add_by,mod_date,mod_by,dist_base_cost)	" +
    			"values(clw_contract_item_seq.nextval,?,?,?,?,sysdate,sysdate,?,sysdate,?,?)";


    	String versiionNumber 		= 	pollockItemView.getversiionNumber();
    	String actionCd 			= 	pollockItemView.getactionCd();
    	String assetCd 				= 	pollockItemView.getassetCd();
    	String storeID 				= 	pollockItemView.getstoreID();
    	String storeName 			= 	pollockItemView.getstoreName();
    	String distSku 				= 	pollockItemView.getdistSku();
    	String mfgSku 				= 	pollockItemView.getmfgSku();
    	String manufacturerName 	= 	pollockItemView.getmanufacturerName();
    	String distributorName 		= 	pollockItemView.getdistributorName();
    	String packCd 				= 	pollockItemView.getpackCd();
    	String uomCd 				= 	pollockItemView.getuomCd();
    	String categoryName 		= 	pollockItemView.getcategoryName();
    	String subcat1Cd 			= 	pollockItemView.getsubcat1Cd();
    	String subcat2Cd 			= 	pollockItemView.getsubcat2Cd();
    	String subcat3Cd 			= 	pollockItemView.getsubcat3Cd();
    	String multiProductName 	= 	pollockItemView.getmultiProductName();
    	String itemSize 			= 	pollockItemView.getitemSize();
    	String longDesc 			= 	pollockItemView.getlongDesc();
    	String shortDesc 			= 	pollockItemView.getshortDesc();
    	String productUpc 			= 	pollockItemView.getproductUpc();
    	String packUpc 				= 	pollockItemView.getpackUpc();
    	String unspscCode 			= 	pollockItemView.getunspscCode();
    	String colorCd 				= 	pollockItemView.getcolorCd();
    	String shippingWeight 		= 	pollockItemView.getshippingWeight();
    	String weightUnit 			= 	pollockItemView.getweightUnit();
    	String nsnCd 				= 	pollockItemView.getnsnCd();
    	String shippingCubicSize 	= 	pollockItemView.getshippingCubicSize();
    	String hazmatCd 			= 	pollockItemView.gethazmatCd();
    	String certifiedCompanies 	= 	pollockItemView.getcertifiedCompanies();
    	String imageCd 				= 	pollockItemView.getimageCd();
    	String msdsCd 				= 	pollockItemView.getmsdsCd();
    	String specificationCd 		= 	pollockItemView.getspecificationCd();
    	String assetName 			= 	pollockItemView.getassetName();
    	String modelNumber 			= 	pollockItemView.getmodelNumber();
    	String associateDoc1 		= 	pollockItemView.getassociateDoc1();
    	String associateDoc2 		= 	pollockItemView.getassociateDoc2();
    	String associateDoc3 		= 	pollockItemView.getassociateDoc3();
    	String mcatO 				=   pollockItemView.getsortOrderMain();
		String sub1O 				=   pollockItemView.getsubCat1Order();
		String sub2O 				= 	pollockItemView.getsubCat2Order();
		String sub3O 				=	pollockItemView.getsubCat3Order();

    	int sortOrderMain = 0;
    	int subCat1Order = 0;
		int subCat2Order = 0;
		int subCat3Order = 0;

    	if(mcatO != null){
    	sortOrderMain = Integer.parseInt(mcatO);
    	}


    	if(sub1O != null){
    		subCat1Order = Integer.parseInt(sub1O);
    	}

    	if(sub2O != null){
    		subCat2Order = Integer.parseInt(sub2O);
    	}

    	if(sub3O != null){
    		subCat3Order = Integer.parseInt(sub3O);
    	}



    	Date runDate = new Date();
    	int itemID = 0;
    	int manufId = 0;
    	int mainCategoryId = 0;
    	int subCat1Id = 0;
    	int subCat2Id = 0;
    	int subCat3Id = 0;

    	int storeCatalogId = getStoreCatalog(conn,storeNum);

    	try{
    		ItemData itemData = ItemData.createValue();
	    	itemData.setShortDesc(shortDesc);
	    	itemData.setLongDesc(longDesc);
	    	itemData.setItemTypeCd(RefCodeNames.ITEM_TYPE_CD.PRODUCT);
	    	itemData.setItemStatusCd(RefCodeNames.ITEM_STATUS_CD.ACTIVE);
	    	itemData.setEffDate(runDate);
	    	itemData.setAddBy(itemloader);
	    	itemData.setModBy(itemloader);
	    	itemData = ItemDataAccess.insert(conn, itemData);
	    	itemID = itemData.getItemId();

	    	itemData.setSkuNum(itemID + CatalogBean.SKU_MINIMUM);
			itemData.setModBy(itemloader);
			ItemDataAccess.update(conn, itemData);

			manufId = getManufId(conn,RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER,manufacturerName,storeNum);
			log.info("MANUFACTURRRRRRRRRRREEEEEEEEEEERRRRRR IIIIIDDDDDD = " + manufId);

			PreparedStatement pstmt = conn.prepareStatement(insertItemMapping);
			pstmt.setInt(1,itemID);
			pstmt.setInt(2,distID);
			pstmt.setString(3,distSku);
			pstmt.setString(4,uomCd);
			pstmt.setString(5,packCd);
			pstmt.setString(6,RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
			pstmt.setString(7,itemloader);
			pstmt.setString(8,itemloader);
			pstmt.addBatch();

			pstmt.setInt(2,manufId);
			pstmt.setString(3,mfgSku );
			pstmt.setString(6,RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();
			//Add Item Meta

			pstmt = conn.prepareStatement(insertItemMeta);
			pstmt.setInt(1,itemID);

			//Add Pack Info
			pstmt.setString(2,"PACK");
			pstmt.setString(3,packCd);
			pstmt.setString(4,itemloader);
			pstmt.setString(5,itemloader);
			pstmt.addBatch();

			//Add UOM Info
			pstmt.setString(2,"UOM");
			pstmt.setString(3,uomCd);
			pstmt.addBatch();

			//Add ITEM_SIZE Info
			if(itemSize != null){
			pstmt.setString(2,"SIZE");
			pstmt.setString(3,itemSize);
			pstmt.addBatch();
			}

			//Add PRODUCT_UPC Info
			if(productUpc != null){
			pstmt.setString(2,"UPC_NUM");
			pstmt.setString(3,productUpc);
			pstmt.addBatch();
			}

			//Add PACK_UPC Info
			if(packUpc != null){
			pstmt.setString(2,"PKG_UPC_NUM");
			pstmt.setString(3,packUpc);
			pstmt.addBatch();
			}

			//Add UNSPSC Code Info
			if(unspscCode != null){
			pstmt.setString(2,"UNSPSC_CD");
			pstmt.setString(3,unspscCode);
			pstmt.addBatch();
			}

			//Add COLOR Info
			if(colorCd != null){
			pstmt.setString(2,"COLOR");
			pstmt.setString(3,colorCd);
			pstmt.addBatch();
			}

			//Add Shipping Weight Info
			if(shippingWeight != null){
			pstmt.setString(2,"SHIP_WEIGHT");
			pstmt.setString(3,shippingWeight);
			pstmt.addBatch();
			}

			//Add Weight Unit Info
			if(weightUnit != null){
			pstmt.setString(2,"WEIGHT_UNIT");
			pstmt.setString(3,weightUnit);
			pstmt.addBatch();
			}

			//Add NSN Info
			if(nsnCd != null){
			pstmt.setString(2,"NSN");
			pstmt.setString(3,nsnCd);
			pstmt.addBatch();
			}

			//Add CUBE_SIZE Info
			if(shippingCubicSize != null){
			pstmt.setString(2,"CUBE_SIZE");
			pstmt.setString(3,shippingCubicSize);
			pstmt.addBatch();
			}

			//Add HAZMAT Info
			if(hazmatCd != null){
			hazmatCd = hazmatCd.toLowerCase();
			pstmt.setString(2,"HAZMAT");
			pstmt.setString(3,hazmatCd);
			pstmt.addBatch();
			}

			pstmt.executeBatch();
			pstmt.close();
			//Add Item to Store Catalog
			String SkuNum = Integer.toString(itemID + CatalogBean.SKU_MINIMUM);

			CatalogStructureData catalogStructureData = CatalogStructureData.createValue();

			catalogStructureData.setCatalogId(storeCatalogId);
			catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
			catalogStructureData.setItemId(itemID);
			catalogStructureData.setCustomerSkuNum(SkuNum);
			catalogStructureData.setEffDate(runDate);
			catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
			catalogStructureData.setAddBy(itemloader);
			CatalogStructureDataAccess.insert(conn, catalogStructureData);

			if(alternateCatalogId > 0){
				pstmt = conn.prepareStatement(insertAltCatalogStru);
				pstmt.setInt(1, alternateCatalogId);
				pstmt.setString(2, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
				pstmt.setInt(3, itemID);
				pstmt.setString(4,SkuNum);
				pstmt.setString(5,RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
				pstmt.setString(6,itemloader);
				pstmt.setString(7,itemloader);
				pstmt.executeUpdate();
				pstmt.close();

				pstmt = conn.prepareStatement(selectAltContract);
				pstmt.setInt(1, alternateCatalogId);
	    		ResultSet rs = pstmt.executeQuery();
	    		int altContractId = 0;
	    		int altContAmt = 0;
	    		while(rs.next()){
	    			altContractId = rs.getInt(1);
	    		}
	    		pstmt.close();

	    		if(altContractId > 0){
	    			pstmt = conn.prepareStatement(insertAltContractItem);
	    			pstmt.setInt(1,altContractId);
	    			pstmt.setInt(2,itemID);
	    			pstmt.setInt(3,altContAmt);
	    			pstmt.setInt(4,altContAmt);
	    			pstmt.setString(5,itemloader);
	    			pstmt.setString(6,itemloader);
	    			pstmt.setInt(7,altContAmt);
	    			pstmt.executeUpdate();
					pstmt.close();

	    		}

			}
		/*
			if(subcat3Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,itemloader);
			}

			if(subcat2Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader);
			}

			if(subcat1Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader);
			}

			if(categoryName != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader);
			}		*/


//			checkCreateCategoryAssoc(conn,itemID,pollockItemView,itemloader,storeCatalogId,storeNum);

			//Associate items to Certified Companies
			log.info("Associate Items to Certified Companies:");
			if(certifiedCompanies != null){
				pstmt = conn.prepareStatement(insertCretifiedCompanies);
				pstmt.setInt(1,itemID);
				int certifiedCompId = 0;
				String sp[] = certifiedCompanies.split(",");
			for(String s:sp) {
				s = s.trim();
				log.info("Certified Companies List:" + s);
				certifiedCompId = getCertifiedCompId(conn,s);
				if (certifiedCompId == 0) {
	    			throw new IllegalArgumentException("certifiedCompId not Found company" + s);
	    		}
			   	pstmt.setInt(2, certifiedCompId);
				pstmt.setString(3, RefCodeNames.ITEM_MAPPING_CD.ITEM_CERTIFIED_COMPANY);
				pstmt.setString(4, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
				pstmt.setString(5,itemloader);
				pstmt.setString(6,itemloader);
				pstmt.addBatch();

			}
				pstmt.executeBatch();
				pstmt.close();
			}
			int itemAssocID = 0;
		//	int sortOrder = 0;
			if(subcat3Cd == null){
				if(subcat2Cd == null){
					if(subcat1Cd == null){
						//associate Main Category
					//	catId = checkIfCategoryExists(conn,storeCatalogId,categoryName);
						//checkCreateCategoryAssoc(conn,itemID,pollockItemView,itemloader,storeCatalogId,storeNum);
						mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
						itemAssocID = checkItemCatAssoc(conn,itemID,mainCategoryId,storeCatalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}else{
							associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Main Category mainCategoryId = " + mainCategoryId);
					}else{
						//associate sub cat 1
				//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat1Cd);
						subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
						itemAssocID = checkItemCatAssoc(conn,itemID,subCat1Id,storeCatalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}else{
							associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}
						//Check Main Category and subcat1 Association
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
						mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
						//change(03/02/2010)
						itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);

						if(itemAssocID == 0){
							associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
						}


					}
				}else{
					//associate sub cat 2
			//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat2Cd);
					subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader,subCat2Order);
					itemAssocID = checkItemCatAssoc(conn,itemID,subCat2Id,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}else{
						associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}


					//Check subcat1 and subcat2 Association
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat2 = " + subcat2Cd + "sucat1 = " + subcat1Cd);
					subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
					itemAssocID = checkCatSucatAssoc(conn,subCat2Id,subCat1Id,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
					}


					//Check Main Category and subcat1 Association
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
					mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
					itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
					}

				}
			}else{
				//associate sub cat 3
		//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat3Cd);

				subCat3Id = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,itemloader,subCat3Order);
				itemAssocID = checkItemCatAssoc(conn,itemID,subCat3Id,storeCatalogId);
				if(itemAssocID == 0){
					associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
				}else{
					associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
				}
				log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat3 = " + subcat3Cd + "sucat2 = " + subcat2Cd);
				//check subcat2 and subcat3 Association
				subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader,subCat2Order);
				itemAssocID = checkCatSucatAssoc(conn,subCat3Id,subCat2Id,storeCatalogId);
				if(itemAssocID == 0){
					associateItem(conn,subCat3Id,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
				}

				//Check subcat1 and subcat2 Association
				log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat2 = " + subcat2Cd + "sucat1 = " + subcat1Cd);
				subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
				itemAssocID = checkCatSucatAssoc(conn,subCat2Id,subCat1Id,storeCatalogId);
				if(itemAssocID == 0){
					associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
				}


				//Check Main Category and subcat1 Association
				log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
				mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
				itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);
				if(itemAssocID == 0){
					associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
				}
				log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 333333333333 subCat3Id = " + subCat3Id);
			}

			pstmt.close();
			log.info("item_id = " + itemData.getItemId() + "SKU Num = " + itemData.getSkuNum());
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createItem()=> "
                               + e.getMessage());
    	}


    }

    public int getCertifiedCompId(Connection conn,String certifiedCompany) throws RemoteException{
    		log.info("Get Certified Company");
    		int certifiedCompanyId = 0;

    		String selectCertifiedCompany = "select bus_entity_id from clw_bus_entity " +
    				"where bus_entity_type_cd = ? and upper(short_desc) = ?";


    		try{
    			certifiedCompany = certifiedCompany.toUpperCase();
    			PreparedStatement pstmt = conn.prepareStatement(selectCertifiedCompany);
    			pstmt.setString(1,RefCodeNames.BUS_ENTITY_TYPE_CD.CERTIFIED_COMPANY);
    			pstmt.setString(2,certifiedCompany);
    			ResultSet rs = pstmt.executeQuery();
    			while(rs.next()){
    				certifiedCompanyId = rs.getInt(1);
        		}
    			pstmt.close();
    			return certifiedCompanyId;

    		}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.getCertifiedCompId()=> "
                                   + e.getMessage());
        	}

    }

    public int getManufId(Connection conn,String busEntityTypeCd,String shortDesc, int storeNum) throws RemoteException{
    	String selectManufId = "select bus_entity_id from clw_bus_entity where upper(short_desc) = ? " +
    	"and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
    	"and bus_entity_type_cd = ? and bus_entity_status_cd = ?";
    	int manufId = 0;

    	try{
    		shortDesc = shortDesc.toUpperCase();
    		PreparedStatement pstmt = conn.prepareStatement(selectManufId);
    		pstmt.setString(1, shortDesc);
    		pstmt.setInt(2, storeNum);
    		pstmt.setString(3, busEntityTypeCd);
    		pstmt.setString(4, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE );
    		ResultSet rs = pstmt.executeQuery();
    		while(rs.next()){
    			manufId = rs.getInt(1);
    		}
    		log.info("Manuffacturer Name = " + shortDesc);
    		if (manufId == 0) {
    			throw new IllegalArgumentException("Manufacturer ID not Found" + selectManufId);
    		}
    		//else{


    		//}
    		pstmt.close();
    		return manufId;

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getManufId()=> "
                               + e.getMessage());
    	}

    }

    public int getStoreCatalog(Connection conn,int storeNum) throws RemoteException{
    	String selectStoreCatalog = "select catalog_id from clw_catalog where catalog_type_cd = ? " +
    	"and catalog_id in(select catalog_id from clw_catalog_assoc where bus_entity_id = ?)" +
    	"and catalog_status_cd = ?";

    	int catalogId = 0;

    	try{
    		PreparedStatement pstmt = conn.prepareStatement(selectStoreCatalog);
    		pstmt.setString(1,RefCodeNames.BUS_ENTITY_TYPE_CD.STORE);
    		pstmt.setInt(2,storeNum);
    		pstmt.setString(3,RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
    		ResultSet rs = pstmt.executeQuery();
    		while(rs.next()){
    			catalogId = rs.getInt(1);
    			if (rs.next())
            		throw new Exception("Error Found Two Active Store Catalog for store_id =" + storeNum);
    		}
    		if(catalogId == 0){
    			throw new Exception("Error No Active Store Catalog for store_id =" + storeNum);
    		}
    		pstmt.close();
    		return catalogId;

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getStoreCatalog()=> "
                               + e.getMessage());
    	}

    }
    public HashMap checkAndCreateCategoryN(Connection conn,int storeCatalogId,String catName,String itemloader,int sortOrder,HashMap categoryHashMap) throws RemoteException{
      return checkAndCreateCategoryN( conn, storeCatalogId, catName, itemloader, sortOrder, categoryHashMap, 0);
    }
    private HashMap checkAndCreateCategoryN(Connection conn,int storeCatalogId,String catName,String itemloader,int sortOrder,HashMap categoryHashMap, int costCenterId) throws RemoteException{
    	log.info("CHECK AND CREATE CATEGORY new start catId===" + storeCatalogId);
    	String selectCategory = "select item_id from clw_item where upper(short_desc||long_desc) = upper(?) " +
    			"and item_type_cd = ?  and item_id in(select item_id  " +
    			"from clw_catalog_structure where catalog_id = ? and catalog_structure_cd = ?)";
    	int categoryId = 0;
    	Date runDate = new Date();
 //   	log.info("CHECK AND CREATE CATEGORY storeCatalogId =" + storeCatalogId + "catName =" + catName);

    	String updateCategoryOrder = "UPDATE CLW_CATALOG_STRUCTURE set sort_order = ?,mod_date=sysdate," +
    			"mod_by = ?, cost_center_id = ? where item_id = ? and catalog_id = ? and catalog_structure_cd = ?";

    	//HashMap hashMap  = new HashMap();

    	try{
    		if(  categoryHashMap.containsKey(catName.toUpperCase())  ){
    			categoryId  = (Integer)  categoryHashMap.get(catName.toUpperCase());
    			log.info("HashMap contains Category:" + catName + "and CatId = " + categoryId);

    		}else{

                      PreparedStatement pstmt = conn.prepareStatement(selectCategory);
                      pstmt.setString(1, catName);
                      pstmt.setString(2, RefCodeNames.ITEM_TYPE_CD.CATEGORY);
                      //pstmt.setString(3, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
                      pstmt.setInt(3, storeCatalogId);
                      pstmt.setString(4, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
                      ResultSet rs = pstmt.executeQuery();
                      while (rs.next()) {
    			categoryId = rs.getInt(1);
    			if (rs.next())
            		throw new Exception("Error Found Two Active Category Associated for catalog_id =" + storeCatalogId + "catName = " + catName);

                      }
    		pstmt.close();

    		categoryHashMap.put(catName.toUpperCase(),categoryId);
                log.info("HashMap does not contain Category :"+catName +". add to Hashmap");
    		}

    		if(categoryId > 0){
    		//	log.info("CHECK AND CREATE CATEGORY FOUND CATEGORYYYYYYY UPDATE SORT ORDER sort_order =" + sortOrder + "catalog_id = " + storeCatalogId + " category_id = " + categoryId);
    			PreparedStatement pstmt = conn.prepareStatement(updateCategoryOrder);
    			pstmt.setInt(1,sortOrder);
    			pstmt.setString(2,itemloader);
                        pstmt.setInt(3, costCenterId);
    			pstmt.setInt(4,categoryId);
    			pstmt.setInt(5,storeCatalogId);
    			pstmt.setString(6, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			pstmt.executeUpdate();
    			pstmt.close();
    		}

    		if(categoryId == 0){
    			//Create Category
    		//	log.info("CHECK AND CREATE CATEGORY NOT FOUND");
    			ItemData itemData = ItemData.createValue();
    	    	itemData.setShortDesc(catName);
    	    	itemData.setItemTypeCd(RefCodeNames.ITEM_TYPE_CD.CATEGORY);
    	    	itemData.setItemStatusCd(RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    	    	itemData.setEffDate(runDate);
    	    	itemData.setAddBy(itemloader);
    	    	itemData.setModBy(itemloader);
    	    	itemData = ItemDataAccess.insert(conn, itemData);
    	    	categoryId = itemData.getItemId();



    	    	CatalogStructureData catalogStructureData = CatalogStructureData.createValue();

    			catalogStructureData.setCatalogId(storeCatalogId);
    			catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			catalogStructureData.setItemId(categoryId);
    			catalogStructureData.setEffDate(runDate);
    			catalogStructureData.setSortOrder(sortOrder);
    			catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
    			catalogStructureData.setAddBy(itemloader);
                        catalogStructureData.setCostCenterId(costCenterId);

    			CatalogStructureDataAccess.insert(conn, catalogStructureData);

    			log.info("CHECK AND CREATE CATEGORY Return categoryID = " + categoryId);
    			categoryHashMap.put(catName.toUpperCase(),categoryId);
    		}

    		return categoryHashMap;


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndCreateCategoryN()=> "
                               + e.getMessage());
    	}

    }

    public int checkAndCreateCategory(Connection conn,int storeCatalogId,String catName,String itemloader,int sortOrder) throws RemoteException{
    	log.info("CHECK AND CREATE CATEGORY OLD start catalogId=" + storeCatalogId);
    	String selectCategory = "select item_id from clw_item where upper(short_desc||long_desc) = upper(?) " +
    			"and item_type_cd = ? and item_status_cd = ? and item_id in(select item_id  " +
    			"from clw_catalog_structure where catalog_id = ? and catalog_structure_cd = ?)";
    	int categoryId = 0;
    	Date runDate = new Date();
    	log.info("CHECK AND CREATE CATEGORY storeCatalogId =" + storeCatalogId + "catName =" + catName);

    	String updateCategoryOrder = "UPDATE CLW_CATALOG_STRUCTURE set sort_order = ?,mod_date=sysdate," +
    			"mod_by = ? where item_id = ? and catalog_id = ? and catalog_structure_cd = ?";

    	try{

    		PreparedStatement pstmt = conn.prepareStatement(selectCategory);
    		pstmt.setString(1, catName);
    		pstmt.setString(2, RefCodeNames.ITEM_TYPE_CD.CATEGORY);
    		pstmt.setString(3, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    		pstmt.setInt(4, storeCatalogId);
    		pstmt.setString(5, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    		ResultSet rs = pstmt.executeQuery();
    		while(rs.next()){
    			categoryId = rs.getInt(1);
    			if (rs.next())
            		throw new Exception("Error Found Two Active Category Associated for catalog_id =" + storeCatalogId + "catName = " + catName);

    		}
    		pstmt.close();


    		if(categoryId > 0){
    	//		log.info("CHECK AND CREATE CATEGORY FOUND CATEGORYYYYYYY UPDATE SORT ORDER sort_order =" + sortOrder + "catalog_id = " + storeCatalogId + " category_id = " + categoryId);
    			pstmt = conn.prepareStatement(updateCategoryOrder);
    			pstmt.setInt(1,sortOrder);
    			pstmt.setString(2,itemloader);
    			pstmt.setInt(3,categoryId);
    			pstmt.setInt(4,storeCatalogId);
    			pstmt.setString(5, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			pstmt.executeUpdate();
    			pstmt.close();
    		}

    		if(categoryId == 0){
    			//Create Category
    	//		log.info("CHECK AND CREATE CATEGORY NOT FOUND");
    			ItemData itemData = ItemData.createValue();
    	    	itemData.setShortDesc(catName);
    	    	itemData.setItemTypeCd(RefCodeNames.ITEM_TYPE_CD.CATEGORY);
    	    	itemData.setItemStatusCd(RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    	    	itemData.setEffDate(runDate);
    	    	itemData.setAddBy(itemloader);
    	    	itemData.setModBy(itemloader);
    	    	itemData = ItemDataAccess.insert(conn, itemData);
    	    	categoryId = itemData.getItemId();


    	    	CatalogStructureData catalogStructureData = CatalogStructureData.createValue();

    			catalogStructureData.setCatalogId(storeCatalogId);
    			catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			catalogStructureData.setItemId(categoryId);
    			catalogStructureData.setEffDate(runDate);
    			catalogStructureData.setSortOrder(sortOrder);
    			catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
    			catalogStructureData.setAddBy(itemloader);

    			CatalogStructureDataAccess.insert(conn, catalogStructureData);

    			log.info("CHECK AND CREATE CATEGORY Return categoryID = " + categoryId);
    		}

    		return categoryId;


    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndCreateCategory()=> "
                               + e.getMessage());
    	}

    }

    public int checkItemCatAssoc(Connection conn,int item1ID,int item2ID,int catalogId) throws RemoteException{
    //	String selectCatAssoc = "select count(*) from clw_item_assoc where item1_id = ? and item2_id = ? " +
    //			"and catalog_id = ?";
        	String selectCatAssoc = "select count(*) from clw_item_assoc where item1_id = ?  " +
    			"and catalog_id = ?";
    	int count = 0;
    	log.info("checkItemCatAssoc Start");

    	try{
    		PreparedStatement pstmt = conn.prepareStatement(selectCatAssoc);
			pstmt.setInt(1, item1ID);
		//	pstmt.setInt(2, item2ID);
			pstmt.setInt(2, catalogId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
    			count = rs.getInt(1);

    			//if (rs.next())
            	//	throw new Exception("Error Found Two Active Store Catalog for store_id =" + storeNum);
    		}

			pstmt.close();
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkItemCatAssoc()=> "
                               + e.getMessage());
    	}

    	log.info("checkItemCatAssoc End return value=" + count);
    	return count;

    }


    public int checkCatSucatAssoc(Connection conn,int item1ID,int item2ID,int catalogId) throws RemoteException{
    //	String selectCatAssoc = "select count(*) from clw_item_assoc where item1_id = ? and item2_id = ? " +
    //			"and catalog_id = ? and item_assoc_cd = ?";

    	String selectCatAssoc = "select count(*) from clw_item_assoc where item1_id = ?  " +
    			"and catalog_id = ? and item_assoc_cd = ?";

  //  	String selectCatSubcatAssoc = "select count(*) from clw_item_assoc where item1_id = ? " +
  //  		"and catalog_id = ? and item_assoc_cd = ?";

    //	String selectShortDesc = "select short_Desc from clw_item where item_id = ?";

    	int count = 0;
    	log.info("checkCatSubcatAssoc Start");

    	try{
    	/*	PreparedStatement pstmt = conn.prepareStatement(selectShortDesc);
    		pstmt.setInt(1, item1ID);
    		ResultSet rs = pstmt.executeQuery();
    		String shortDesc = "";
    		while(rs.next()){
    			shortDesc = rs.getString(1);
    		}
    		log.info("Item1 short desc ======================" + shortDesc);
    		pstmt.close();

    		pstmt = conn.prepareStatement(selectShortDesc);
    		pstmt.setInt(1, item2ID);
    		rs = pstmt.executeQuery();
    		//shortDesc = "";
    		while(rs.next()){
    			shortDesc = rs.getString(1);
    		}
    		log.info("Item2 short desc ======================" + shortDesc);
    		pstmt.close();*/


    		PreparedStatement pstmt = conn.prepareStatement(selectCatAssoc);
			pstmt.setInt(1, item1ID);
		//	pstmt.setInt(2, item2ID);
			pstmt.setInt(2, catalogId);
			pstmt.setString(3, RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
    			count = rs.getInt(1);

    			//if (rs.next())
            	//	throw new Exception("Error Found Two Active Store Catalog for store_id =" + storeNum);
    		}

			pstmt.close();
		/*	if(count == 0){
				pstmt = conn.prepareStatement(selectCatSubcatAssoc);
				pstmt.setInt(1, item1ID);
				pstmt.setInt(2, catalogId);
				pstmt.setString(3, RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY);
				rs = pstmt.executeQuery();
				while(rs.next()){
	    			count = rs.getInt(1);

	    			//if (rs.next())
	            	//	throw new Exception("Error Found Two Active Store Catalog for store_id =" + storeNum);
	    		}
				if(count > 0){
					throw new Exception("Error subcat id = " + item1ID + " is already associated to category id = " + item2ID + " and catalog_id = " + catalogId);
				}

				pstmt.close();

			}*/
			if(count > 1){
					throw new Exception("Error subcat id = " + item1ID + " is already associated to category id = " + item2ID + " and catalog_id = " + catalogId);
				}

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkCatSucatAssoc()=> "
                               + e.getMessage());
    	}

    	log.info("checkCatSucatAssoc End return value=" + count);
    	return count;

    }


    public void associateItem(Connection conn,int item1ID,int item2ID,int insertOrUpdate,String productOrCat,int storeCatalogId,String itemloader) throws RemoteException{
    	//Associate items to Category or Update Association
    	//if insertOrUpdate = 0 then insert if it is 1 then update the association used only for
    	//item and category not for category to category association

    		String insertItemAssoc = "insert into clw_item_assoc(item_assoc_id,item1_id,item2_id,catalog_id," +
			"item_assoc_cd,add_date,add_by,mod_date,mod_by) " +
			"values(clw_item_assoc_seq.nextval,?,?,?,?,sysdate,?,sysdate,?)";

    		String updateItemAssoc = "update clw_item_assoc set item2_id = ?,mod_by=?,mod_date=sysdate where item1_id = ? and catalog_id = ? ";

    		try{

    			if(insertOrUpdate == 0){
    				PreparedStatement pstmt = conn.prepareStatement(insertItemAssoc);
    				pstmt.setInt(1, item1ID);
    				pstmt.setInt(2, item2ID);
    				pstmt.setInt(3, storeCatalogId);
    				pstmt.setString(4,productOrCat);
    				pstmt.setString(5,itemloader);
	    			pstmt.setString(6,itemloader);
	    			pstmt.executeUpdate();
	    			pstmt.close();
    			}

    			if(insertOrUpdate == 1){
    				PreparedStatement pstmt = conn.prepareStatement(updateItemAssoc);
    				pstmt.setInt(1, item2ID);
    				pstmt.setString(2, itemloader);
    				pstmt.setInt(3, item1ID);
    				pstmt.setInt(4,storeCatalogId);
    				pstmt.executeUpdate();
    				pstmt.close();
    			}




    		}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.associateItem()=> "
                                   + e.getMessage());
        	}
    }


    public void checkCreateCategoryAssoc(Connection conn,int itemID,PollockItemView pollockItemView,String itemloader,int storeCatalogId, int storeNum) throws RemoteException{
    		log.info("CHECK AND CREATE CATEGORY ASSOCIATION");

    		String categoryName 		= 	pollockItemView.getcategoryName();
    		String subcat1Cd 			= 	pollockItemView.getsubcat1Cd();
    		String subcat2Cd 			= 	pollockItemView.getsubcat2Cd();
    		String subcat3Cd 			= 	pollockItemView.getsubcat3Cd();
    		int categoryMainId = 0;
    		int categoryAssocId = 0;

    		String selectCatAssoc = "select item2_id from clw_item_assoc where item1_id = ?";

    		String selectCategory = "select item_id from clw_item where upper(short_desc||long_desc) = upper(?) " +
			"and item_type_cd = ? and item_status_cd = ? and item_id in(select item_id from clw_catalog_structure " +
			" where catalog_id = ? and catalog_structure_cd = ?)";

    		String insertItemAssoc = "insert into clw_item_assoc(item_assoc_id,item1_id,item2_id,catalog_id," +
    				"item_assoc_cd,add_date,add_by,mod_date,mod_by) " +
    				"values(clw_item_assoc_seq.nextval,?,?,?,?,sysdate,?,sysdate,?)";

    		String updateItemAssoc = "update clw_item_assoc set item2_id = ? where item1_id = ? ";

    		try{
    		if(subcat3Cd == null){
				if(subcat2Cd == null){
					if(subcat1Cd == null){
						//associate Main Category

						PreparedStatement pstmt = conn.prepareStatement(selectCategory);
			    		pstmt.setString(1, categoryName);
			    		pstmt.setString(2, RefCodeNames.ITEM_TYPE_CD.CATEGORY);
			    		pstmt.setString(3, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
			    		pstmt.setInt(4, storeCatalogId);
			    		pstmt.setString(5, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
			    		ResultSet rs = pstmt.executeQuery();
			    		while(rs.next()){
			    			categoryMainId = rs.getInt(1);
			    			if (rs.next())
			            		throw new RemoteException("^clw^Multiple Active Category Associated for catalog_id =" + storeCatalogId + "catName = " + categoryName+"^clw^");

			    		}

						pstmt = conn.prepareStatement(selectCatAssoc);
						pstmt.setInt(1, itemID);
						while(rs.next()){
			    			categoryAssocId = rs.getInt(1);

			    			if (rs.next())
			            		throw new RemoteException("^clw^Multiple Active Store Catalog for store_id =" + storeNum+"^clw^");
			    		}
			    		if(categoryAssocId == 0){

							log.info("Frommmmm ELSE 333 itemID =" + selectCatAssoc);
			    			//Associate categoryMainId to itemID
			    			pstmt = conn.prepareStatement(insertItemAssoc);
			    			pstmt.setInt(1, itemID);
			    			pstmt.setInt(2, categoryMainId);
			    			pstmt.setInt(3, storeCatalogId);
			    			pstmt.setString(4, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
			    			pstmt.setString(5,itemloader);
			    			pstmt.setString(6,itemloader);
			    			pstmt.executeUpdate();
						}else {
			    			//update category Main assoc with itemid
							pstmt = conn.prepareStatement(updateItemAssoc);
			    			pstmt.setInt(1,itemID);
			    			pstmt.setInt(2,categoryAssocId);
			    			pstmt.executeUpdate();
			    		}
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Main Category categoryId = " + categoryAssocId);
						log.info("itemID =" + itemID);
					}else{
						//associate sub cat 1
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 categoryId = ");
					}
				}else{
					//associate sub cat 2
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 22222222222 categoryId = ");
				}
			}else{
				//associate sub cat 3
				log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 333333333333 categoryId = " );
			}
    		}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.checkCreateCategoryAssoc()=> "
                                   + e.getMessage());
        	}
    }

    public void updateItem(Connection conn, int itemID,int distID,PollockItemView pollockItemView,String itemloader,int storeNum) throws RemoteException{
    	log.info("Update Item item_id ============= " + itemID);

    	String packCd 				= 	pollockItemView.getpackCd();
    	String uomCd 				= 	pollockItemView.getuomCd();
    	String categoryName 		= 	pollockItemView.getcategoryName();
    	String subcat1Cd 			= 	pollockItemView.getsubcat1Cd();
    	String subcat2Cd 			= 	pollockItemView.getsubcat2Cd();
    	String subcat3Cd 			= 	pollockItemView.getsubcat3Cd();
    	String itemSize 			= 	pollockItemView.getitemSize();
    	String longDesc 			= 	pollockItemView.getlongDesc();
    	String shortDesc 			= 	pollockItemView.getshortDesc();
    	String productUpc 			= 	pollockItemView.getproductUpc();
    	String packUpc 				= 	pollockItemView.getpackUpc();
    	String unspscCode 			= 	pollockItemView.getunspscCode();
    	String colorCd 				= 	pollockItemView.getcolorCd();
    	String shippingWeight 		= 	pollockItemView.getshippingWeight();
    	String weightUnit 			= 	pollockItemView.getweightUnit();
    	String nsnCd 				= 	pollockItemView.getnsnCd();
    	String shippingCubicSize 	= 	pollockItemView.getshippingCubicSize();
    	String hazmatCd 			= 	pollockItemView.gethazmatCd();
    	String certifiedCompanies 	= 	pollockItemView.getcertifiedCompanies();
    	String manufacturerName 	= 	pollockItemView.getmanufacturerName();
    	String mcatO 				=   pollockItemView.getsortOrderMain();
		String sub1O 				=   pollockItemView.getsubCat1Order();
		String sub2O 				= 	pollockItemView.getsubCat2Order();
		String sub3O 				=	pollockItemView.getsubCat3Order();

    	int sortOrderMain = 0;
    	int subCat1Order = 0;
		int subCat2Order = 0;
		int subCat3Order = 0;

    	if(mcatO != null){
    	sortOrderMain = Integer.parseInt(mcatO);
    	}


    	if(sub1O != null){
    		subCat1Order = Integer.parseInt(sub1O);
    	}

    	if(sub2O != null){
    		subCat2Order = Integer.parseInt(sub2O);
    	}

    	if(sub3O != null){
    		subCat3Order = Integer.parseInt(sub3O);
    	}

    	String updateItem = "update clw_item set short_desc = ?,long_desc=?,item_status_cd = ?,mod_date=sysdate,mod_by = ? " +
    	"where item_id = ? ";

    	String updateItemMapping = "update clw_item_mapping set item_uom = ?,item_pack =?,mod_date=sysdate," +
    			"mod_by =? where item_id = ? and item_mapping_cd = ?";

    	String updateItemMappingManu = "update clw_item_mapping set item_uom = ?,item_pack =?,mod_date=sysdate," +
		"mod_by =?,bus_entity_id = ? where item_id = ? and item_mapping_cd = ?";

    	String updateItemMeta = "update clw_item_meta set clw_value = ?,mod_date=sysdate,mod_by = ? " +
    			"where name_value = ? and item_id = ?";
    	int storeCatalogId = getStoreCatalog(conn,storeNum);
    	int categoryId = 0;
    	int mainCategoryId = 0;
    	int subCat1Id = 0;
    	int subCat2Id = 0;
    	int subCat3Id = 0;

    	try{
    		//Update Item short desc and long Desc
    		PreparedStatement pstmt = conn.prepareStatement(updateItem);
    		pstmt.setString(1,shortDesc);
    		pstmt.setString(2,longDesc);
    		pstmt.setString(3,RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    		pstmt.setString(4,itemloader);
    		pstmt.setInt(5,itemID);
    		pstmt.executeUpdate();
    		pstmt.close();

    		//Update item mapping UOM and Pack Info
    		pstmt = conn.prepareStatement(updateItemMapping);
    		pstmt.setString(1,uomCd);
    		pstmt.setString(2,packCd);
    		pstmt.setString(3,itemloader);
    		pstmt.setInt(4, itemID);
    		pstmt.setString(5, RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
    		pstmt.executeUpdate();
    		pstmt.close();

    		int manufId= 0;
    		manufId = getManufId(conn,RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER,manufacturerName,storeNum);

    		pstmt = conn.prepareStatement(updateItemMappingManu);
    		pstmt.setString(1,uomCd);
    		pstmt.setString(2,packCd);
    		pstmt.setString(3,itemloader);
    		pstmt.setInt(4, manufId);
    		pstmt.setInt(5, itemID);
    		pstmt.setString(6, RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER);
    		pstmt.executeUpdate();
    		pstmt.close();

    		//Update item meta
    		pstmt = conn.prepareStatement(updateItemMeta);
    		pstmt.setInt(4, itemID);
    		pstmt.setString(2,itemloader);
    		//update pack info
    		pstmt.setString(1,packCd);
    		pstmt.setString(3,"PACK");
    		pstmt.addBatch();

    		//Update UOM Info
    		pstmt.setString(1,uomCd);
    		pstmt.setString(3,"UOM");
    		pstmt.addBatch();

    		//Update ITEM_SIZE Info
			if(itemSize != null){
			pstmt.setString(1,itemSize);
			pstmt.setString(3,"SIZE");
			pstmt.addBatch();
			}

			//Update PRODUCT_UPC Info
			if(productUpc != null){
			pstmt.setString(1,productUpc);
			pstmt.setString(3,"UPC_NUM");
			pstmt.addBatch();
			}

			//Update PACK_UPC Info
			if(packUpc != null){
			pstmt.setString(1,packUpc);
			pstmt.setString(3,"PKG_UPC_NUM");
			pstmt.addBatch();
			}

			//Update UNSPSC Code Info
			if(unspscCode != null){
			pstmt.setString(1,unspscCode);
			pstmt.setString(3,"UNSPSC_CD");
			pstmt.addBatch();
			}

			//Update COLOR Info
			if(colorCd != null){
			pstmt.setString(1,colorCd);
			pstmt.setString(3,"COLOR");
			pstmt.addBatch();
			}

			//Update Shipping Weight Info
			if(shippingWeight != null){
			pstmt.setString(1,shippingWeight);
			pstmt.setString(3,"SHIP_WEIGHT");
			pstmt.addBatch();
			}

			//Update Weight Unit Info
			if(weightUnit != null){
			pstmt.setString(1,weightUnit);
			pstmt.setString(3,"WEIGHT_UNIT");
			pstmt.addBatch();
			}

			//Update NSN Info
			if(nsnCd != null){
			pstmt.setString(1,nsnCd);
			pstmt.setString(3,"NSN");
			pstmt.addBatch();
			}

			//Update CUBE_SIZE Info
			if(shippingCubicSize != null){
			pstmt.setString(1,shippingCubicSize);
			pstmt.setString(3,"CUBE_SIZE");
			pstmt.addBatch();
			}

			//Update HAZMAT Info
			if(hazmatCd != null){
			hazmatCd = hazmatCd.toLowerCase();
			pstmt.setString(1,hazmatCd);
			pstmt.setString(3,"HAZMAT");
			pstmt.addBatch();
			}

			pstmt.executeBatch();
			pstmt.close();

			int sortOrder = 0;
		/*	if(subcat3Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,itemloader,subCat3Order);
			}

			if(subcat2Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader,subCat2Order);
			}

			if(subcat1Cd != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
			}

			if(categoryName != null){
				categoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
			}*/

			int itemAssocID = 0;
			//	int sortOrder = 0;
				if(subcat3Cd == null){
					if(subcat2Cd == null){
						if(subcat1Cd == null){
							//associate Main Category
						//	catId = checkIfCategoryExists(conn,storeCatalogId,categoryName);
							//checkCreateCategoryAssoc(conn,itemID,pollockItemView,itemloader,storeCatalogId,storeNum);
							mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
							itemAssocID = checkItemCatAssoc(conn,itemID,mainCategoryId,storeCatalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
							}else{
								associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
							}
							log.info("CCCCCCCAAAAAAAATTTTTTTT associate Main Category mainCategoryId = " + mainCategoryId);
						}else{
							//associate sub cat 1
					//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat1Cd);
							subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
							itemAssocID = checkItemCatAssoc(conn,itemID,subCat1Id,storeCatalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
							}else{
								associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
							}
							//Check Main Category and subcat1 Association
							log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
							mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
							//change(03/02/2010)
							itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);

							if(itemAssocID == 0){
								associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
							}else{
								associateItem(conn,subCat1Id,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
							}


						}
					}else{
						//associate sub cat 2
				//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat2Cd);
						subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader,subCat2Order);
						itemAssocID = checkItemCatAssoc(conn,itemID,subCat2Id,storeCatalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}else{
							associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}

						//Check subcat1 and subcat2 Association
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat2 = " + subcat2Cd + "sucat1 = " + subcat1Cd);
						subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
						itemAssocID = checkCatSucatAssoc(conn,subCat2Id,subCat1Id,storeCatalogId);
						if(itemAssocID == 0){
							associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
						}else{
							associateItem(conn,subCat2Id,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}


						//Check Main Category and subcat1 Association
						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
						mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
						itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);
						if(itemAssocID == 0){
							associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
						}else{
							associateItem(conn,subCat1Id,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
						}

					}
				}else{
					//associate sub cat 3
			//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat3Cd);

					subCat3Id = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,itemloader,subCat3Order);
					itemAssocID = checkItemCatAssoc(conn,itemID,subCat3Id,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}else{
						associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat3 = " + subcat3Cd + "sucat2 = " + subcat2Cd);
					//check subcat2 and subcat3 Association
					subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,itemloader,subCat2Order);
					itemAssocID = checkCatSucatAssoc(conn,subCat3Id,subCat2Id,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,subCat3Id,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
					}else{
						associateItem(conn,subCat3Id,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}

					//Check subcat1 and subcat2 Association
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 222222 subCat2 = " + subcat2Cd + "sucat1 = " + subcat1Cd);
					subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,itemloader,subCat1Order);
					itemAssocID = checkCatSucatAssoc(conn,subCat2Id,subCat1Id,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
					}else{
						associateItem(conn,subCat2Id,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}


					//Check Main Category and subcat1 Association
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1 = " + subcat1Cd + "main category = " + categoryName);
					mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,itemloader,sortOrderMain);
					itemAssocID = checkCatSucatAssoc(conn,subCat1Id,mainCategoryId,storeCatalogId);
					if(itemAssocID == 0){
						associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,storeCatalogId,itemloader);
					}else{
						associateItem(conn,subCat1Id,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,itemloader);
					}
					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 333333333333 subCat3Id = " + subCat3Id);
				}


			checkCreateCategoryAssoc(conn,itemID,pollockItemView,itemloader,storeCatalogId,storeNum);
			checkAndAddCertifiedCompany(conn,itemID,certifiedCompanies,itemloader,storeNum);
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateItem()=> "
                               + e.getMessage());
    	}

    }

    public void checkAndAddCertifiedCompany(Connection conn,int itemID,String certifiedCompanies,String itemloader,int storeNum) throws RemoteException{
    	String insertCretifiedCompanies = "insert into clw_item_mapping(item_mapping_id,item_id,bus_entity_id," +
		"item_mapping_cd,status_cd,add_date,add_by,mod_date,mod_by) " +
		"values(clw_item_mapping_seq.nextval,?,?,?,?,sysdate,?,sysdate,?)";

    	String deleteCertifiedCompanies = "delete from clw_item_mapping where item_mapping_cd = 'ITEM_CERTIFIED_COMPANY' " +
		"and item_id = ?";

    	try{
			log.info("checkAndAddCertifiedCompany Items to Certified Companies:");
			if(certifiedCompanies != null){
				int delRec = 0;
				log.info("DELETE CERTIFIED COMPANY DATA:::::::;;: item_id = " + itemID);
				log.info("DELETE CERTIFIED COMPANY DATA:::::::;;: sql = " + deleteCertifiedCompanies);
				PreparedStatement pstmt = conn.prepareStatement(deleteCertifiedCompanies);
				pstmt.setInt(1,itemID);
				delRec = pstmt.executeUpdate();
				pstmt.close();
				log.info("DONE DELETETING CERTIFIED COMPANY DATA:::::::;;: item_id = " + itemID + " Records Deleted =" + delRec + "=");
			//	pstmt = conn.prepareStatement(insertCretifiedCompanies);
			//	pstmt.setInt(1,itemID);
				int certifiedCompId = 0;
				String sp[] = certifiedCompanies.split(",");
				for(String s:sp) {
					s = s.trim();
					log.info("Certified Companies List:" + s);
					certifiedCompId = getCertifiedCompId(conn,s);
					if (certifiedCompId == 0) {
		    			throw new IllegalArgumentException("certifiedCompId not Found company" + s);
		    		}
					pstmt = conn.prepareStatement(insertCretifiedCompanies);
					pstmt.setInt(1,itemID);
				   	pstmt.setInt(2, certifiedCompId);
					pstmt.setString(3, RefCodeNames.ITEM_MAPPING_CD.ITEM_CERTIFIED_COMPANY);
					pstmt.setString(4, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
					pstmt.setString(5,itemloader);
					pstmt.setString(6,itemloader);
					//pstmt.addBatch();
					pstmt.executeUpdate();
					pstmt.close();

				}
			//	pstmt.executeBatch();
			//	pstmt.close();
				}

    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndAddCertifiedCompany()=> "
                               + e.getMessage());
    	}
    }

    public void inactivateItem(Connection conn,int itemID, String itemloader) throws RemoteException{
    	log.info("INActivate Item ItemID = " + itemID);

    	String updateItem = "update clw_item set item_status_cd = ?,mod_date=sysdate,mod_by=? " +
    		"where item_id = ?";

    	try{
    		PreparedStatement pstmt = conn.prepareStatement(updateItem);
    		pstmt.setString(1,RefCodeNames.ITEM_STATUS_CD.INACTIVE);
    		pstmt.setString(2,itemloader);
    		pstmt.setInt(3, itemID);

    		pstmt.executeUpdate();
    		pstmt.close();
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.inactivateItem()=> "
                               + e.getMessage());
    	}

    }


    public void processUser(Connection conn, String userloader, String userActionAdd,String userActionChange, String userActionDelete, int storeNum) throws RemoteException{
    	log.info("Start Data Checking");

    	String selectAccountCheck = "select account_ref_num from  CLT_POLLOCK_USER_LOADER " +
    			"where account_ref_num not in(select clw_value from clw_property where short_Desc = ?" +
    			" and bus_entity_id in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)) ";

    	String selectNull = "select count(*) from CLT_POLLOCK_USER_LOADER where add_by = ? " +
    			"and action in(?,?) " +
    			"and (action is null or version is null or store_id is null " +
    			"or store_name is null or account_ref_num is null or site_ref_num is null or username is null " +
    			"or password is null or update_password is null or preferred_language is null or first_name is null " +
    			"or last_name is null or address1 is null or city is null or state is null or postal_code is null " +
    			"or country is null or email is null or approver is null or needs_approval is null " +
    			"or WAS_APPROVED is null or WAS_REJECTED is null or WAS_MODIFIED is null or CORPORATE_USER is null " +
    			"or RECEIVE_INVENTORY_MIS_EMAIL is null or ON_ACCOUNT is null or CREDIT_CARD is null " +
    			"or OTHER_PAYMENT is null or PO_NUM_REQUIRED is null or SHOW_PRICE is null or CONTRACT_ITEMS_ONLY is null " +
    			"or ORDER_DETAIL_NOTIFICATION is null or SHIPPING_NOTIFICATION is null)";

    	String selectUserInactive = "select count(*) from CLT_POLLOCK_USER_LOADER where add_by = ? " +
			"and action = ? " +
			"and (action is null or store_id is null or account_ref_num is null or site_ref_num is null)";

    	/*String selectSiteCheck = "select site_ref_num,site_name from CLT_POLLOCK_USER_LOADER " +
    			"where site_ref_num not in(select clw_value from clw_property where bus_entity_id " +
    			"in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id " +
    			"in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)) " +
    			"and short_desc = ?) ";*/
    	String selectSiteCheck = "select site_ref_num from CLT_POLLOCK_USER_LOADER t " +
		"where not exists(select clw_value from clw_property where t.site_ref_num = clw_value and bus_entity_id " +
		"in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id " +
		"in(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)) " +
		"and short_desc = ?) ";

    	String selectUsernameSize = "select count(*) from CLT_POLLOCK_USER_LOADER " +
    	" where add_by = ? and length(username) > 30";

    	String selectPasswordSize = "select count(*) from CLT_POLLOCK_USER_LOADER " +
    	" where add_by = ? and length(password) > 30";

    	String selectUserCheck = "select distinct username from CLT_POLLOCK_USER_LOADER " +
    			"where add_by = ? and action in(?,?)";

    	String selectUserDel = "select distinct username from CLT_POLLOCK_USER_LOADER " +
    			"where add_by = ? and action in(?)";

    	String inactiveUser = "select distinct username from CLT_POLLOCK_USER_LOADER " ;
    			//"where action in(?)";


    	try{

			PreparedStatement pstmt = conn.prepareStatement(selectNull);
			pstmt.setString(1, userloader);
			pstmt.setString(2, userActionAdd);
			pstmt.setString(3, userActionChange);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}
			log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 1111111111111111111111 Oneeeeee of the mandatory field is null");
			} else{
				log.info("CHECK 1111111111111111111111 Counttttt is zero continue = " + count);
			}

			pstmt.close();

			pstmt = conn.prepareStatement(selectUserInactive);
			pstmt.setString(1, userloader);
			pstmt.setString(2, userActionDelete);
			rs = pstmt.executeQuery();
			while(rs.next()){
				count = rs.getInt(1);
			}
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 5555555555 Oneeeeee of the mandatory field is null");
			} else{
				log.info("CHECK 5555555555 Counttttt is zero continue = " + count);
			}
			pstmt.close();


			pstmt = conn.prepareStatement(selectAccountCheck);
			pstmt.setString(1, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setInt(2, storeNum);
			//pstmt.setString(3, userloader);
			rs = pstmt.executeQuery();

			boolean foundMissingAccounts=false;
			StringBuffer missingAccounts = new StringBuffer();
			while(rs.next()){
				foundMissingAccounts = true;
				missingAccounts.append(rs.getString(1));
				missingAccounts.append(",");

			}

			if (foundMissingAccounts ) {
				throw new IllegalArgumentException("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}
			pstmt.close();

			boolean foundMissingSites=false;
			StringBuffer missingSites = new StringBuffer();

			pstmt = conn.prepareStatement(selectSiteCheck);
			pstmt.setInt(1, storeNum);
			pstmt.setString(2, RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
			//pstmt.setString(3, userloader);
			rs = pstmt.executeQuery();

			while(rs.next()){
				foundMissingSites = true;
				missingSites.append(rs.getString(1));
				missingSites.append(",");
			}

			if (foundMissingSites ) {
				throw new IllegalArgumentException("Could not find Sites using store id: "+storeNum+" and Site reference number: "+missingSites);

			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}


			pstmt.close();
			//Check the Username size
			pstmt = conn.prepareStatement(selectUsernameSize);
			pstmt.setString(1, userloader);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				}

			if (count > 0) {
				throw new IllegalArgumentException("CHECK 4444444 ERROR Username is greater then 30 characters = " + selectUsernameSize);
			} else{
				log.info("CHECK 444444 is success continue = ");
			}
			pstmt.close();

			//Check the Password size
			pstmt = conn.prepareStatement(selectPasswordSize);
			pstmt.setString(1, userloader);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				}

			if (count > 0) {
				throw new IllegalArgumentException("CHECK 4444444 ERROR selectPasswordSize is greater then 30 characters = " + selectPasswordSize);
			} else{
				log.info("CHECK 444444 is success continue = ");
			}
			pstmt.close();

			//Check if user all exits in the same store
			PreparedStatement pstmt1 = conn.prepareStatement(selectUserCheck);
			//pstmt = conn.prepareStatement(selectUserCheck);
			pstmt1.setString(1, userloader);
			pstmt1.setString(2, userActionAdd);
			pstmt1.setString(3, userActionChange);
			//pstmt.setString(4,userActionDelete);
			rs = pstmt1.executeQuery();
			int userID = 0;
			while(rs.next()){

			String userN = rs.getString(1);
			userID = userCheck(conn,userN,storeNum);

			log.info("USERID = =======================" + userID);
			if(userID == 0){
				log.info("Create USer username =============== " + userN);
				createUser(conn,userN,storeNum,userloader);

			}else{
				log.info("Uuuuuupdate Userrrrrrrrrrrrr");
				log.info("Update user where username = " + userN + "User id ====" + userID);
				updateUser(conn,userN,storeNum,userloader);
			}


			}
			pstmt1.close();

			PreparedStatement pstmt4 = conn.prepareStatement(selectUserDel);
			//pstmt = conn.prepareStatement(selectUserDel);
			pstmt4.setString(1, userloader);
			pstmt4.setString(2,userActionDelete);
			rs = pstmt4.executeQuery();
			userID = 0;
			Map userDelMap = new HashMap();
			while(rs.next()){
				String userN = rs.getString(1);
				userID = getUserId(conn,userN,storeNum);
				createUserAssociations(userID,userN,storeNum,userloader,conn);
				userDelMap.put(userN, new Integer(userID));
			}
			pstmt4.close();
			
			//Now remove any account associations if user has no site association
			String checkUserAssoc = "select count(*) from clw_user_assoc where user_id = ? and user_assoc_cd in(?)";
			pstmt4 = conn.prepareStatement(checkUserAssoc);
			String deleteAccountAssoc = "delete from clw_user_assoc where user_id = ? and user_assoc_cd in(?)";
			pstmt = conn.prepareStatement(deleteAccountAssoc);			
			
			Iterator it = userDelMap.keySet().iterator();
			while (it.hasNext()){
				String userN = (String) it.next();
				int userId = ((Integer)userDelMap.get(userN)).intValue();
				pstmt4.setInt(1, userId);
				pstmt4.setString(2, RefCodeNames.USER_ASSOC_CD.SITE);
    			rs = pstmt4.executeQuery();
    			rs.next();    			
    			count = rs.getInt(1);
    			if(count == 0){
    				pstmt.setInt(1, userId);
    				pstmt.setString(2, RefCodeNames.USER_ASSOC_CD.ACCOUNT);
    				pstmt.execute();    				
    			}				
			}
			pstmt4.close();
			pstmt.close();
			

			PreparedStatement pstmt5 = conn.prepareStatement(inactiveUser);
			//pstmt = conn.prepareStatement(inactiveUser);
			//pstmt.setString(1,userActionDelete);
			rs = pstmt5.executeQuery();
			while(rs.next()){
				String userN = rs.getString(1);
				userID = getUserId(conn,userN,storeNum);
				CheckAndChangeUserStatus(conn,userID,userloader);
			}
			pstmt5.close();
			conn.close();

    	}catch(Exception e){
    		throw processException(e);
    	}
    }


    	public void CheckAndChangeUserStatus(Connection conn,int userId,String userloader)  throws RemoteException{
    		String activeUser = "update clw_user set user_status_cd = ?,mod_date=sysdate,mod_by =? " +
    				"where user_id = ? and user_status_cd = ?";

    		String checkUserAssoc = "select count(*) from clw_user_assoc where user_id = ? " +
    				"and user_assoc_cd in(?,?)";



    		try{
    			PreparedStatement pstmt = conn.prepareStatement(checkUserAssoc);
    			pstmt.setInt(1, userId);
    			pstmt.setString(2, RefCodeNames.USER_ASSOC_CD.ACCOUNT);
    			pstmt.setString(3, RefCodeNames.USER_ASSOC_CD.SITE);
    			ResultSet rs = pstmt.executeQuery();
    			int count = 0;
    			while(rs.next()){
    				count = rs.getInt(1);
    			}
    			pstmt.close();
    			if(count > 0){
    			pstmt = conn.prepareStatement(activeUser);
    			pstmt.setString(1, RefCodeNames.USER_STATUS_CD.ACTIVE);
    			pstmt.setString(2, userloader);
    			pstmt.setInt(3, userId);
    			pstmt.setString(4, RefCodeNames.USER_STATUS_CD.INACTIVE);
    			pstmt.executeUpdate();
    			pstmt.close();
    			}

    		}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.processUser()=> "
                                   + e.getMessage());
        	}

    	}

    	public int userCheck(Connection conn,String userN,int storeNum)  throws RemoteException{
    		log.info("Check If user Existssssssssssssss");
    		String selectUserId = "select user_id from clw_user where user_name = ?";

    		String selectUserAssocCheck = "select count(*) from clw_user_assoc where user_id = ? " +
    			"and bus_entity_id = ?";


    		int userID = 0;

    		try{

    			PreparedStatement pstmt = conn.prepareStatement(selectUserId);
    			pstmt.setString(1, userN);
    			ResultSet rs = pstmt.executeQuery();
    			rs = pstmt.executeQuery();
    			while(rs.next()){

    				userID = rs.getInt(1);
    			}
    			pstmt.close();
    			int count = 0;
    			if (userID > 0){
    				pstmt = conn.prepareStatement(selectUserAssocCheck);
        			pstmt.setInt(1, userID);
        			pstmt.setInt(2, storeNum);
        			rs = pstmt.executeQuery();
        			while(rs.next()){

        				count = rs.getInt(1);
        			}
        			pstmt.close();
        			if (count > 0){
        				log.info("User Already Exists in System and is associated to store");
        				log.info("User ID = " + userID + "storeID = " + storeNum);
        		//		return userID;
        			}else{
        				throw new IllegalArgumentException("Error User Already Exixts in System but is not Associate to Store = " + storeNum + "userID = " + userID);
        			}
    			}


    		}catch(Exception e){
        		e.printStackTrace();
        		//throw e;
        		   throw new RemoteException(
                           "Error.IntegrationServicesBean.processSiteDelivery()=> "
                                   + e.getMessage());
        	}




    		return userID;
    }


    	public void createUser(Connection conn,String userN,int storeNum,String userloader) throws RemoteException{

			String createUserAcc = "SELECT DISTINCT STORE_ID,STORE_NAME,USERNAME,PASSWORD,UPDATE_PASSWORD,PREFERRED_LANGUAGE," +
					"FIRST_NAME,LAST_NAME,ADDRESS1,ADDRESS2,CITY,STATE,POSTAL_CODE,COUNTRY,PHONE,EMAIL,FAX," +
					"MOBILE,APPROVER,NEEDS_APPROVAL,WAS_APPROVED,WAS_REJECTED,WAS_MODIFIED,CORPORATE_USER," +
					"RECEIVE_INVENTORY_MIS_EMAIL,ON_ACCOUNT,CREDIT_CARD,OTHER_PAYMENT,PO_NUM_REQUIRED," +
					"SHOW_PRICE,CONTRACT_ITEMS_ONLY,BROWSE_ONLY,NO_REPORTING,ORDER_DETAIL_NOTIFICATION," +
					"SHIPPING_NOTIFICATION,WORK_ORDER_COMPLETED_NOTIFI,WORK_ORDER_ACCEPTED_NOTIFI," +
					"WORK_ORDER_REJECTED_NOTIFI,GROUP_ID from CLT_POLLOCK_USER_LOADER " +
					"where add_by = ? and username = ?";

        	 /*String selectUser = "select VERSION,ACTION,STORE_ID,STORE_NAME,ACCOUNT_REF_NUM,ACCOUNT_NAME,SITE_NAME,SITE_REF_NUM," +
			"USERNAME,PASSWORD,UPDATE_PASSWORD,PREFERRED_LANGUAGE,FIRST_NAME,LAST_NAME,ADDRESS1,ADDRESS2,CITY,STATE," +
			"POSTAL_CODE,COUNTRY,PHONE,EMAIL,FAX,MOBILE,APPROVER,NEEDS_APPROVAL,WAS_APPROVED,WAS_REJECTED," +
			"WAS_MODIFIED,CORPORATE_USER,RECEIVE_INVENTORY_MIS_EMAIL,ON_ACCOUNT,CREDIT_CARD,OTHER_PAYMENT,PO_NUM_REQUIRED," +
			"SHOW_PRICE,CONTRACT_ITEMS_ONLY,BROWSE_ONLY,NO_REPORTING,ORDER_DETAIL_NOTIFICATION,SHIPPING_NOTIFICATION," +
			"WORK_ORDER_COMPLETED_NOTIFI,WORK_ORDER_ACCEPTED_NOTIFI,WORK_ORDER_REJECTED_NOTIFI,GROUP_ID " +
			"from CLT_POLLOCK_USER_LOADER where add_date >= trunc(sysdate) and add_by = ?";*/

        	String insertPhone = "insert into clw_phone(phone_id,user_id,phone_num,phone_type_cd,phone_status_cd," +
        			"primary_ind,add_date,add_by,mod_date,mod_by) " +
        			"values(clw_phone_seq.nextval,?,?,?,'ACTIVE',1,sysdate,?,sysdate,?)";

        	String insertProperty = "insert into clw_property(property_id,user_id,short_desc,clw_value," +
        			"property_status_cd,property_type_cd,add_date,add_by,mod_date,mod_by) " +
        			"values(clw_property_seq.nextval,?,?,?,?,?,sysdate,?,sysdate,?)";



        	//String selectDistinctAccount = "select distinct account_ref_num from CLT_POLLOCK_USER_LOADER " +
        	//		"where username = ? and Action in ('A','C') ";

        	//String selectDistinctSite = "select distinct site_ref_num,ACCOUNT_REF_NUM from CLT_POLLOCK_USER_LOADER " +
        	//	"where username = ? and Action in ('A','C') ";

        	String insertGroup = "insert into clw_group_assoc(group_assoc_id,group_assoc_cd,add_date,add_by," +
        			"mod_date,mod_by,user_id,group_id,bus_entity_id) " +
        			"values(clw_group_assoc_seq.nextval,'USER_OF_GROUP',sysdate,?,sysdate,?,?,?,0)";

			Date runDate = new Date();
			int userId = 0;
			UserBean usrBean = new UserBean();			

        	try{

        	PreparedStatement pstmt2 = conn.prepareStatement(createUserAcc);
			pstmt2.setString(1, userloader);
			pstmt2.setString(2, userN);
			ResultSet rs = pstmt2.executeQuery();
			while(rs.next()){

			//	 boolean theValue = Boolean.parseBoolean(strBoolean);

				String storeId = rs.getString(1);
				String storeName = rs.getString(2);
				String username = rs.getString(3);
				String password = rs.getString(4);
				String updatePassword = rs.getString(5);
				String preferredLanguage = rs.getString(6);
				String firstName = rs.getString(7);
				String lastName = rs.getString(8);
				String address1 = rs.getString(9);
				String address2 = rs.getString(10);
				String city = rs.getString(11);
				String state = rs.getString(12);
				String postalCode = rs.getString(13);
				String country = rs.getString(14);
				String phone = rs.getString(15);
				String email = rs.getString(16);
				String fax = rs.getString(17);
				String mobile = rs.getString(18);
				boolean approver = Boolean.parseBoolean(rs.getString(19));
				boolean needsApproval = Boolean.parseBoolean(rs.getString(20));
				boolean wasApproved = Boolean.parseBoolean(rs.getString(21));
				boolean wasRejected = Boolean.parseBoolean(rs.getString(22));
				boolean wasModified = Boolean.parseBoolean(rs.getString(23));
				String corporateUser = rs.getString(24);
				String receiveInventoryMisEmail = rs.getString(25);
				boolean onAccount = Boolean.parseBoolean(rs.getString(26));
				boolean creditCard = Boolean.parseBoolean(rs.getString(27));
				boolean otherPayment = Boolean.parseBoolean(rs.getString(28));
				boolean poNumRequired = Boolean.parseBoolean(rs.getString(29));
				boolean showPrice = Boolean.parseBoolean(rs.getString(30));
				boolean contractItemsOnly = Boolean.parseBoolean(rs.getString(31));
				boolean browseOnly = Boolean.parseBoolean(rs.getString(32));
				boolean noReporting = Boolean.parseBoolean(rs.getString(33));
				boolean orderDetailNotification = Boolean.parseBoolean(rs.getString(34));
				boolean shippingNotification = Boolean.parseBoolean(rs.getString(35));
				boolean workOrderCompletedNotifi = Boolean.parseBoolean(rs.getString(36));
				boolean workOrderAcceptedNotifi = Boolean.parseBoolean(rs.getString(37));
				boolean workOrderRejectedNotifi = Boolean.parseBoolean(rs.getString(38));
				String groupID = rs.getString(39);


				UserData userData = UserData.createValue();
				userData.setFirstName(firstName);
				userData.setLastName(lastName);
				userData.setUserName(username);
				//userData.setPassword(password);
				userData.setPassword(PasswordUtil.getHash(username,password));
				userData.setEffDate(runDate);
				userData.setUserStatusCd(RefCodeNames.USER_STATUS_CD.ACTIVE);
				userData.setUserTypeCd(RefCodeNames.USER_TYPE_CD.MSB);
				userData.setPrefLocaleCd(preferredLanguage);
				userData.setAddBy(userloader);
				userData.setModBy(userloader);

				if(approver){
					userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER);
				//	log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE = ORDER_APPROVER" );
				}else{
					userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN);
					//log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE == UNKNOWN" );
				}

				UserRightsTool userRightstool = new UserRightsTool(userData);

				userRightstool.setCanApprovePurchases(approver);
				//log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE = " + userRightstool.getCanApprovePurchases());
				userRightstool.setEmailForApproval(needsApproval);
				userRightstool.setEmailOrderApproved(wasApproved);
				userRightstool.setEmailOrderRejection(wasRejected);
				userRightstool.setEmailOrderModifications(wasModified);
				userRightstool.setOnAccount(onAccount);
				userRightstool.setCreditCardFlag(creditCard);
				userRightstool.setOtherPaymentFlag(otherPayment);
				userRightstool.setPoNumRequired(poNumRequired);
				userRightstool.setShowPrice(showPrice);
				userRightstool.setUserOnContract(contractItemsOnly);
				userRightstool.setBrowseOnly(browseOnly);
				userRightstool.setNoReporting(noReporting);
				userRightstool.setNoReporting(false);
				userRightstool.setEmailOrderDetailNotification(orderDetailNotification);
				userRightstool.setOrderNotificationShipped(shippingNotification);
				userRightstool.setWorkOrderCompletedNotification(workOrderCompletedNotifi);
				userRightstool.setWorkOrderAcceptedByProviderNotification(workOrderAcceptedNotifi);
				userRightstool.setWorkOrderRejectedByProviderNotification(workOrderRejectedNotifi);

                String userRights = userRightstool.makePermissionsToken();
                userData.setUserRoleCd(userRights);
                //userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN);
                userData = UserDataAccess.insert(conn, userData);

                userId = userData.getUserId();
                usrBean.createPasswordHistoryIfChanged(conn, userData, true, false);


                //Add Address
                AddressData addressData = AddressData.createValue();
                addressData.setUserId(userId);
                addressData.setName1(firstName);
                addressData.setName2(lastName);
                addressData.setAddress1(address1);
                if(address2 != null){
                	addressData.setAddress2(address2);
                }
                addressData.setCity(city);
                addressData.setStateProvinceCd(state);
                addressData.setPostalCode(postalCode);
                addressData.setCountryCd(country);
                addressData.setAddressStatusCd(RefCodeNames.ADDRESS_STATUS_CD.ACTIVE);
                addressData.setAddressTypeCd(RefCodeNames.ADDRESS_TYPE_CD.PRIMARY_CONTACT);
                addressData.setPrimaryInd(true);
                addressData.setAddBy(userloader);
                addressData.setModBy(userloader);
                AddressDataAccess.insert(conn, addressData);


                //Add Phone
                PreparedStatement pstmt = conn.prepareStatement(insertPhone);
                //pstmt = conn.prepareStatement(insertPhone);
                pstmt.setInt(1, userId);
                pstmt.setString(4,userloader);
                pstmt.setString(5,userloader);

                //add phone number
                pstmt.setString(2,phone);
                pstmt.setString(3, RefCodeNames.PHONE_TYPE_CD.PHONE);
                pstmt.addBatch();

                //add Mobile number
                pstmt.setString(2,mobile);
                pstmt.setString(3, RefCodeNames.PHONE_TYPE_CD.MOBILE);
                pstmt.addBatch();

                //add Fax number
                pstmt.setString(2,fax);
                pstmt.setString(3, RefCodeNames.PHONE_TYPE_CD.FAX);
                pstmt.addBatch();

                pstmt.executeBatch();
                pstmt.close();


                //Add Email
                EmailData emailData = EmailData.createValue();
                emailData.setUserId(userId);
                emailData.setEmailAddress(email);
                emailData.setEmailTypeCd(RefCodeNames.EMAIL_TYPE_CD.PRIMARY_CONTACT);
                emailData.setEmailStatusCd(RefCodeNames.EMAIL_STATUS_CD.ACTIVE);
                emailData.setPrimaryInd(true);
                emailData.setAddBy(userloader);
                emailData.setModBy(userloader);
                EmailDataAccess.insert(conn, emailData);


                //Associate User to Store
                UserAssocData userAssocData = UserAssocData.createValue();
                userAssocData.setUserId(userId);
                userAssocData.setBusEntityId(storeNum);
                userAssocData.setUserAssocCd(RefCodeNames.USER_ASSOC_CD.STORE);
                userAssocData.setAddBy(userloader);
                userAssocData.setModBy(userloader);
                UserAssocDataAccess.insert(conn, userAssocData);


                //Add Property

                pstmt = conn.prepareStatement(insertProperty);
                pstmt.setInt(1,userId);
                pstmt.setString(6,userloader);
                pstmt.setString(7,userloader);
                pstmt.setString(4,RefCodeNames.PROPERTY_STATUS_CD.ACTIVE);

                //Add Corporate User
                pstmt.setString(2,RefCodeNames.PROPERTY_TYPE_CD.CORPORATE_USER);
                pstmt.setString(3,corporateUser);
                pstmt.setString(5,RefCodeNames.PROPERTY_TYPE_CD.CORPORATE_USER);
                pstmt.addBatch();

                //Add Missing Inventory Missing Email
                pstmt.setString(2,RefCodeNames.PROPERTY_TYPE_CD.RECEIVE_INV_MISSING_EMAIL);
                pstmt.setString(3,receiveInventoryMisEmail);
                pstmt.setString(5,RefCodeNames.PROPERTY_TYPE_CD.RECEIVE_INV_MISSING_EMAIL);
                pstmt.addBatch();

                pstmt.executeBatch();
                pstmt.close();

              //Add Group ID
//                log.info("ADDDD GROUPPPP IDDDDDDD = " + groupID);
                if(Utility.isSet(groupID) && !groupID.equals("0")){
	                pstmt = conn.prepareStatement(insertGroup);
	                pstmt.setString(1,userloader);
	                pstmt.setString(2,userloader);
	                pstmt.setInt(3,userId);
	    			String sp[] = groupID.split(",");
	    			for(String s:sp) {
	    				s = s.trim();
	    			   log.info("1111 GroupIDDDDDDDDDDDDDDDDD = " + s);
	    			   int groupId = Integer.parseInt(s);
	    			   	pstmt.setInt(4, groupId);
	    				pstmt.addBatch();

	    			}
	    			pstmt.executeBatch();
	                pstmt.close();
                }



			}
			pstmt2.close();
			userId = getUserId(conn,userN,storeNum);
			if(userId > 0){
				createUserAssociations(userId, userN,storeNum,userloader,conn);
			}

        	}catch(Exception e){
        		throw processException(e);
        	}
    	}


    	/**
    	 * Creates the user associations to accounts and sites.  Also will set the user status to inactive if there are no
    	 * associations to sites when the loader is finished.
    	 */
	private void createUserAssociations(int userId, String userN, int storeNum,
			String userloader, Connection conn) throws SQLException,
			RemoteException {
		String selectDistinctAccount = "select distinct account_ref_num from CLT_POLLOCK_USER_LOADER "
				+ "where username = ? and Action in ('A','C') ";

		String selectDistinctSite = "select distinct site_ref_num,ACCOUNT_REF_NUM from CLT_POLLOCK_USER_LOADER "
				+ "where username = ? and Action in ('A','C') ";

		String selectDistinctSiteRemove = "select distinct site_ref_num,ACCOUNT_REF_NUM from CLT_POLLOCK_USER_LOADER "
				+ "where username = ? and Action in ('D') ";

		String selectDistinctAccountRemove = "select distinct account_ref_num from CLT_POLLOCK_USER_LOADER "
				+ "where username = ? and Action in ('D') ";

		String selectCountUserAssocCodes = "select count(*) from clw_user_assoc where user_assoc_cd = '"+RefCodeNames.USER_ASSOC_CD.SITE+"' and user_id = ?";

		String updateUserInactive = "update clw_user set user_status_cd = 'INACTIVE' where user_id = ?";


		//First add associations
		PreparedStatement pstmt = conn.prepareStatement(selectDistinctAccount);
		pstmt.setString(1, userN);
		ResultSet rs = pstmt.executeQuery();
		String accRefNum = "";
		int accountID = 0;
		while (rs.next()) {

			accRefNum = rs.getString(1);
			accountID = getAccountId(conn, accRefNum, storeNum);
			checkAndCreateUserAccountAssoc(conn, userId, accountID, userloader);
		}
		pstmt.close();

		// check and add assoc sites to user
		pstmt = conn.prepareStatement(selectDistinctSite);
		pstmt.setString(1, userN);
		rs = pstmt.executeQuery();
		String siteRefNum = "";
		int siteID = 0;
		while (rs.next()) {
			siteRefNum = rs.getString(1);
			accRefNum = rs.getString(2);
			siteID = getSiteId(conn, siteRefNum, accRefNum, storeNum);
			if (siteID > 0) {
				checkAndCreateUserSiteAssoc(conn, userId, siteID, accountID,
						userloader);
			} else {
				log.info("Error Site Does not Exists in Account siteRefNum = "
						+ siteRefNum + "accRefNum = " + accRefNum);
			}
		}
		pstmt.close();

		//Now remove any associations
		//STJ-3856
		/*pstmt = conn.prepareStatement(selectDistinctAccountRemove);
		pstmt.setString(1, userN);
		rs = pstmt.executeQuery();
		while (rs.next()) {

			accRefNum = rs.getString(1);
			accountID = getAccountId(conn, accRefNum, storeNum);
			checkAndRemoveCreateUserBusEntAssoc(conn, userId, accountID);
		}
		pstmt.close();*/

		// check and add assoc sites to user
		pstmt = conn.prepareStatement(selectDistinctSiteRemove);
		pstmt.setString(1, userN);
		rs = pstmt.executeQuery();
		siteRefNum = "";
		siteID = 0;
		while (rs.next()) {
			siteRefNum = rs.getString(1);
			accRefNum = rs.getString(2);
			siteID = getSiteId(conn, siteRefNum, accRefNum, storeNum);
			if (siteID > 0) {
				checkAndRemoveCreateUserBusEntAssoc(conn, userId, siteID);
			} else {
				log.info("Site Does not Exists in Account siteRefNum = "
						+ siteRefNum + "accRefNum = " + accRefNum);
			}
		}
		pstmt.close();


		pstmt = conn.prepareStatement(selectCountUserAssocCodes);
		pstmt.setInt(1, userId);
		rs = pstmt.executeQuery();
		rs.next();
		int count = rs.getInt(1);
		pstmt.close();
		if(count == 0){
			//no sites associated with this user, inactivate it.
			pstmt = conn.prepareStatement(updateUserInactive);
			pstmt.setInt(1, userId);
			count = pstmt.executeUpdate();
			if(count!=1){
				throw new RemoteException("When inactivating user update count did not equal 1 update count="+count+" using sql: "+updateUserInactive+" for user id="+userId);
			}
			pstmt.close();
		}
//		pstmt.close();
	}


public void updateUser(Connection conn,String userN,int storeNum,String userloader) throws RemoteException{
	log.info("START updateUser for userN="+userN+" storeNum = "+storeNum);
	String createUserAcc = "SELECT DISTINCT STORE_ID,STORE_NAME,USERNAME,PASSWORD,UPDATE_PASSWORD,PREFERRED_LANGUAGE," +
	"FIRST_NAME,LAST_NAME,ADDRESS1,ADDRESS2,CITY,STATE,POSTAL_CODE,COUNTRY,PHONE,EMAIL,FAX," +
	"MOBILE,APPROVER,NEEDS_APPROVAL,WAS_APPROVED,WAS_REJECTED,WAS_MODIFIED,CORPORATE_USER," +
	"RECEIVE_INVENTORY_MIS_EMAIL,ON_ACCOUNT,CREDIT_CARD,OTHER_PAYMENT,PO_NUM_REQUIRED," +
	"SHOW_PRICE,CONTRACT_ITEMS_ONLY,BROWSE_ONLY,NO_REPORTING,ORDER_DETAIL_NOTIFICATION," +
	"SHIPPING_NOTIFICATION,WORK_ORDER_COMPLETED_NOTIFI,WORK_ORDER_ACCEPTED_NOTIFI," +
	"WORK_ORDER_REJECTED_NOTIFI,GROUP_ID,ACTION from CLT_POLLOCK_USER_LOADER " +
	"where add_by = ? and username = ?";

	String updateUsers = "update clw_user set first_name = ?,last_name = ?,user_role_cd = ?," +
			"pref_locale_cd = ?,workflow_role_cd = ?,mod_by = ?,user_status_cd = 'ACTIVE',mod_date = sysdate " +
			"where user_id = ?";

	String updateUserAddress = "update clw_address set name1 = ?,name2 = ?,address1=?,address2=?,city=?," +
			"state_province_cd = ?,country_cd = ?,postal_code = ?,mod_by = ?, mod_date = sysdate " +
			"where user_id = ?";

	String updateUserEmail = "update clw_email set email_address = ?,mod_by = ?,mod_date = sysdate " +
			"where user_id = ? ";

	String updateUserPhone = "update clw_phone set phone_num = ?,mod_by = ?,mod_date = sysdate " +
			"where user_id = ? and phone_type_cd = ?";

	String updateUserProperty = "update clw_property set clw_value = ?,mod_by = ?,mod_date = sysdate " +
			"where user_id = ? and short_desc = ?";

	String insertGroup = "insert into clw_group_assoc(group_assoc_id,group_assoc_cd,add_date,add_by," +
			"mod_date,mod_by,user_id,group_id,bus_entity_id) " +
			"values(clw_group_assoc_seq.nextval,'USER_OF_GROUP',sysdate,?,sysdate,?,?,?,0)";

	String selectDistinctAccount = "select distinct account_ref_num from CLT_POLLOCK_USER_LOADER " +
	"where username = ? and Action in ('A','C') ";

    String selectDistinctSite = "select distinct site_ref_num,ACCOUNT_REF_NUM from CLT_POLLOCK_USER_LOADER " +
    "where username = ? and Action in ('A','C') ";

   String UpdateUserInfo = "update clw_user set first_name = ?,last_name=?,user_role_cd = ?," +
	  "pref_locale_cd=?,workflow_role_cd=?,mod_date=sysdate,mod_by=?  where user_id = ?";

   String updateUserPassword = "update clw_user set password = ?,mod_date=sysdate,mod_by=? where user_id = ?";

	Date runDate = new Date();
	UserBean usrBean = new UserBean();	

	try{
		int userId = 0;
		PreparedStatement pstmt8 = conn.prepareStatement(createUserAcc);
    	pstmt8.setString(1, userloader);
		pstmt8.setString(2, userN);
		ResultSet rs = pstmt8.executeQuery();
		while(rs.next()){

		//	 boolean theValue = Boolean.parseBoolean(strBoolean);

			String storeId = rs.getString(1);
			String storeName = rs.getString(2);
			String username = rs.getString(3);
			String password = rs.getString(4);
			boolean updatePassword = Boolean.parseBoolean(rs.getString(5));
			String preferredLanguage = rs.getString(6);
			String firstName = rs.getString(7);
			String lastName = rs.getString(8);
			String address1 = rs.getString(9);
			String address2 = rs.getString(10);
			String city = rs.getString(11);
			String state = rs.getString(12);
			String postalCode = rs.getString(13);
			String country = rs.getString(14);
			String phone = rs.getString(15);
			String email = rs.getString(16);
			String fax = rs.getString(17);
			String mobile = rs.getString(18);
			boolean approver = Boolean.parseBoolean(rs.getString(19));
			boolean needsApproval = Boolean.parseBoolean(rs.getString(20));
			boolean wasApproved = Boolean.parseBoolean(rs.getString(21));
			boolean wasRejected = Boolean.parseBoolean(rs.getString(22));
			boolean wasModified = Boolean.parseBoolean(rs.getString(23));
			String corporateUser = rs.getString(24);
			String receiveInventoryMisEmail = rs.getString(25);
			boolean onAccount = Boolean.parseBoolean(rs.getString(26));
			boolean creditCard = Boolean.parseBoolean(rs.getString(27));
			boolean otherPayment = Boolean.parseBoolean(rs.getString(28));
			boolean poNumRequired = Boolean.parseBoolean(rs.getString(29));
			boolean showPrice = Boolean.parseBoolean(rs.getString(30));
			boolean contractItemsOnly = Boolean.parseBoolean(rs.getString(31));
			boolean browseOnly = Boolean.parseBoolean(rs.getString(32));
			boolean noReporting = Boolean.parseBoolean(rs.getString(33));
			boolean orderDetailNotification = Boolean.parseBoolean(rs.getString(34));
			boolean shippingNotification = Boolean.parseBoolean(rs.getString(35));
			boolean workOrderCompletedNotifi = Boolean.parseBoolean(rs.getString(36));
			boolean workOrderAcceptedNotifi = Boolean.parseBoolean(rs.getString(37));
			boolean workOrderRejectedNotifi = Boolean.parseBoolean(rs.getString(38));
			String groupID = rs.getString(39);
			String action = rs.getString(40);

			userId = getUserId(conn,userN,storeNum);
			if(userId > 0){

				PreparedStatement pstmt = conn.prepareStatement(updateUserAddress);
				log.info("111111111111111111111111111 Update ADDRESSS");
				//Update Address
				//pstmt = conn.prepareStatement(updateUserAddress);
				pstmt.setString(1,firstName);
				pstmt.setString(2,lastName);
				pstmt.setString(3,address1);
				pstmt.setString(4,address2);
				pstmt.setString(5,city);
				pstmt.setString(6,state);
				pstmt.setString(7,country);
				pstmt.setString(8,postalCode);
				pstmt.setString(9,userloader);
				pstmt.setInt(10,userId);
				pstmt.executeUpdate();
				pstmt.close();

				//Update Email
				log.info("22222222222222 Update EMAILL");
				pstmt = conn.prepareStatement(updateUserEmail);
				pstmt.setString(1, email);
				pstmt.setString(2, userloader);
				pstmt.setInt(3, userId);
				pstmt.executeUpdate();
				pstmt.close();
				//update Phone
				log.info("333333333333333333333 Update PHONEEE");
				pstmt = conn.prepareStatement(updateUserPhone);

				//update phone number
				pstmt.setString(1,phone);
				pstmt.setString(2,userloader);
				pstmt.setInt(3,userId);
				pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.PHONE);
				pstmt.addBatch();

				//update fax
				pstmt.setString(1,fax);
				pstmt.setString(2,userloader);
				pstmt.setInt(3,userId);
				pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.FAX);
				pstmt.addBatch();

				//update mobile
				pstmt.setString(1,mobile);
				pstmt.setString(2,userloader);
				pstmt.setInt(3,userId);
				pstmt.setString(4,RefCodeNames.PHONE_TYPE_CD.MOBILE);
				pstmt.addBatch();

				pstmt.executeBatch();
				pstmt.close();

				//update User Property
				log.info("444444444444444444444 Update PROPERTY");
				pstmt = conn.prepareStatement(updateUserProperty);



				//update corporate user property
				pstmt.setString(1,corporateUser);
				pstmt.setString(2,userloader);
				pstmt.setInt(3,userId);
				pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.CORPORATE_USER);
				pstmt.addBatch();


				pstmt.setString(1,receiveInventoryMisEmail);
				pstmt.setString(2,userloader);
				pstmt.setInt(3,userId);
				pstmt.setString(4,RefCodeNames.PROPERTY_TYPE_CD.RECEIVE_INV_MISSING_EMAIL);
				pstmt.addBatch();

				pstmt.executeBatch();
				pstmt.close();

				//Update USER INFO
	/*			log.info("555555555555555555 Update USER");

                String userWorkflowRole = "";
				if(approver){
					userWorkflowRole = RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER;
					log.info("222222 UPdate CAN APROVE ORDERSSSSS BOOLEAN VALUE = ORDER_APPROVER" );
				}else{
					userWorkflowRole = RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN;
					log.info("222 Update CAN APROVE ORDERSSSSS BOOLEAN VALUE == UNKNOWN" );
				}

				pstmt = conn.prepareStatement(updateUsers);
				pstmt.setString(1,firstName);
				pstmt.setString(2,lastName);
				pstmt.setString(4,preferredLanguage);
				pstmt.setString(5,userWorkflowRole); */



				log.info("555555555555555555 Update USER");
				UserData userData = UserData.createValue();
				/*userData.setUserId(userId);
				userData.setFirstName(firstName);
				userData.setUserName(username);
				userData.setLastName(lastName);
				userData.setPrefLocaleCd(preferredLanguage);
				userData.setUserStatusCd(RefCodeNames.USER_STATUS_CD.ACTIVE);
				userData.setUserTypeCd(RefCodeNames.USER_TYPE_CD.MSB);
				userData.setEffDate(runDate);
				userData.setModBy(userloader);
				userData.setAddDate(runDate);
				userData.setAddBy(userloader);
				userData.setModDate(runDate);

				if(updatePassword){
					userData.setPassword(PasswordUtil.getHash(username,password));
				}*/
				String workflowRoleCd = "";
				if(approver){
					//userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.ORDER_APPROVER);
					workflowRoleCd = "ORDER APPROVER";
					log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE = ORDER_APPROVER" );
				}else{
					//userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN);
					workflowRoleCd = "UNKNOWN";
					log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE == UNKNOWN" );
				}

				UserRightsTool userRightstool = new UserRightsTool(userData);
				log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE ==== " + approver);
				userRightstool.setCanApprovePurchases(approver);
				//log.info("111111111111111111111111111 CAN APROVE ORDERSSSSS BOOLEAN VALUE = " + userRightstool.getCanApprovePurchases());
				userRightstool.setEmailForApproval(needsApproval);
				userRightstool.setEmailOrderApproved(wasApproved);
				userRightstool.setEmailOrderRejection(wasRejected);
				userRightstool.setEmailOrderModifications(wasModified);
				userRightstool.setOnAccount(onAccount);
				userRightstool.setCreditCardFlag(creditCard);
				userRightstool.setOtherPaymentFlag(otherPayment);
				userRightstool.setPoNumRequired(poNumRequired);
				userRightstool.setShowPrice(showPrice);
				userRightstool.setUserOnContract(contractItemsOnly);
				userRightstool.setBrowseOnly(browseOnly);
				userRightstool.setNoReporting(noReporting);
				userRightstool.setNoReporting(false);
				userRightstool.setEmailOrderDetailNotification(orderDetailNotification);
				userRightstool.setOrderNotificationShipped(shippingNotification);
				userRightstool.setWorkOrderCompletedNotification(workOrderCompletedNotifi);
				userRightstool.setWorkOrderAcceptedByProviderNotification(workOrderAcceptedNotifi);
				userRightstool.setWorkOrderRejectedByProviderNotification(workOrderRejectedNotifi);

                String userRights = userRightstool.makePermissionsToken();
               // userData.setUserRoleCd(userRights);
                //userData.setWorkflowRoleCd(RefCodeNames.WORKFLOW_ROLE_CD.UNKNOWN);
               // UserDataAccess.update(conn, userData);


				pstmt = conn.prepareStatement(UpdateUserInfo);
				pstmt.setString(1,firstName);
				pstmt.setString(2,lastName);
				pstmt.setString(3,userRights);
				pstmt.setString(4,preferredLanguage);
				pstmt.setString(5,workflowRoleCd);
				pstmt.setString(6,userloader);
				pstmt.setInt(7,userId);
				pstmt.executeUpdate();
				pstmt.close();


				if(updatePassword){
                	UserData userD = UserDataAccess.select(conn, userId);
                	String updatePasswordCd = PasswordUtil.getHash(username,password);
                	
                	if (!Utility.isEqual(userD.getPassword(), updatePasswordCd)){
                		pstmt = conn.prepareStatement(updateUserPassword);
	                	pstmt.setString(1,updatePasswordCd);
	                	pstmt.setString(2,userloader);
	                	pstmt.setInt(3, userId);
	                	pstmt.executeUpdate();
	    				pstmt.close();
	    				userD.setPassword(updatePasswordCd);
	    				usrBean.createPasswordHistoryIfChanged(conn, userD, false, false);
                	}
				}

                //Check And Add Group Assoc
                if(Utility.isSet(groupID) && !groupID.equals("0")){
	    			String sp[] = groupID.split(",");
	    			PreparedStatement pstmt9 = conn.prepareStatement(insertGroup);
	    			//pstmt = conn.prepareStatement(insertGroup);
	    			for(String s:sp) {
	    				s = s.trim();
	    			   log.info("1111 GroupIDDDDDDDDDDDDDDDDD = " + s);
	    			   int groupId = Integer.parseInt(s);
	    			   int groupAssocId = checkUserGroupAssoc(conn,groupId,userId);

	    			   if(groupAssocId == 0){

	    				   pstmt9.setString(1,userloader);
	    	               pstmt9.setString(2,userloader);
	    	               pstmt9.setInt(3,userId);
	    				   pstmt9.setInt(4, groupId);
	    				   pstmt9.addBatch();
	    			   }

	    			}
	    			pstmt9.executeBatch();
	                pstmt9.close();
                }else{
                	//String deleteUserGroups = "delete from clw_group_assoc where user_id = ? and addby = ?";
                	//pstmt.setInt(1,userId);
                	//pstmt.setString(1,userloader);
                	//XXX Groups are additive only right now!!!
                }


    			if(userId > 0){

    				createUserAssociations(userId, userN,storeNum,userloader,conn);

    			}

			}else{
				log.info("Error User Doest Not Exists username = " + userN);
			}

		}
		pstmt8.close();
	}catch(Exception e){
		e.printStackTrace();
		//throw e;
		   throw new RemoteException(
                   "Error.IntegrationServicesBean.updateUser()=> "
                           + e.getMessage());
	}

}

	public int checkUserGroupAssoc(Connection conn,int groupId,int userId) throws RemoteException{
		log.info("Check User Group Assoc start");
		String selectGroup = "select count(*) from clw_group_assoc where group_id = ? and user_id = ?";

		int groupAssocID = 0;
		try{
			PreparedStatement pstmt = conn.prepareStatement(selectGroup);
			pstmt.setInt(1,groupId);
			pstmt.setInt(2,userId);
			ResultSet rs = pstmt.executeQuery();

			while(rs.next()){
				groupAssocID = rs.getInt(1);
			}
			pstmt.close();
		}catch(Exception e){
			e.printStackTrace();
			//throw e;
			   throw new RemoteException(
	                   "Error.IntegrationServicesBean.checkUserGroupAssoc()=> "
	                           + e.getMessage());
		}
			return groupAssocID;


	}

	public int getUserId(Connection conn,String userName,int storeNum) throws RemoteException{

    	String selectUserId = "select cu.user_id from clw_user cu,clw_user_assoc cua where cu.user_name = ? " +
		"and cu.user_id = cua.user_id and cua.bus_entity_id = ?";

    	int userId = 0;
    	try{

        	PreparedStatement pstmt = conn.prepareStatement(selectUserId);
        	pstmt.setString(1,userName);
        	pstmt.setInt(2, storeNum);
        	ResultSet rs = pstmt.executeQuery();

        	while(rs.next()){
        		userId = rs.getInt(1);
        	}
        	pstmt.close();
    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getUserId()=> "
                               + e.getMessage());
    	}

    	return userId;
	}

	public int getAccountId(Connection conn,String accountRefNum,int storeNum) throws RemoteException{
		String selectAccountId = "select bus_entity_id from clw_bus_entity where bus_entity_id in " +
				"(select bus_entity_id from clw_property where short_Desc = ? and " +
				"clw_value = ? and bus_entity_id in(select bus_entity1_id from " +
				"clw_bus_entity_assoc where bus_entity2_id = ?)) and bus_entity_type_cd = ?";

		int accountId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectAccountId);
			pstmt.setString(1, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setString(2,accountRefNum);
			pstmt.setInt(3,storeNum);
			pstmt.setString(4,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			ResultSet rs = pstmt.executeQuery();

			while(rs.next()){
				accountId = rs.getInt(1);
			}

			pstmt.close();
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getAccountId()=> "
                               + e.getMessage());
    	}


		return accountId;

	}
	
	public int getSiteIdByPropertyName(String pName,
			String val, List parentIds, boolean parentIsAccount) throws RemoteException{
		
		DBCriteria dbc = new DBCriteria();
		dbc.addEqualTo(PropertyDataAccess.SHORT_DESC, pName);
		dbc.addEqualTo(PropertyDataAccess.CLW_VALUE, val);
		
		if (parentIds != null){
			if (parentIsAccount){
				DBCriteria dbc1 = new DBCriteria();
				dbc1.addEqualTo(BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD, RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT);
				dbc1.addOneOf(BusEntityAssocDataAccess.BUS_ENTITY2_ID, parentIds);
				dbc.addOneOf(PropertyDataAccess.BUS_ENTITY_ID, BusEntityAssocDataAccess.getSqlSelectIdOnly(BusEntityAssocDataAccess.BUS_ENTITY1_ID, dbc1));
				
			}else {// store
				DBCriteria dbc1 = new DBCriteria();
				dbc1.addEqualTo(BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD, RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE);
				dbc1.addOneOf(BusEntityAssocDataAccess.BUS_ENTITY2_ID, parentIds);
				String selAccountIds = BusEntityAssocDataAccess.getSqlSelectIdOnly(BusEntityAssocDataAccess.BUS_ENTITY1_ID, dbc1);
	
				dbc1 = new DBCriteria();
				dbc1.addEqualTo(BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD, RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT);
				dbc1.addOneOf(BusEntityAssocDataAccess.BUS_ENTITY2_ID, selAccountIds);
				dbc.addOneOf(PropertyDataAccess.BUS_ENTITY_ID, BusEntityAssocDataAccess.getSqlSelectIdOnly(BusEntityAssocDataAccess.BUS_ENTITY1_ID, dbc1));			
			}
		}
		String selectId = PropertyDataAccess.getSqlSelectIdOnly(PropertyDataAccess.BUS_ENTITY_ID, dbc);
		Connection conn = null;
		try{
			conn = getConnection();
			PropertyDataVector propertyDV = PropertyDataAccess.select(conn, dbc);
			if (propertyDV.size() > 1) {
				String errorMsg = "More than one property record found for name: " 
            		+ pName + ", value: " + val;
				if (parentIds != null){
					if (parentIsAccount){
						errorMsg += " with in account ids: " + parentIds;
					}else{
						errorMsg += " with in store ids: " + parentIds;
					}
				}
	            throw new RemoteException(errorMsg);
	        }else if (propertyDV.size() == 1) {
	        	return ((PropertyData)propertyDV.get(0)).getBusEntityId();
	        }else{
	        	return 0;
	        }	        	
		}catch(Exception e){
			e.printStackTrace();
			throw new RemoteException(
                   "Error.IntegrationServicesBean.getBusEntityIdByPropertyName()=> "
                           + e.getMessage());
		}finally{
			closeConnection(conn);
		}
	}

	public int getBusEntityIdByProperty(String propertyTypeCd, String val) throws RemoteException{
		String selectId = "select bus_entity_id from clw_property "+
			"where property_type_cd =? " +
			" and clw_value =?";
		Connection conn = null;
		int bId = 0;
		try{
			conn = getConnection();

			PreparedStatement pstmt = conn.prepareStatement(selectId);
			pstmt.setString(1,propertyTypeCd);
			pstmt.setString(2,val);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				bId = rs.getInt(1);
			}
			pstmt.close();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getBusEntityIdByProperty()=> "
                               + e.getMessage());
    	}finally{
    		closeConnection(conn);
    	}

		return bId;
	}

	public int getSiteId(Connection conn,String siteRefNum,String accRefNum,int storeNum) throws RemoteException{

		String selectSiteId = "select bus_entity_id from clw_bus_entity where bus_entity_type_cd  = ? " +
				"and bus_entity_id in(select bus_entity_id from clw_property where bus_entity_id in" +
				"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id in" +
				"(select bus_entity_id from clw_bus_entity where bus_entity_id in" +
				"(select bus_entity_id from clw_property where short_Desc = ? " +
				"and clw_value = ? and bus_entity_id in(select bus_entity1_id " +
				"from clw_bus_entity_assoc where bus_entity2_id = ?)) and bus_entity_type_cd = ?)) " +
				"and short_desc  = ? and clw_value = ?)";

				int siteId = 0;


				try{
					PreparedStatement pstmt = conn.prepareStatement(selectSiteId);
					pstmt.setString(1,RefCodeNames.BUS_ENTITY_TYPE_CD.SITE);
					pstmt.setString(2,RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
					pstmt.setString(3,accRefNum);
					pstmt.setInt(4,storeNum);
					pstmt.setString(5,RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
					pstmt.setString(6,RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER);
					pstmt.setString(7,siteRefNum);
					ResultSet rs = pstmt.executeQuery();
					while(rs.next()){
						siteId = rs.getInt(1);
					}
					pstmt.close();

				}catch(Exception e){
		    		e.printStackTrace();
		    		//throw e;
		    		   throw new RemoteException(
		                       "Error.IntegrationServicesBean.getSiteId()=> "
		                               + e.getMessage());
		    	}

				return siteId;

	}


	public void checkAndCreateUserAccountAssoc(Connection conn,int userId, int accountID,String userloader) throws RemoteException{

		String checkUserAssoc = "select count(*) from clw_user_assoc " +
				"where bus_entity_id = ? and user_id = ?";

		String inserUserAssoc = "insert into clw_user_assoc(user_assoc_id,user_id,bus_entity_id," +
				"user_assoc_cd,add_date,add_by,mod_date,mod_by) " +
				"values(clw_user_assoc_seq.nextval,?,?,?,sysdate,?,sysdate,?)";

		int count = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(checkUserAssoc);
			pstmt.setInt(1,accountID);
			pstmt.setInt(2,userId);
			ResultSet rs = pstmt.executeQuery();

			while(rs.next()){
				count = rs.getInt(1);
			}

			pstmt.close();

			if(count == 0){
				pstmt = conn.prepareStatement(inserUserAssoc);
				pstmt.setInt(1, userId);
				pstmt.setInt(2, accountID);
				pstmt.setString(3,RefCodeNames.USER_ASSOC_CD.ACCOUNT);
				pstmt.setString(4,userloader);
				pstmt.setString(5,userloader);
				pstmt.executeUpdate();
				pstmt.close();

			}



		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndCreateUserAccountAssoc()=> "
                               + e.getMessage());
    	}
	}




	public void checkAndRemoveCreateUserBusEntAssoc(Connection conn,int userId,int busEntID) throws RemoteException{
		String removeAssoc = "delete from clw_user_assoc where bus_entity_id = ? and user_id = ?";

		int count = 0;
		try{
			PreparedStatement pstmt = conn.prepareStatement(removeAssoc);
			pstmt.setInt(1,busEntID);
			pstmt.setInt(2,userId);
			count = pstmt.executeUpdate();
			pstmt.close();

			if(count > 1){
				throw new RemoteException("Unexpectedly deleted more than 1 row when removing association between site and user!\n"+removeAssoc+"\n param1=siteID param2=userId");

			}
		}catch(Exception e){
    		throw processException(e);
    	}
}

	public void checkAndCreateUserSiteAssoc(Connection conn,int userId,int siteID,int accountID,String userloader) throws RemoteException{
		log.info("checkAndCreateUserSiteAssoc for  siteID="+ siteID+" userId="+userId);
			String checkUserAssoc = "select count(*) from clw_user_assoc " +
			"where bus_entity_id = ? and user_id = ?";

			String inserUserAssoc = "insert into clw_user_assoc(user_assoc_id,user_id,bus_entity_id," +
			"user_assoc_cd,add_date,add_by,mod_date,mod_by) " +
			"values(clw_user_assoc_seq.nextval,?,?,?,sysdate,?,sysdate,?)";

			int count = 0;

			try{
				PreparedStatement pstmt = conn.prepareStatement(checkUserAssoc);
				pstmt.setInt(1,siteID);
				pstmt.setInt(2,userId);
				ResultSet rs = pstmt.executeQuery();

				while(rs.next()){
					count = rs.getInt(1);
				}
				pstmt.close();

				if(count == 0){
					pstmt = conn.prepareStatement(inserUserAssoc);
					pstmt.setInt(1, userId);
					pstmt.setInt(2, siteID);
					pstmt.setString(3,RefCodeNames.USER_ASSOC_CD.SITE);
					pstmt.setString(4,userloader);
					pstmt.setString(5,userloader);
					pstmt.executeUpdate();
					pstmt.close();

				}
				//pstmt.close();
			}catch(Exception e){
	    		e.printStackTrace();
	    		//throw e;
	    		   throw new RemoteException(
	                       "Error.IntegrationServicesBean.checkAndCreateUserSiteAssoc()=> "
	                               + e.getMessage());
	    	}
	}


	public void processOrderGuide(Connection conn, String orderguideloader,int storeNum) throws RemoteException{
		log.info("Start processOrderGuide");

    	String selectNullVersion = "select SITE_REF_NUM,ORDER_GUIDE_NAME,DIST_SKU from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where add_by = ? and (VERSION_NUMBER is null or STORE_ID is null)";

    	String selectNullOrderGuideName = "select SITE_REF_NUM,CATALOG_ID,DIST_SKU from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where add_by = ? and (order_guide_name is null or order_guide_type is null)";

    	String selectNullDistSku = "select SITE_REF_NUM,CATALOG_ID,ORDER_GUIDE_NAME from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where add_by = ? and dist_sku is null";

		String selectConditionalNull = "select CATALOG_ID,ORDER_GUIDE_NAME,DIST_SKU from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where add_by = ? and site_ref_num is null " +
		"and order_guide_type = 'SITE'";

		String selectCatalogOrder = "select SITE_REF_NUM,ORDER_GUIDE_NAME,DIST_SKU from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where add_by = ? and catalog_id is null " +
		"and order_guide_type = 'CATALOG'";

		String selectDistinctOrderGuide = "select distinct order_guide_name,account_ref_num,site_ref_num,catalog_id, " +
				"order_guide_type from CLT_POLLARD_ORDER_GUIDE_LOADER " +
				"where add_by = ? ";

		String selectAllOrderGuides = "select order_guide_id from clw_order_guide where bus_entity_id in " +
		"	(select bus_entity_id from (select bus_entity_id,count(*) from " +
		"	clw_order_guide where bus_entity_id in(select bus_entity_id from clw_bus_entity where " +
		"bus_entity_type_cd = 'SITE' and bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?)))  " +
		"	and order_guide_type_cd = 'SITE_ORDER_GUIDE_TEMPLATE' group by bus_entity_id )) " +
		"and order_guide_type_cd = 'SITE_ORDER_GUIDE_TEMPLATE' and add_by = ?";

		String selectItemId = "select ci.item_id,cim.item_num " +
		"from clw_item ci,clw_item_mapping cim,clw_bus_entity dist,clw_bus_entity_assoc cbea " +
		"where ci.item_id = cim.item_id and cim.bus_entity_id = dist.bus_entity_id " +
		"and dist.bus_entity_id = cbea.bus_entity1_id and cbea.bus_entity2_id = ? " +
		"and dist.bus_entity_type_cd = 'DISTRIBUTOR' and ci.item_status_cd = 'ACTIVE' " +
		"and cim.item_num not in " +
		"(select item_num from " +
		"(select item_num,count(*) from clw_item_mapping where bus_entity_id in " +
		"(select bus_entity_id from clw_bus_entity where bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
		"and bus_entity_type_cd = 'DISTRIBUTOR' and bus_entity_status_cd = 'ACTIVE') " +
		"group by item_num having count(*) >1))";

		HashMap itemIdHashMap = new HashMap();

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectNullVersion);
			pstmt.setString(1, orderguideloader);
			ResultSet rs = pstmt.executeQuery();
			boolean foundMissingVersionNum=false;
			StringBuffer missingVersionNum = new StringBuffer();
			while(rs.next()){
				foundMissingVersionNum = true;
				missingVersionNum.append(rs.getString(1));
				missingVersionNum.append(":");
				missingVersionNum.append(rs.getString(2));
				missingVersionNum.append(":");
				missingVersionNum.append(rs.getString(3));
				missingVersionNum.append("*****");
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (foundMissingVersionNum ) {
				throw new IllegalArgumentException("Found Missing Version number or Store ID for SITE_REF_NUM:ORDER_GUIDE_NAME:DIST_SKU ==" + missingVersionNum);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}
			pstmt.close();




			pstmt = conn.prepareStatement(selectNullOrderGuideName);
			pstmt.setString(1, orderguideloader);
			rs = pstmt.executeQuery();
			boolean foundMissingOgName=false;
			StringBuffer missingOgName = new StringBuffer();
			while(rs.next()){
				foundMissingOgName = true;
				missingOgName.append(rs.getString(1));
				missingOgName.append(":");
				missingOgName.append(rs.getString(2));
				missingOgName.append(":");
				missingOgName.append(rs.getString(3));
				missingOgName.append("*****");
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (foundMissingOgName) {
				throw new IllegalArgumentException("CHECK 2 order Guide name is null or order guide type is null SITE_REF_NUM:CATALOG_ID:DIST_SKU =" + missingOgName);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectNullDistSku);
			pstmt.setString(1, orderguideloader);
			rs = pstmt.executeQuery();
			boolean foundMissingDistSku=false;
			StringBuffer missingDistSku = new StringBuffer();
			while(rs.next()){
				foundMissingDistSku = true;
				missingDistSku.append(rs.getString(1));
				missingDistSku.append(":");
				missingDistSku.append(rs.getString(2));
				missingDistSku.append(":");
				missingDistSku.append(rs.getString(3));
				missingDistSku.append("*****");
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (foundMissingDistSku ) {
				throw new IllegalArgumentException("CHECK 2 DIST_SKU is null SITE_REF_NUM:CATALOG_ID:ORDER_GUIDE_NAME =" + missingDistSku);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}
			pstmt.close();




			pstmt = conn.prepareStatement(selectConditionalNull);
			pstmt.setString(1, orderguideloader);
			rs = pstmt.executeQuery();
			boolean foundMissingSiteRefNum=false;
			StringBuffer missingSiteRefNum = new StringBuffer();
			while(rs.next()){
				foundMissingSiteRefNum = true;
				missingSiteRefNum.append(rs.getString(1));
				missingSiteRefNum.append(":");
				missingSiteRefNum.append(rs.getString(2));
				missingSiteRefNum.append(":");
				missingSiteRefNum.append(rs.getString(3));
				missingSiteRefNum.append("*****");
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (foundMissingSiteRefNum ) {
				throw new IllegalArgumentException("CHECK 2 site reference number is null where order guide type cd is SITE catalog_key:order_guide_name:dist_sku =" + missingSiteRefNum);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = ");
			}
			pstmt.close();



			pstmt = conn.prepareStatement(selectCatalogOrder);
			pstmt.setString(1, orderguideloader);
			rs = pstmt.executeQuery();
			boolean foundMissingCatalogKey=false;
			StringBuffer missingCatalogKey = new StringBuffer();

			while(rs.next()){
				foundMissingCatalogKey = true;
				missingCatalogKey.append(rs.getString(1));
				missingCatalogKey.append(":");
				missingCatalogKey.append(rs.getString(2));
				missingCatalogKey.append(":");
				missingCatalogKey.append(rs.getString(3));
				missingCatalogKey.append("*****");
			}

			if (foundMissingCatalogKey ) {
				throw new IllegalArgumentException("CHECK 3 Catalog Id is null where order guide type cd is Catalog SITE_REF_NUM:ORDER_GUIDE_NAME:DIST_SKU =" + missingCatalogKey);
				//log.info("Could not find accounts using store id: "+storeNum+" and Dist reference number: "+missingAccounts);
			} else{
				log.info("CHECK 33333333333333333 Success Counttttt is zero continue = ");
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectItemId);
			pstmt.setInt(1,storeNum);
			pstmt.setInt(2,storeNum);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int itemID1 = rs.getInt(1);
				String itemNum1 = rs.getString(2);
				if(  itemIdHashMap.containsKey(itemNum1)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemIdHashMap.put(itemNum1,itemID1);
		    	}
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectDistinctOrderGuide);
			pstmt.setString(1, orderguideloader);
			rs = pstmt.executeQuery();
			//String orderGuideName = "";
			//String catalogId = "";
			//String siteReferenceNum = "";
			PollockOrderGuideView pollockOrderGuideView = PollockOrderGuideView.createValue();

			HashSet<Integer> orderGuidesLoaded = new HashSet();
			while(rs.next()){
				pollockOrderGuideView.setorderGuideName(rs.getString(1));
				pollockOrderGuideView.setaccountRefNum(rs.getString(2));
				pollockOrderGuideView.setsiteRefNum(rs.getString(3));
				pollockOrderGuideView.setcatalogId(rs.getString(4));
				pollockOrderGuideView.setorderGuideType(rs.getString(5));
				//int ogid = createOrderGuide(conn,pollockOrderGuideView,orderguideloader,storeNum);
				int ogid = createOrderGuideN(conn,pollockOrderGuideView,orderguideloader,storeNum,itemIdHashMap);
				orderGuidesLoaded.add(ogid);
			}

			rs.close();
			pstmt.close();

			log.info("selectOrderGuidesWeLoaded: "+selectAllOrderGuides);
			pstmt = conn.prepareStatement(selectAllOrderGuides);
			pstmt.setInt(1, storeNum);
			pstmt.setString(2, orderguideloader);
			rs = pstmt.executeQuery();

			List<Integer> orderGuidesToDelete = new ArrayList();
			while(rs.next()){
				Integer ogid = rs.getInt(1);
				if(!orderGuidesLoaded.contains(ogid) && !orderGuidesToDelete.contains(ogid)){
					orderGuidesToDelete.add(ogid);
				}
			}
			rs.close();
			pstmt.close();

			//remove order guides that have schedules associated with them.
			DBCriteria crit = new DBCriteria();
			crit.addOneOf(OrderScheduleDataAccess.ORDER_GUIDE_ID, orderGuidesToDelete);
			IdVector ogsWithSchedules = OrderScheduleDataAccess.selectIdOnly(conn,OrderScheduleDataAccess.ORDER_GUIDE_ID, crit);
			Iterator<Integer> it = orderGuidesToDelete.iterator();
			while(it.hasNext()){
				int ogid = it.next();
				if(ogsWithSchedules.contains(ogid)){
					it.remove();
				}
			}

			if(orderGuidesToDelete.size() > 1000){
                            throw new RemoteException("Panic loader wants to delete more than 1000 order guides!  Maybe small file trying to be loaded?");
                        }
			it = orderGuidesToDelete.iterator();
			while(it.hasNext()){
				int ogid = it.next();
				log.info("Deleteing order guide: "+ogid);
				deleteOrderGuideStructure(conn, ogid);
				OrderGuideDataAccess.remove(conn, ogid);
			}




		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}

	}



	public int createOrderGuideN(Connection conn,PollockOrderGuideView pollockOrderGuideView,String orderguideloader,int storeNum,HashMap itemIdHashMap) throws RemoteException{

		String selectOrderGuide = "select distinct dist_sku from CLT_POLLARD_ORDER_GUIDE_LOADER " +
				"where order_guide_name = ? " +
				"and account_ref_num = ?";

		String insertOrderGuideStructure = "insert into clw_order_guide_structure" +
				"(order_guide_structure_id,order_guide_id,item_id,category_item_id,quantity," +
				"add_Date,add_by,mod_date) " +
				"values(clw_order_guide_structure_seq.nextval,?,?,0,0,sysdate,?,sysdate)";

		String selectCatalog = "select catalog_id from clw_catalog where catalog_id in " +
				"(select catalog_id from clw_catalog_assoc where bus_entity_id in( " +
				"select bus_entity_id from clw_bus_entity_assoc where bus_entity2_id in " +
				"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))) " +
				"and loader_field = ?";

		String accountRefNum = "";
		String siteRefNum = "";
		String catalogId = "";
		String orderGuideName = "";
		String orderGuideType = "";
		String distSku = "";
		int siteId = 0;
		int orderGuideId = 0;

		int siteCatalogId = 0;

		try{
			orderGuideName = pollockOrderGuideView.getorderGuideName();
			accountRefNum = pollockOrderGuideView.getaccountRefNum();
			siteRefNum = pollockOrderGuideView.getsiteRefNum();
			catalogId = pollockOrderGuideView.getcatalogId();
			orderGuideType = pollockOrderGuideView.getorderGuideType();
			orderGuideType = orderGuideType.toUpperCase();
			int itemId = 0;

			/*if(catalogId != null){
	    	PreparedStatement pstmt = conn.prepareStatement(selectCatalog);
	    	pstmt.setInt(1, storeNum);
	    	pstmt.setString(2, catalogId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
			siteCatalogId = rs.getInt(1);
			}
			}*/

			if(siteRefNum != null){
				siteId = getSiteId(conn,siteRefNum,accountRefNum,storeNum);
			}
			if(catalogId == null){
				if(siteId == 0){
					throw new IllegalArgumentException("Both Site Ref num and catalog id are null");
				}
				else{
					siteCatalogId = getSiteCatalogId(conn,siteId);

				}
			}else{
				PreparedStatement pstmt = conn.prepareStatement(selectCatalog);
		    	pstmt.setInt(1, storeNum);
		    	pstmt.setString(2, catalogId);
				ResultSet rs = pstmt.executeQuery();
				while(rs.next()){
				siteCatalogId = rs.getInt(1);
				}
				pstmt.close();
			//	siteCatalogId = Integer.parseInt(catalogId);
			}

			orderGuideId = checkIfOrderGuideExists(conn,siteCatalogId,orderGuideName,orderGuideType,siteId);
			if(orderGuideId > 0){
				//throw new IllegalArgumentException("order Guide already exists order guide name = " + orderGuideName + "catalogId = " + catalogId);
				updateTemplateOrderGuideDate(conn,orderGuideId,orderguideloader);
				deleteOrderGuideStructure(conn,orderGuideId);
				//createOrderGuideStructure(conn,orderGuideId,pollockOrderGuideView,orderguideloader,storeNum);
				createOrderGuideStructureN(conn,orderGuideId,pollockOrderGuideView,orderguideloader,storeNum,itemIdHashMap);
				log.info("order Guide already exists order guide name = " + orderGuideName + "catalogId = " + catalogId);
			}else{

			//int count = 0;

			//	accountRefNum = rs.getString(1);
			//	siteRefNum = rs.getString(2);
			//	catalogId = rs.getString(3);
			//	orderGuideName = rs.getString(4);
			//	orderGuideType = rs.getString(5);
			//	distSku = rs.getString(6);
				log.info("Create Order Guide order_guide_name = " + orderGuideName + "catalogId = " + catalogId);

				log.info("Order 111 Guide Type is order_guide_type_cd = " + orderGuideType);

				OrderGuideData orderGuideData = OrderGuideData.createValue();
				orderGuideData.setShortDesc(orderGuideName);

				if(siteId > 0){
					orderGuideData.setBusEntityId(siteId);
				}

				if(siteCatalogId > 0){
					orderGuideData.setCatalogId(siteCatalogId);
				}
				if(orderGuideType.equals("SITE")){
					log.info("Order 222 Guide Type is order_guide_type_cd = " + orderGuideType);
					if(siteId == 0){
						throw new IllegalArgumentException("Site not found for order guide type SITE_ORDER_GUIDE_TEMPLATE site_ref_num=" + siteRefNum + "account_ref_num=" + accountRefNum + "store_num=" + storeNum );
					}
				//orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.BUYER_ORDER_GUIDE);
					orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE);
				}

				if(orderGuideType.equals("CATALOG")){
					log.info("Order 333 Guide Type is order_guide_type_cd = " + orderGuideType);
					//orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE);
					orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
					}

				orderGuideData.setAddBy(orderguideloader);
				orderGuideData.setModBy(orderguideloader);

				orderGuideData = OrderGuideDataAccess.insert(conn, orderGuideData);
				orderGuideId = orderGuideData.getOrderGuideId();

			/*	log.info("get Item Id distSku = " + distSku);
				itemId = getItemId(conn,distSku,storeNum);
				if(itemId > 0){
				OrderGuideStructureData orderGuideStructureData = OrderGuideStructureData.createValue();
				orderGuideStructureData.setOrderGuideId(orderGuideId);
				orderGuideStructureData.setItemId(itemId);
				orderGuideStructureData.setCategoryItemId(0);
				orderGuideStructureData.setAddBy(orderguideloader);
				orderGuideStructureData.setModBy(orderguideloader);
				}else{
					log.info("Error Item Not found distsku = " + distSku);
				}*/
				if(catalogId == null){
					selectOrderGuide = selectOrderGuide + " and site_ref_num = '" + siteRefNum + "'" ;
				}else{
					selectOrderGuide = selectOrderGuide + " and catalog_id = '" + catalogId + "'";
				}

				log.info("Add Items to order Guide Structure sql= " + selectOrderGuide);

				PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
				pstmt.setString(1, orderGuideName);
				pstmt.setString(2, accountRefNum);
				ResultSet rs = pstmt.executeQuery();

				PreparedStatement pstmt1 = conn.prepareStatement(insertOrderGuideStructure);
				pstmt1.setInt(1,orderGuideId);
				pstmt1.setString(3,orderguideloader);

				while(rs.next()){
					distSku = rs.getString(1);
					log.info("Add Items to order Guide Structure dist_sku ===  " + distSku);
					if(itemIdHashMap.containsKey(distSku)){
						itemId = (Integer)  itemIdHashMap.get(distSku);
						pstmt1.setInt(2,itemId);
						pstmt1.addBatch();
					}else{
						//itemId = getItemId(conn, distSku,distributor,uom,storeNum );
						IdVector itemIds = getAllItemIds(conn,distSku,"",storeNum);
						log.info("Add Items to order Guide Structure ItemID count ===  " + itemIds.size());
						Iterator it = itemIds.iterator();
						while(it.hasNext()){
							itemId = (Integer) it.next();
							pstmt1.setInt(2,itemId);
							pstmt1.addBatch();
						}
					}
				//	IdVector itemIds = getAllItemIds(conn,distSku,"",storeNum);
				//	log.info("Add Items to order Guide Structure ItemID count ===  " + itemIds.size());
				//	Iterator it = itemIds.iterator();
				//	while(it.hasNext()){
				//		Integer itemId = (Integer) it.next();

					//}
				}
				pstmt1.executeBatch();
				pstmt1.close();

				pstmt.close();
			}


			return orderGuideId;
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createOrderGuideN()=> "
                               + e.getMessage());
    	}


	}


	public void createOrderGuideStructureN(Connection conn,int orderGuideId,PollockOrderGuideView pollockOrderGuideView,String orderguideloader,int storeNum,HashMap itemIdHashMap) throws RemoteException{
		String selectOrderGuide = "select distinct dist_sku from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where order_guide_name = ? " +
		"and account_ref_num = ?";

		String insertOrderGuideStructure = "insert into clw_order_guide_structure" +
		"(order_guide_structure_id,order_guide_id,item_id,category_item_id,quantity," +
		"add_Date,add_by,mod_date) " +
		"values(clw_order_guide_structure_seq.nextval,?,?,0,0,sysdate,?,sysdate)";


		String accountRefNum = "";
		String siteRefNum = "";
		String catalogKey = "";
		String orderGuideName = "";
		String orderGuideType = "";
		String distSku = "";

		try{
			orderGuideName = pollockOrderGuideView.getorderGuideName();
			accountRefNum = pollockOrderGuideView.getaccountRefNum();
			siteRefNum = pollockOrderGuideView.getsiteRefNum();
			catalogKey = pollockOrderGuideView.getcatalogId();
			orderGuideType = pollockOrderGuideView.getorderGuideType();
			orderGuideType = orderGuideType.toUpperCase();
			int itemId = 0;

			if(siteRefNum != null){
				selectOrderGuide = selectOrderGuide + " and site_ref_num = '" + siteRefNum + "'" ;
			}else{
				selectOrderGuide = selectOrderGuide + " and catalog_id = '" + catalogKey + "'";
			}

		 	log.info("Add Items to order Guide Structure sql= " + selectOrderGuide);

			PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
			pstmt.setString(1, orderGuideName);
			pstmt.setString(2, accountRefNum);
			ResultSet rs = pstmt.executeQuery();

			PreparedStatement pstmt2 = conn.prepareStatement(insertOrderGuideStructure);
			pstmt2.setInt(1,orderGuideId);
			pstmt2.setString(3,orderguideloader);

			while(rs.next()){
				distSku = rs.getString(1);
				log.info("Add Items to order Guide Structure dist_sku ===  " + distSku);
				if(itemIdHashMap.containsKey(distSku)){
					itemId = (Integer)  itemIdHashMap.get(distSku);
					pstmt2.setInt(2,itemId);
					pstmt2.addBatch();
				}else{
					//itemId = getItemId(conn, distSku,distributor,uom,storeNum );
					IdVector itemIds = getAllItemIds(conn,distSku,"",storeNum);
					log.info("Add Items to order Guide Structure ItemID count ===  " + itemIds.size());
					Iterator it = itemIds.iterator();
					while(it.hasNext()){
						itemId = (Integer) it.next();
						pstmt2.setInt(2,itemId);
						pstmt2.addBatch();
					}
				}

			}
			pstmt2.executeBatch();
			pstmt2.close();

			pstmt.close();


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createOrderGuideStructure()=> "
                               + e.getMessage());
    	}


	}

	public int createOrderGuide(Connection conn,PollockOrderGuideView pollockOrderGuideView,String orderguideloader,int storeNum) throws RemoteException{

		String selectOrderGuide = "select distinct dist_sku from CLT_POLLARD_ORDER_GUIDE_LOADER " +
				"where order_guide_name = ? " +
				"and account_ref_num = ?";

		String insertOrderGuideStructure = "insert into clw_order_guide_structure" +
				"(order_guide_structure_id,order_guide_id,item_id,category_item_id,quantity," +
				"add_Date,add_by,mod_date) " +
				"values(clw_order_guide_structure_seq.nextval,?,?,0,0,sysdate,?,sysdate)";

		String selectCatalog = "select catalog_id from clw_catalog where catalog_id in " +
				"(select catalog_id from clw_catalog_assoc where bus_entity_id in( " +
				"select bus_entity_id from clw_bus_entity_assoc where bus_entity2_id in " +
				"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))) " +
				"and loader_field = ?";

		String accountRefNum = "";
		String siteRefNum = "";
		String catalogId = "";
		String orderGuideName = "";
		String orderGuideType = "";
		String distSku = "";
		int siteId = 0;
		int orderGuideId = 0;

		int siteCatalogId = 0;

		try{
			orderGuideName = pollockOrderGuideView.getorderGuideName();
			accountRefNum = pollockOrderGuideView.getaccountRefNum();
			siteRefNum = pollockOrderGuideView.getsiteRefNum();
			catalogId = pollockOrderGuideView.getcatalogId();
			orderGuideType = pollockOrderGuideView.getorderGuideType();
			orderGuideType = orderGuideType.toUpperCase();

			/*if(catalogId != null){
	    	PreparedStatement pstmt = conn.prepareStatement(selectCatalog);
	    	pstmt.setInt(1, storeNum);
	    	pstmt.setString(2, catalogId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
			siteCatalogId = rs.getInt(1);
			}
			}*/

			if(siteRefNum != null){
				siteId = getSiteId(conn,siteRefNum,accountRefNum,storeNum);
			}
			if(catalogId == null){
				if(siteId == 0){
					throw new IllegalArgumentException("Both Site Ref num and catalog id are null");
				}
				else{
					siteCatalogId = getSiteCatalogId(conn,siteId);

				}
			}else{
				PreparedStatement pstmt = conn.prepareStatement(selectCatalog);
		    	pstmt.setInt(1, storeNum);
		    	pstmt.setString(2, catalogId);
				ResultSet rs = pstmt.executeQuery();
				while(rs.next()){
				siteCatalogId = rs.getInt(1);
				}
				pstmt.close();
			//	siteCatalogId = Integer.parseInt(catalogId);
			}

			orderGuideId = checkIfOrderGuideExists(conn,siteCatalogId,orderGuideName,orderGuideType,siteId);
			if(orderGuideId > 0){
				//throw new IllegalArgumentException("order Guide already exists order guide name = " + orderGuideName + "catalogId = " + catalogId);
				updateTemplateOrderGuideDate(conn,orderGuideId,orderguideloader);
				deleteOrderGuideStructure(conn,orderGuideId);
				createOrderGuideStructure(conn,orderGuideId,pollockOrderGuideView,orderguideloader,storeNum);
				log.info("order Guide already exists order guide name = " + orderGuideName + "catalogId = " + catalogId);
			}else{

			//int count = 0;

			//	accountRefNum = rs.getString(1);
			//	siteRefNum = rs.getString(2);
			//	catalogId = rs.getString(3);
			//	orderGuideName = rs.getString(4);
			//	orderGuideType = rs.getString(5);
			//	distSku = rs.getString(6);
				log.info("Create Order Guide order_guide_name = " + orderGuideName + "catalogId = " + catalogId);

				log.info("Order 111 Guide Type is order_guide_type_cd = " + orderGuideType);

				OrderGuideData orderGuideData = OrderGuideData.createValue();
				orderGuideData.setShortDesc(orderGuideName);

				if(siteId > 0){
					orderGuideData.setBusEntityId(siteId);
				}

				if(siteCatalogId > 0){
					orderGuideData.setCatalogId(siteCatalogId);
				}
				if(orderGuideType.equals("SITE")){
					log.info("Order 222 Guide Type is order_guide_type_cd = " + orderGuideType);
					if(siteId == 0){
						throw new IllegalArgumentException("Site not found for order guide type SITE_ORDER_GUIDE_TEMPLATE site_ref_num=" + siteRefNum + "account_ref_num=" + accountRefNum + "store_num=" + storeNum );
					}
				//orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.BUYER_ORDER_GUIDE);
					orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE);
				}

				if(orderGuideType.equals("CATALOG")){
					log.info("Order 333 Guide Type is order_guide_type_cd = " + orderGuideType);
					//orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE);
					orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
					}

				orderGuideData.setAddBy(orderguideloader);
				orderGuideData.setModBy(orderguideloader);

				orderGuideData = OrderGuideDataAccess.insert(conn, orderGuideData);
				orderGuideId = orderGuideData.getOrderGuideId();

			/*	log.info("get Item Id distSku = " + distSku);
				itemId = getItemId(conn,distSku,storeNum);
				if(itemId > 0){
				OrderGuideStructureData orderGuideStructureData = OrderGuideStructureData.createValue();
				orderGuideStructureData.setOrderGuideId(orderGuideId);
				orderGuideStructureData.setItemId(itemId);
				orderGuideStructureData.setCategoryItemId(0);
				orderGuideStructureData.setAddBy(orderguideloader);
				orderGuideStructureData.setModBy(orderguideloader);
				}else{
					log.info("Error Item Not found distsku = " + distSku);
				}*/
				if(catalogId == null){
					selectOrderGuide = selectOrderGuide + " and site_ref_num = '" + siteRefNum + "'" ;
				}else{
					selectOrderGuide = selectOrderGuide + " and catalog_id = '" + catalogId + "'";
				}

				log.info("Add Items to order Guide Structure sql= " + selectOrderGuide);

				PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
				pstmt.setString(1, orderGuideName);
				pstmt.setString(2, accountRefNum);
				ResultSet rs = pstmt.executeQuery();

				PreparedStatement pstmt1 = conn.prepareStatement(insertOrderGuideStructure);
				pstmt1.setInt(1,orderGuideId);
				pstmt1.setString(3,orderguideloader);

				while(rs.next()){
					distSku = rs.getString(1);
					log.info("Add Items to order Guide Structure dist_sku ===  " + distSku);
					IdVector itemIds = getAllItemIds(conn,distSku,"",storeNum);
					log.info("Add Items to order Guide Structure ItemID count ===  " + itemIds.size());
					Iterator it = itemIds.iterator();
					while(it.hasNext()){
						Integer itemId = (Integer) it.next();
						pstmt1.setInt(2,itemId.intValue());
						pstmt1.addBatch();
					}
				}
				pstmt1.executeBatch();
				pstmt1.close();

				pstmt.close();
			}


			return orderGuideId;
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processSiteDelivery()=> "
                               + e.getMessage());
    	}


	}

	public void deleteOrderGuideStructure(Connection conn,int orderGuideId) throws RemoteException{
		log.info("Delete data from order guide structure ====== order_guide_id = " + orderGuideId);
		String deleteOrderGuideStru = "delete from clw_order_guide_structure where order_guide_id = ?";

		try{
			PreparedStatement pstmt = conn.prepareStatement(deleteOrderGuideStru);
			pstmt.setInt(1, orderGuideId);
			int delRec = pstmt.executeUpdate();
			pstmt.close();
			log.info("Number of records deleted from order guide structure = " + delRec);
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.deleteOrderGuideStructure()=> "
                               + e.getMessage());
    	}
	}

	public void createOrderGuideStructure(Connection conn,int orderGuideId,PollockOrderGuideView pollockOrderGuideView,String orderguideloader,int storeNum) throws RemoteException{
		String selectOrderGuide = "select distinct dist_sku from CLT_POLLARD_ORDER_GUIDE_LOADER " +
		"where order_guide_name = ? " +
		"and account_ref_num = ?";

		String insertOrderGuideStructure = "insert into clw_order_guide_structure" +
		"(order_guide_structure_id,order_guide_id,item_id,category_item_id,quantity," +
		"add_Date,add_by,mod_date) " +
		"values(clw_order_guide_structure_seq.nextval,?,?,0,0,sysdate,?,sysdate)";


		String accountRefNum = "";
		String siteRefNum = "";
		String catalogKey = "";
		String orderGuideName = "";
		String orderGuideType = "";
		String distSku = "";

		try{
			orderGuideName = pollockOrderGuideView.getorderGuideName();
			accountRefNum = pollockOrderGuideView.getaccountRefNum();
			siteRefNum = pollockOrderGuideView.getsiteRefNum();
			catalogKey = pollockOrderGuideView.getcatalogId();
			orderGuideType = pollockOrderGuideView.getorderGuideType();
			orderGuideType = orderGuideType.toUpperCase();

			if(siteRefNum != null){
				selectOrderGuide = selectOrderGuide + " and site_ref_num = '" + siteRefNum + "'" ;
			}else{
				selectOrderGuide = selectOrderGuide + " and catalog_id = '" + catalogKey + "'";
			}

		 	log.info("Add Items to order Guide Structure sql= " + selectOrderGuide);

			PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
			pstmt.setString(1, orderGuideName);
			pstmt.setString(2, accountRefNum);
			ResultSet rs = pstmt.executeQuery();


			while(rs.next()){
				distSku = rs.getString(1);
				log.info("Add Items to order Guide Structure dist_sku ===  " + distSku);
				IdVector itemIds = getAllItemIds(conn,distSku,"",storeNum);
				log.info("Add Items to order Guide Structure ItemID count ===  " + itemIds.size());
				Iterator it = itemIds.iterator();
				while(it.hasNext()){
					Integer itemId = (Integer) it.next();
					PreparedStatement pstmt2 = conn.prepareStatement(insertOrderGuideStructure);
					pstmt2.setInt(1,orderGuideId);
					pstmt2.setInt(2,itemId);
					pstmt2.setString(3,orderguideloader);
					pstmt2.executeUpdate();
					pstmt2.close();
				}

			}


			pstmt.close();


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createOrderGuideStructure()=> "
                               + e.getMessage());
    	}


	}

	public int checkIfOrderGuideExists(Connection conn,int catalogId,String orderGuideName,String orderGuideType,int siteId) throws RemoteException{
		log.info("Check If order Guide Exists");

		int orderGuideId = 0;

	/*	String selectOrderGuideId = "select order_guide_id from clw_order_guide where short_Desc = ? " +
		"and catalog_id = ? and order_guide_type_cd = ?";*/
		String selectOrderGuideId = "select order_guide_id from clw_order_guide where short_Desc = ? " +
		"and order_guide_type_cd = ?";

		String orderGuideTypeCd = "";
		int thirdCondition = 0;

		try{

			log.info("oooooooo 1111111111111111111111111111111");


			if(orderGuideType.equals("CATALOG")){
				orderGuideTypeCd = "ORDER_GUIDE_TEMPLATE";
				selectOrderGuideId = selectOrderGuideId + " and catalog_id = ?";
				thirdCondition = catalogId;

			}

			if(orderGuideType.equals("SITE")){
				log.info("000000000000000002222222222222222222222222 sql=" + selectOrderGuideId);
				orderGuideTypeCd = "SITE_ORDER_GUIDE_TEMPLATE";
				selectOrderGuideId = selectOrderGuideId + " and bus_entity_id = ?";
				log.info("Third Condition is site id =" + siteId);
				log.info("0000000000000000000000003333333333333333333333 sql=" + selectOrderGuideId);
				thirdCondition = siteId;

			}
			PreparedStatement pstmt = conn.prepareStatement(selectOrderGuideId);
			pstmt.setString(1,orderGuideName);
			pstmt.setString(2,orderGuideTypeCd);
			pstmt.setInt(3, thirdCondition);
			//pstmt.setInt(2, catalogId);
			//pstmt.setString(2,orderGuideTypeCd);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				orderGuideId = rs.getInt(1);

			}

			pstmt.close();
			return orderGuideId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkIfOrderGuideExists()=> "
                               + e.getMessage());
    	}

	}

	public int getItemId(Connection conn,String distSku,String uom,int storeNum) throws RemoteException{

		 String uomCond = (Utility.isSet(uom))?" and NVL(item_uom,'NULL')='"+uom+"' " :"" ;

			String selectItemId = "select item_id from clw_item where item_id in(select item_id from " +
			"clw_item_mapping where item_num = ? " + uomCond +
                            " and bus_entity_id in(select bus_entity_id from clw_bus_entity " +
			"where bus_entity_type_cd = ? and bus_entity_id in(select bus_entity1_id " +
			"from clw_bus_entity_assoc where bus_entity2_id = ?))) and item_status_cd = ?";
		int itemId = 0;
		try{
	    	PreparedStatement pstmt = conn.prepareStatement(selectItemId);
			pstmt.setString(1, distSku);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt.setInt(3, storeNum);
			pstmt.setString(4, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				itemId = rs.getInt(1);
				if(rs.next())
				throw new IllegalArgumentException("Two items found dist_sku = " + distSku + "selectItemId =" + selectItemId);
			}
			pstmt.close();
			log.info("from getItemId Method get Item Id distSku = " + distSku + "itemId = " + itemId);
			return itemId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getItemId()=> "
                               + e.getMessage());
    	}


	}


	public IdVector getAllItemIds(Connection conn,String distSku,String uom,int storeNum) throws RemoteException{

		 String uomCond = (Utility.isSet(uom))?" and NVL(item_uom,'NULL')='"+uom+"' " :"" ;

			String selectItemId = "select item_id from clw_item where item_id in(select item_id from " +
			"clw_item_mapping where item_num = ? " + uomCond +
                           " and bus_entity_id in(select bus_entity_id from clw_bus_entity " +
			"where bus_entity_type_cd = ? and bus_entity_id in(select bus_entity1_id " +
			"from clw_bus_entity_assoc where bus_entity2_id = ?))) and item_status_cd = ?";
		IdVector items = new IdVector();
		try{
	    	PreparedStatement pstmt = conn.prepareStatement(selectItemId);
			pstmt.setString(1, distSku);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt.setInt(3, storeNum);
			pstmt.setString(4, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				int itemId = rs.getInt(1);
				items.add(new Integer(itemId));
			}
			pstmt.close();
			//log.info("from getItemId Method get Item Id distSku = " + distSku + "itemId = " + itemId);
			return items;

		}catch(Exception e){
   		e.printStackTrace();
   		//throw e;
   		   throw new RemoteException(
                      "Error.IntegrationServicesBean.getItemId()=> "
                              + e.getMessage());
   	}


	}

	public int getSiteCatalogId(Connection conn,int siteId) throws RemoteException{

		String selectSiteCatalogId = "select catalog_id from clw_catalog where catalog_id in " +
									"(select catalog_id from clw_catalog_Assoc where bus_entity_id = ?) " +
									"and catalog_type_Cd = ? and catalog_status_Cd = ? ";

		int catalogId = 0;

		try{
	    	PreparedStatement pstmt = conn.prepareStatement(selectSiteCatalogId);
			pstmt.setInt(1, siteId);
			pstmt.setString(2, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
			pstmt.setString(3, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();

			while(rs.next()){
				catalogId = rs.getInt(1);
				if(rs.next())
					throw new IllegalArgumentException("More Than two Active Site Catalog for Site ID = " + siteId);
			}

			pstmt.close();
			return catalogId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getSiteCatalogId()=> "
                               + e.getMessage());
    	}


	}


	public void processCatalog(Connection conn,String catalogloader,int storeNum,String tmpTableName) throws RemoteException{
		log.info("Process Catalog");

		String selectSysdate = "select sysdate from dual";

		String catalogStartTime = "";

		String selectNull = "select count(*) from CLT_POLLOCK_CATALOG_LOADER " +
				"where add_by = ? and( " +
				"VERSION_NUMBER is null or STORE_ID is null or account_ref_num is null " +
				"or catalog_key is null or catalog_name is null or order_guide_name is null or locale is null " +
		        "or dist_sku is null or distributor is null or pack is null or uom is null or cost is null " +
		        "or price is null or category_name is null or order_guide is null)";

	    String selectAcc = "select count(*) from CLT_POLLOCK_CATALOG_LOADER where account_ref_num not in " +
	    "(select clw_value from clw_property where bus_entity_id in " +
	    "(select bus_Entity_id from clw_bus_entity where bus_entity_id in " +
	    "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
	    "and bus_entity_type_cd = ?) " +
	    "and short_desc = ?) and add_by = ? ";


    	//String selectDistCheck = "select count(*) from CLT_POLLOCK_CATALOG_LOADER t where add_by = ? " +


    	String selectDistCheck = "select count(*) from CLT_POLLOCK_CATALOG_LOADER t where add_by = ? " +
		"and not exists " +
		"(select short_desc from clw_bus_entity cbe where bus_entity_type_cd = ? and " +
		"upper(cbe.short_desc) = upper(t.distributor) " +
		"and cbe.bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))";

    	String selectAccCat = "select distinct account_ref_num,catalog_key from CLT_POLLOCK_CATALOG_LOADER " +
    			"where add_by = ? order by account_ref_num,catalog_key";

		String selectStoreCatalog = "select catalog_id from clw_catalog where catalog_id in" +
		"(select catalog_id from clw_catalog_assoc where bus_entity_id = ?) " +
		"and catalog_type_cd = ? and catalog_status_cd = ?";

		String selectItemId = "select ci.item_id,cim.item_num " +
		"from clw_item ci,clw_item_mapping cim,clw_bus_entity dist,clw_bus_entity_assoc cbea " +
		"where ci.item_id = cim.item_id and cim.bus_entity_id = dist.bus_entity_id " +
		"and dist.bus_entity_id = cbea.bus_entity1_id and cbea.bus_entity2_id = ? " +
		"and dist.bus_entity_type_cd = 'DISTRIBUTOR' and ci.item_status_cd = 'ACTIVE' " +
                "and cbea.bus_entity_assoc_cd = 'DISTRIBUTOR OF STORE' "+
		"and cim.item_num in " +
		"(select item_num from " +
		"(select item_num,count(*) from clw_item_mapping where bus_entity_id in " +
		"(select bus_entity_id from clw_bus_entity where bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ? and bus_entity_assoc_cd = 'DISTRIBUTOR OF STORE') " +
		"and bus_entity_type_cd = 'DISTRIBUTOR' and bus_entity_status_cd = 'ACTIVE' ) " +
		"group by item_num having count(*) = 1))";

		int storeCatalogId = 0;
		HashMap itemIdHashMap = new HashMap();


		try{
			PreparedStatement pstmt = conn.prepareStatement(selectSysdate);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				catalogStartTime = rs.getString(1);
				log.info("Catalog Loader Start Time = " + catalogStartTime);
			}
			pstmt.close();

	    	pstmt = conn.prepareStatement(selectNull);
			pstmt.setString(1, catalogloader);
			rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 1111111111111111111111 Oneeeeee of the mandatory field is null" +  selectNull);
			} else{
				log.info("CHECK 1111111111111111111111 is success Counttttt is zero continue = " + count);
			}

			pstmt.close();

			pstmt = conn.prepareStatement(selectAcc);
			pstmt.setInt(1, storeNum);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			pstmt.setString(3, RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM);
			pstmt.setString(4, catalogloader);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				log.info("Check 2 COUNTTTTTTTTTTTTTT = " + count);
			}


			if (count > 0) {
				throw new IllegalArgumentException("CHECK 22222222222222222222222 Accounttttttttt does not exists");
			} else{
				log.info("CHECK 22222222222222222222222 Success Counttttt is zero continue = " + count);
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectDistCheck);
			pstmt.setString(1, catalogloader);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt.setInt(3, storeNum);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);

			}
			log.info("Check 3, check if all the Distributor are present  = " + selectDistCheck);
			if (count > 0) {
				throw new IllegalArgumentException("Error CHECK 333333333333 Distributor does not exists");
			} else{
				log.info("CHECK 333333333333333 Counttttt is zero continue = " + selectDistCheck);
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectStoreCatalog);
			pstmt.setInt(1, storeNum);
			pstmt.setString(2, RefCodeNames.CATALOG_TYPE_CD.STORE);
			pstmt.setString(3, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			rs = pstmt.executeQuery();
			while(rs.next()){
				storeCatalogId = rs.getInt(1);
				if(rs.next())
					throw new IllegalArgumentException("More than two Active Store Catalogs Exists" + selectStoreCatalog);
			}

			pstmt.close();
                        log.info("step:  selectStoreCatalog = " + selectStoreCatalog);
                        // check : all Cost Centers are present
                        StringBuffer errMess = new StringBuffer();
                        errMess.append(checkAllCostCenterKeyExists(conn, storeNum, catalogloader,tmpTableName));
                        if (Utility.isSet(errMess.toString())){
                              throw new Exception("^clw^"+errMess.toString()+ "^clw^");
                        }

			pstmt = conn.prepareStatement(selectItemId);
			pstmt.setInt(1,storeNum);
			pstmt.setInt(2,storeNum);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int itemID1 = rs.getInt(1);
				String itemNum1 = rs.getString(2);
				if(  itemIdHashMap.containsKey(itemNum1)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemIdHashMap.put(itemNum1,itemID1);
		    	}
			}
			pstmt.close();
                        log.info("step : selectItemId = " + selectItemId);

                        HashMap<String,HashSet> catalogCostCenersMap = getCatalogCostCentersMap (conn,catalogloader, tmpTableName);
                        HashMap<String,Integer> costCenterKeyToIdMap = getCostCenterKeyToIdMap(conn,catalogloader, tmpTableName);

			pstmt = conn.prepareStatement(selectAccCat);
			pstmt.setString(1, catalogloader);
			rs = pstmt.executeQuery();

                        log.info("step : selectAccCat = " + selectAccCat);

			int catalogId = 0;

			while(rs.next()){

				String accRefNum = "";
				String catalogKey = "";
				int accountId = 0;
				int accountCatalogId = 0;
				int shoppingCatalogId = 0;
				int contractId = 0;
				int templateOrderGuideId = 0;

				accRefNum = rs.getString(1);
				catalogKey = rs.getString(2);

				accountId = getAccountId(conn,accRefNum,storeNum);
				accountCatalogId = getAccountCatalogId(conn,accountId);
				shoppingCatalogId = getShoppingCatalogId(conn,accountId,catalogKey);
				log.info("processing Pollock Catalog account_ref_num = " + accRefNum + " catalog_key =" + catalogKey);

				if(accountCatalogId == 0){
					log.info("Create New Account Catalog account_id = " + accountId);
					accountCatalogId = createAccountCatalog(conn,accountId,storeNum,catalogloader);
			//		log.info("Create New Account Catalog account_id ============================= " + accountId);
				//	createCatlogStructure(conn,accountId,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
					createCatlogStructureN(conn,accountId,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName,itemIdHashMap, costCenterKeyToIdMap);
			//		log.info("Create New Account Catalog account_id ============================= " + accountId);
		//			log.info("Account Catalog ID = " + accountCatalogId);


				}else{
					log.info("Add Items to Account Catalog account catalog Id = " + accountCatalogId);
					updateCatalogDate(conn,accountCatalogId,catalogloader);
					//updateAccountCatalogStructure(conn,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
					updateAccountCatalogStructureN(conn,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName,itemIdHashMap, costCenterKeyToIdMap);
				}

				if(shoppingCatalogId == 0){
					log.info("Create New Shopping Catalog account_id = " + accountId + "catalog name=" + catalogKey);
					shoppingCatalogId = createShoppingCatalog(conn,accountId,storeNum,catalogloader,catalogKey,accRefNum,tmpTableName);
			//		log.info("Create New Shopping Catalog account_id =+++++++++++++++++++++++++++++ " + accountId + "catalog name=" + catalogKey);
			//		createCatlogStructure(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
					createCatlogStructureN(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName,itemIdHashMap);
			//		log.info("Create New Shopping Catalog account_id =+++++++++++++++++++++++++++++ " + accountId + "catalog name=" + catalogKey);
					contractId = createContractN(conn,shoppingCatalogId,catalogKey,storeNum,catalogloader,accRefNum);
					createContractItemN(conn,contractId,accRefNum,catalogKey,storeNum,catalogloader,tmpTableName,itemIdHashMap);
					//templateOrderGuideId = createTemplateOrderGuide(conn,shoppingCatalogId,catalogKey,catalogloader);
					//createTemplateOrderGuideStruct(conn,templateOrderGuideId,accRefNum,catalogKey,catalogloader,storeNum);
					checkCreateTemplateOrderGuide(conn,shoppingCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
					log.info("Create New Shopping Catalog account_id =+++++++++++++++++++++++++++++ " + accountId + "catalog name=" + catalogKey);
				}else{
					log.info("Update Shopping Catalog Structure  Shopping_catalog_Id = " + shoppingCatalogId);
					updateCatalogDate(conn,shoppingCatalogId,catalogloader);
		//			deleteCatalogStructure(conn,shoppingCatalogId);
			//		log.info("Update Shopping Catalog Structure  Shopping_catalog_Id =*********************** " + shoppingCatalogId);
					updateShopCatlogStructure(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName,itemIdHashMap);
		//			createCatlogStructure(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
			//		log.info("Update Shopping Catalog Structure  Shopping_catalog_Id =*********************** " + shoppingCatalogId);
					contractId = getContractId(conn,shoppingCatalogId);
					updateContractDate(conn,contractId,catalogloader);
					deleteContractItem(conn,contractId);
					createContractItemN(conn,contractId,accRefNum,catalogKey,storeNum,catalogloader,tmpTableName,itemIdHashMap);
					//templateOrderGuideId = getTemplateOrderGuideId(conn,shoppingCatalogId);
					//createTemplateOrderGuideStruct(conn,templateOrderGuideId,accRefNum,catalogKey,catalogloader,storeNum);
					checkCreateTemplateOrderGuide(conn,shoppingCatalogId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
				}
                                // creating catalog-costCenter Association for account Catalog
                                HashSet costCenterKeysHS = catalogCostCenersMap.get(catalogKey);
                                if (costCenterKeysHS != null && costCenterKeysHS.size() >0) {
                                  createCatalogCostCenterAssoc(conn, costCenterKeysHS, accountCatalogId, catalogloader);
                                }

			}

			pstmt.close();

			log.info("Catalog Loader Start Time ================================ " + catalogStartTime);

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processCatalog()=> "
                               + e.getMessage());
    	}

	}

	public void updateCatalogDate(Connection conn,int catalogId,String catalogloader) throws RemoteException{
		String updateCatalog = "update clw_catalog set mod_by = ?,mod_date = sysdate " +
				"where catalog_id = ?";
		try{
			log.info("Start Update Catalog Date");
			PreparedStatement pstmt = conn.prepareStatement(updateCatalog);
			pstmt.setString(1,catalogloader);
			pstmt.setInt(2,catalogId);
			pstmt.executeUpdate();
			pstmt.close();
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateCatalogDate()=> "
                               + e.getMessage());
    	}
	}

	public void updateContractDate(Connection conn,int contractId,String catalogloader) throws RemoteException{
		String updateContract = "update clw_contract set mod_by = ?, mod_date = sysdate " +
				"where contract_id = ?";
		try{
			log.info("Start Update Contract Date");
			PreparedStatement pstmt = conn.prepareStatement(updateContract);
			pstmt.setString(1,catalogloader);
			pstmt.setInt(2, contractId);
			pstmt.executeUpdate();
			pstmt.close();
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateContractDate()=> "
                               + e.getMessage());
    	}

	}

	public int getAccountCatalogId(Connection conn,int accountId) throws RemoteException{
		log.info("Get Account Catalog Id");

		String selectAccCatId = "select catalog_id from clw_catalog where catalog_id in(select catalog_id " +
				"from clw_catalog_assoc where bus_entity_id = ?) and catalog_type_cd = ? and catalog_status_cd = ?";

		int accountCatalogId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectAccCatId);
			pstmt.setInt(1, accountId);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT);
			pstmt.setString(3, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				accountCatalogId = rs.getInt(1);
				if(rs.next())
					throw new IllegalArgumentException("More Than one Account Catalod Found for Account ID = " + accountId);
			}
			pstmt.close();
			return accountCatalogId;
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getAccountCatalogId()=> "
                               + e.getMessage());
    	}

	}

	public int getShoppingCatalogId(Connection conn,int accountId,String catalogKey) throws RemoteException{
		log.info("Get Shopping Catalog Id");

		String selectShoppingCatId = "select catalog_id from clw_catalog where catalog_id in(select catalog_id " +
				"from clw_catalog_assoc where bus_entity_id = ?) and catalog_type_cd = ?" +
				"and catalog_status_cd = ? and loader_field = ?";

		int shoppingCatalogId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectShoppingCatId);
			pstmt.setInt(1, accountId);
			pstmt.setString(2, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
			pstmt.setString(3, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			pstmt.setString(4, catalogKey);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				shoppingCatalogId = rs.getInt(1);
				if(rs.next())
					throw new IllegalArgumentException("More Than one Shopping Catalog Found for Account ID = " + accountId + "catalog key = " + catalogKey);
			}
			pstmt.close();
			return shoppingCatalogId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getShoppingCatalogId()=> "
                               + e.getMessage());
    	}
	}

	public int createAccountCatalog(Connection conn,int accountId,int storeNum,String catalogloader) throws RemoteException{
		log.info("Create Acccount Catalogg");
		String accountCatalogName = "Account Catalog ";

		String insertCatalogAssoc = "INSERT INTO CLW_CATALOG_ASSOC(CATALOG_ASSOC_ID,CATALOG_ID,BUS_ENTITY_ID," +
				"CATALOG_ASSOC_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY) " +
				"VALUES(CLW_CATALOG_ASSOC_SEQ.NEXTVAL,?,?,?,SYSDATE,?,SYSDATE,?)";

		int accountCatalogId = 0;
		Date runDate = new Date();

		try{
			accountCatalogName = accountCatalogName + accountId;
			CatalogData catalogData = CatalogData.createValue();
			catalogData.setShortDesc(accountCatalogName);
			catalogData.setCatalogStatusCd(RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			catalogData.setCatalogTypeCd(RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
			catalogData.setRankWeight(0);
			catalogData.setAddBy(catalogloader);
			catalogData.setAddDate(runDate);
			catalogData.setModBy(catalogloader);
			catalogData.setModDate(runDate);

			catalogData = CatalogDataAccess.insert(conn, catalogData);
			accountCatalogId = catalogData.getCatalogId();

			PreparedStatement pstmt = conn.prepareStatement(insertCatalogAssoc);
			pstmt.setInt(1,accountCatalogId);
			pstmt.setString(4,catalogloader);
			pstmt.setString(5,catalogloader);

			pstmt.setInt(2,accountId);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT);
			pstmt.addBatch();

			pstmt.setInt(2,storeNum);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_STORE);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();

			return accountCatalogId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createAccountCatalog()=> "
                               + e.getMessage());
    	}
	}


	public int createShoppingCatalog(Connection conn,int busEntityId,int storeNum,String catalogloader,String catalogKey,String accRefNum,String tmpTableName) throws RemoteException{
		log.info("Create Shopping Catalog Start");
		//String accountCatalogName = "Account Catalog ";

		String insertCatalogAssoc = "INSERT INTO CLW_CATALOG_ASSOC(CATALOG_ASSOC_ID,CATALOG_ID,BUS_ENTITY_ID," +
				"CATALOG_ASSOC_CD,ADD_DATE,ADD_BY,MOD_DATE,MOD_BY) " +
				"VALUES(CLW_CATALOG_ASSOC_SEQ.NEXTVAL,?,?,?,SYSDATE,?,SYSDATE,?)";

		String selectDist = "select distributor from (select distributor,count(*) cnt from " + tmpTableName + " " +
				"where account_ref_num = ? and catalog_key = ? " +
				"group by distributor) " +
				"where cnt >= (select max(cnt) from " +
				"(select distributor,count(*) cnt from " + tmpTableName + " " +
				"where account_ref_num = ? and catalog_key = ? " +
				"group by distributor))";

		String selectDistDist = "select distinct distributor from " + tmpTableName +
				"where account_ref_num = ? " +
				"and catalog_key = ?" +
				"and add_by = ? ";


		int shoppingCatalogId = 0;
		int mainDistId = 0;
		int distId = 0;
		Date runDate = new Date();
		String distName = "";

		try{

			PreparedStatement pstmt = conn.prepareStatement(selectDist);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2, catalogKey);
			pstmt.setString(3, accRefNum);
			pstmt.setString(4, catalogKey);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				distName = rs.getString(1);
				mainDistId = getDistId(conn,distName,storeNum);
			}

			pstmt.close();

			//accountCatalogName = accountCatalogName + accountId;
			CatalogData catalogData = CatalogData.createValue();
			catalogData.setShortDesc(catalogKey);
			catalogData.setCatalogStatusCd(RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
			catalogData.setCatalogTypeCd(RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
			catalogData.setRankWeight(0);
			catalogData.setAddBy(catalogloader);
			catalogData.setAddDate(runDate);
			catalogData.setModBy(catalogloader);
			catalogData.setModDate(runDate);
			catalogData.setLoaderField(catalogKey);

			catalogData = CatalogDataAccess.insert(conn, catalogData);
			shoppingCatalogId = catalogData.getCatalogId();

			pstmt = conn.prepareStatement(insertCatalogAssoc);
			pstmt.setInt(1,shoppingCatalogId);
			pstmt.setString(4,catalogloader);
			pstmt.setString(5,catalogloader);

			pstmt.setInt(2,busEntityId);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT);
			pstmt.addBatch();

			pstmt.setInt(2,storeNum);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_STORE);
			pstmt.addBatch();

			pstmt.setInt(2, mainDistId);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_MAIN_DISTRIBUTOR);
			pstmt.addBatch();

			///In case of pollock there is only one distributor so this will work
			//if there are more than 1 distrubutor then you will have to use the selectDistDist query
			//logic to addociate the catalog_distributor
			pstmt.setInt(2, mainDistId);
			pstmt.setString(3, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_DISTRIBUTOR);
			pstmt.addBatch();

			pstmt.executeBatch();
			pstmt.close();

			/*pstmt = conn.prepareStatement(selectDistDist);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2, catalogKey);
			pstmt.setString(3, catalogloader);
			rs = pstmt.executeQuery();
			while(rs.next()){
				distName = rs.getString(1);
				distId = getDistId(conn,distName,storeNum);
				//Add To array List and then aad to

			}*/





			return shoppingCatalogId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createShoppingCatalog()=> "
                               + e.getMessage());
    	}

	}

	public int getDistId(Connection conn,String distName,int storeNum) throws RemoteException {
		//log.info("getDistId Start distName = " + distName + "StoreId = " + storeNum);

		String selectDistID = "select cbe.bus_entity_id	from clw_bus_entity cbe,clw_bus_entity_assoc cbea " +
				"where cbe.bus_entity_id = cbea.bus_entity1_id " +
				"and upper(cbe.short_desc) = upper(?) " +
				"and cbea.bus_entity2_id = ? " +
				"and cbe.bus_entity_type_cd = ?	" +
				"and cbe.bus_entity_status_cd = ?";
		int distId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectDistID);
			pstmt.setString(1, distName);
			pstmt.setInt(2, storeNum);
			pstmt.setString(3, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt.setString(4, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				distId = rs.getInt(1);
			}

			if(distId == 0){
				throw new IllegalArgumentException("Distributor Not FOund distName = " + distName + "storeID = " + storeNum);
			}
			pstmt.close();
			return distId;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createShoppingCatalog()=> "
                               + e.getMessage());
    	}

	}


public void updateShopCatlogStructure(Connection conn,int busEntityId,int catalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum, String tmpTableName,HashMap itemIdHashMap) throws RemoteException{
		log.info("Create or update Catalog Structure bus_entity_id = " + busEntityId + "catalog_id =" + catalogId);
		long startTime = System.currentTimeMillis();
		String selectSku = "select dist_sku,distributor,customer_sku,upper(category_name),category_order,upper(subcat1)," +
		"subcat1_order,upper(subcat2),subcat2_order,upper(subcat3),subcat3_order, uom " +
		"from "+tmpTableName+" "+
		"where account_ref_num = ? and catalog_key = ? and add_by = ?";

		String insertCatalogStruct = " insert into clw_catalog_structure(catalog_structure_id," +
		"catalog_id,bus_entity_id,catalog_structure_cd,item_id," +
		"customer_sku_num,eff_date,status_cd,add_date,add_by,mod_date,mod_by,cost_center_id,sort_order) " +
		"values(clw_catalog_structure_seq.nextval,?,?,?,?,?,sysdate,?,sysdate,?,sysdate,?,0,0)";

		String selectDist = "select distinct distributor from "+tmpTableName+ " where add_by = ?";

		String selectDistID = "select cbe.bus_entity_id	from clw_bus_entity cbe,clw_bus_entity_assoc cbea " +
		"where cbe.bus_entity_id = cbea.bus_entity1_id " +
		"and upper(cbe.short_desc) = upper(?) " +
		"and cbea.bus_entity2_id = ? " +
		"and cbe.bus_entity_type_cd = ?	" +
		"and cbe.bus_entity_status_cd = ?";

		String selectCatalogItems = "select item_id,bus_entity_id from clw_catalog_structure where catalog_id = ?";

		String selectShopCatalogCategory = "select item_id,sort_order from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY'";

		String itemAssocCk = "select item1_id,item2_id from clw_item_Assoc where catalog_id = ?";

		String selectStoreCategory = "select item_id,upper(short_desc) from clw_item where item_id in " +
		"(select item_id from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY') ";

		String updateCatStruct = "update clw_catalog_structure set customer_sku_num = ?,mod_date=sysdate,mod_by = ? " +
				" where catalog_id = ? and item_id = ?";

		//log.info("FROM CATALOG STRUCTUREEEEEEEEEEE catalog_id = " + catalogId);

/*		String selectItemId = "select ci.item_id,cim.item_num " +
		"from clw_item ci,clw_item_mapping cim,clw_bus_entity dist,clw_bus_entity_assoc cbea " +
		"where ci.item_id = cim.item_id and cim.bus_entity_id = dist.bus_entity_id " +
		"and dist.bus_entity_id = cbea.bus_entity1_id and cbea.bus_entity2_id = ? " +
		"and dist.bus_entity_type_cd = 'DISTRIBUTOR' and ci.item_status_cd = 'ACTIVE' " +
		"and cim.item_num not in " +
		"(select item_num from " +
		"(select item_num,count(*) from clw_item_mapping where bus_entity_id in " +
		"(select bus_entity_id from clw_bus_entity where bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?) " +
		"and bus_entity_type_cd = 'DISTRIBUTOR' and bus_entity_status_cd = 'ACTIVE') " +
		"group by item_num having count(*) >1))"; */

		Date runDate = new Date();
		HashMap catShopStructHashMap  = new HashMap();
		HashMap categoryHashMap  = new HashMap();
		HashMap itemAssocCheck = new HashMap();
		//HashMap itemIdHashMap = new HashMap();
		ArrayList itemIdList = new ArrayList();

		try{
			 String uom = "";
			String distSku = "";
			String distributor = "";
			String customerSku = "";
			String categoryName = "";
			int categoryOrder = 0;
			String subcat1Cd = "";
			int subCat1Order = 0;
			String subcat2Cd = "";
			int subCat2Order = 0;
			String subcat3Cd = "";
			int subCat3Order = 0;
			int itemID = 0;
			int mainCategoryId = 0;
			int subCat1Id = 0;
			int subCat2Id = 0;
			int subCat3Id = 0;
			int distId = 0;

			String mcatO = "";
			String sub1O = "";
			String sub2O = "";
			String sub3O = "";

			HashMap distHashMap  = new HashMap();
			HashMap shoppingCatItem = new HashMap();

			PreparedStatement pstmt = conn.prepareStatement(selectDist);
			pstmt.setString(1,catalogloader);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				int distID = 0;
				String distName= rs.getString(1);
				PreparedStatement pstmt1 = conn.prepareStatement(selectDistID);
				pstmt1.setString(1, distName);
				pstmt1.setInt(2, storeNum);
				pstmt1.setString(3, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
				pstmt1.setString(4, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
				ResultSet rs1 = pstmt1.executeQuery();
				while(rs1.next()){
					distID = rs1.getInt(1);
				}

				if(distID == 0){
					throw new IllegalArgumentException("Distributor Not FOund distName = " + distName + "storeID = " + storeNum);
				}
				pstmt1.close();

				if(distHashMap.containsKey(distName)  ){
					//do nothing
				}else{
					distHashMap.put(distName,distID);
				}

			}

			pstmt.close();

			pstmt = conn.prepareStatement(selectCatalogItems);
			pstmt.setInt(1,catalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int shoppingCatItemId = rs.getInt(1);
				int shoppingCatDistId = rs.getInt(2);

				if(shoppingCatItem.containsKey(shoppingCatItemId)  ){
					//do nothing
				}else{
					shoppingCatItem.put(shoppingCatItemId,shoppingCatDistId);
				}
			}
			pstmt.close();


			//Add Category to Catalog HashMap
			pstmt = conn.prepareStatement(selectShopCatalogCategory);
			pstmt.setInt(1,catalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int shoppingCategoryId = rs.getInt(1);
				int shoppingCatSortOrd = rs.getInt(2);

				if(catShopStructHashMap.containsKey(shoppingCategoryId)  ){
					//do nothing
				}else{
					catShopStructHashMap.put(shoppingCategoryId,shoppingCatSortOrd);
				}
			}
			pstmt.close();


			pstmt = conn.prepareStatement(itemAssocCk);
			pstmt.setInt(1,catalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int item11Id = rs.getInt(1);
				int item22Id = rs.getInt(2);
				if(  itemAssocCheck.containsKey(item11Id)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemAssocCheck.put(item11Id,item22Id);
		    	}
			}
			pstmt.close();


			///category hashmap
			pstmt = conn.prepareStatement(selectStoreCategory);
			pstmt.setInt(1,storeCatalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int cateID = rs.getInt(1);
				String cateName = rs.getString(2);
				if(  categoryHashMap.containsKey(cateName)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		categoryHashMap.put(cateName,cateID);
		    	}
			}
			pstmt.close();


	/*		pstmt = conn.prepareStatement(selectItemId);
			pstmt.setInt(1,storeNum);
			pstmt.setInt(2,storeNum);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int itemID1 = rs.getInt(1);
				String itemNum1 = rs.getString(2);
				if(  itemIdHashMap.containsKey(itemNum1)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemIdHashMap.put(itemNum1,itemID1);
		    	}
			}
			pstmt.close(); */



			pstmt = conn.prepareStatement(selectSku);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2,catalogKey);
			pstmt.setString(3,catalogloader);
			rs = pstmt.executeQuery();



			while(rs.next()){
				distSku = rs.getString(1);
				distributor= rs.getString(2);
				customerSku = rs.getString(3);
				categoryName = rs.getString(4);
			//	categoryOrder = Integer.parseInt(rs.getString(5));
				mcatO = rs.getString(5);
				subcat1Cd = rs.getString(6);
			//	subCat1Order = Integer.parseInt(rs.getString(7));
				sub1O = rs.getString(7);
				subcat2Cd = rs.getString(8);
		//		subCat2Order = Integer.parseInt(rs.getString(9));
				sub2O = rs.getString(9);
				subcat3Cd = rs.getString(10);
		//		subCat3Order = Integer.parseInt(rs.getString(11));
				sub3O = rs.getString(11);
				 uom = rs.getString(12);
				if(mcatO != null){
					categoryOrder = Integer.parseInt(mcatO);
				}

				if(sub1O != null){
					subCat1Order = Integer.parseInt(sub1O);
				}

				if(sub2O != null){
					subCat2Order = Integer.parseInt(sub2O);
				}

				if(sub3O != null){
					subCat3Order = Integer.parseInt(sub3O);
				}


			//	log.info("FROM CATALOG STRUCTUREEEEEEEEEEE distSku = " + distSku);

				if(itemIdHashMap.containsKey(distSku)){
					itemID = (Integer)  itemIdHashMap.get(distSku);
				}else{
				itemID = getItemId(conn, distSku,distributor,uom,storeNum );
				}


				 if (itemIdList.contains(itemID)){
			            //do nothing
			        }else {
			        	itemIdList.add(itemID);
			       }

				if(distHashMap.containsKey(distributor)  ){
					distId  = (Integer)  distHashMap.get(distributor);
				}else{
					distId = getDistId(conn,distributor,storeNum);
				}

				if(shoppingCatItem.containsKey(itemID)  ){
					pstmt = conn.prepareStatement(updateCatStruct);
					pstmt.setString(1, customerSku);
					pstmt.setString(2, catalogloader);
					pstmt.setInt(3, catalogId);
					pstmt.setInt(4,itemID);
					pstmt.executeUpdate();
					pstmt.close();
					//do nothing
				}else{
					pstmt = conn.prepareStatement(insertCatalogStruct);
					pstmt.setInt(1,catalogId);
					pstmt.setInt(2,distId);
					pstmt.setString(3,RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
					pstmt.setInt(4,itemID);
					pstmt.setString(5,customerSku);
					pstmt.setString(6,RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
					pstmt.setString(7,catalogloader);
					pstmt.setString(8,catalogloader);
					pstmt.executeUpdate();
					pstmt.close();

					shoppingCatItem.put(itemID,distId);
				}

				HashMap tempHashMap  = new HashMap();
				HashMap tempSortHashMap  = new HashMap();



				int itemAssocID = 0;
				int sortOrder = 0;
				if(subcat3Cd == null){
					if(subcat2Cd == null){
						if(subcat1Cd == null){
							///new addCategory Main

							if(categoryHashMap.containsKey(categoryName)){
								mainCategoryId = (Integer) categoryHashMap.get(categoryName);
							}else{
								log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
							}

							if (itemIdList.contains(mainCategoryId)){
					            //do nothing
					        }else {
					        	itemIdList.add(mainCategoryId);
					       }

							if(  catShopStructHashMap.containsKey(mainCategoryId)  ){
								 int sortOrde = (Integer) catShopStructHashMap.get(mainCategoryId);
								 if(sortOrde == categoryOrder){
									//do nothing
									}else{
										updateCategorySortOrder(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);
									}
							}else{
									tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catShopStructHashMap);
									catShopStructHashMap.put(mainCategoryId,categoryOrder);
							}

							//End new addCategiry Main

					//		associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);

					if(itemAssocCheck.containsKey(itemID)  ){
							int item2Id  = (Integer)  itemAssocCheck.get(itemID);
							if(item2Id == mainCategoryId) {
								//do nothing
							}else{
								associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}
						}else{
							    associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								itemAssocCheck.put(itemID,mainCategoryId);

						}
					/*		itemAssocID = checkItemCatAssoc(conn,itemID,mainCategoryId,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							} */

						}else{
							//associate sub cat 1

							if(categoryHashMap.containsKey(subcat1Cd)){
								subCat1Id = (Integer) categoryHashMap.get(subcat1Cd);
							}else{
								log.info("Category Does not Exits in store Catalof catName=" + subcat1Cd + " store Catalog_id = " + storeCatalogId);
							}

							if (itemIdList.contains(subCat1Id)){
					            //do nothing
					        }else {
					        	itemIdList.add(subCat1Id);
					       }

							///new addCategory subcat1
							if(  catShopStructHashMap.containsKey(subCat1Id)  ){
									int sortOrde = (Integer) catShopStructHashMap.get(subCat1Id);
								 if(sortOrde == subCat1Order){
									//do nothing
									}else{
										updateCategorySortOrder(conn,catalogId,subCat1Id,subCat1Order,catalogloader);
									}
							}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(subCat1Id,subCat1Order);
							}

							//End new addCategiry Subcat1

							//associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);

							if(itemAssocCheck.containsKey(itemID)  ){
								int item2Id  = (Integer)  itemAssocCheck.get(itemID);
								if(item2Id == subCat1Id) {
								//do nothing
								}else{
									associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								}
							}else{
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								itemAssocCheck.put(itemID,subCat1Id);
							}

						/*	itemAssocID = checkItemCatAssoc(conn,itemID,subCat1Id,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}*/
							//Check Main Category and subcat1 Association

							///new addCategory Main
							if(categoryHashMap.containsKey(categoryName)){
								mainCategoryId = (Integer) categoryHashMap.get(categoryName);
							}else{
								log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
							}

							if (itemIdList.contains(mainCategoryId)){
					            //do nothing
					        }else {
					        	itemIdList.add(mainCategoryId);
					       }

							if(  catShopStructHashMap.containsKey(mainCategoryId)  ){
								 int sortOrde = (Integer) catShopStructHashMap.get(mainCategoryId);
								 if(sortOrde == categoryOrder){
									//do nothing
									}else{
										updateCategorySortOrder(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);
									}
							}else{
									tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catShopStructHashMap);
									catShopStructHashMap.put(mainCategoryId,categoryOrder);
							}

							//End new addCategiry Main
						}
					}else{
						///new addCategory subcat2
						if(categoryHashMap.containsKey(subcat2Cd)){
							subCat2Id = (Integer) categoryHashMap.get(subcat2Cd);
						}else{
							log.info("Category Does not Exits in store Catalof catName=" + subcat2Cd + " store Catalog_id = " + storeCatalogId);
						}


						if (itemIdList.contains(subCat2Id)){
				            //do nothing
				        }else {
				        	itemIdList.add(subCat2Id);
				       }

						if(  catShopStructHashMap.containsKey(subCat2Id)  ){
							int sortOrde = (Integer) catShopStructHashMap.get(subCat2Id);
							 if(sortOrde == subCat2Order){
								//do nothing
								}else{
									updateCategorySortOrder(conn,catalogId,subCat2Id,subCat2Order,catalogloader);
								}
						}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(subCat2Id,subCat2Order);
							}
						//End new addCategiry Subcat2

						if(itemAssocCheck.containsKey(itemID)  ){
							int item2Id  = (Integer)  itemAssocCheck.get(itemID);
							if(item2Id == subCat2Id) {
							//do nothing
							}else{
							associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}
						}else{
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							itemAssocCheck.put(itemID,subCat2Id);
						}

				/*		itemAssocID = checkItemCatAssoc(conn,itemID,subCat2Id,catalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}else{
							associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						} */
						///new addCategory subcat1

						if(categoryHashMap.containsKey(subcat1Cd)){
							subCat1Id = (Integer) categoryHashMap.get(subcat1Cd);
						}else{
							log.info("Category Does not Exits in store Catalof catName=" + subcat1Cd + " store Catalog_id = " + storeCatalogId);
						}


						if (itemIdList.contains(subCat1Id)){
				            //do nothing
				        }else {
				        	itemIdList.add(subCat1Id);
				       }


						if(  catShopStructHashMap.containsKey(subCat1Id)  ){
								int sortOrde = (Integer) catShopStructHashMap.get(subCat1Id);
							 if(sortOrde == subCat1Order){
								//do nothing
								}else{
									updateCategorySortOrder(conn,catalogId,subCat1Id,subCat1Order,catalogloader);
								}
						}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(subCat1Id,subCat1Order);
							}
						//End new addCategiry Subcat1
						///new addCategory Main

						if(categoryHashMap.containsKey(categoryName)){
							mainCategoryId = (Integer) categoryHashMap.get(categoryName);
						}else{
							log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
						}

						if (itemIdList.contains(mainCategoryId)){
				            //do nothing
				        }else {
				        	itemIdList.add(mainCategoryId);
				       }

						if(  catShopStructHashMap.containsKey(mainCategoryId)  ){
							 int sortOrde = (Integer) catShopStructHashMap.get(mainCategoryId);
							 if(sortOrde == categoryOrder){
								//do nothing
								}else{
									updateCategorySortOrder(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);
								}
						}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(mainCategoryId,categoryOrder);
							}

					}
				}else{
					///new addCategory subcat3
					if(categoryHashMap.containsKey(subcat3Cd)){
						subCat3Id = (Integer) categoryHashMap.get(subcat3Cd);
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat3Cd + " store Catalog_id = " + storeCatalogId);
					}

					if (itemIdList.contains(subCat3Id)){
			            //do nothing
			        }else {
			        	itemIdList.add(subCat3Id);
			       }

					if(  catShopStructHashMap.containsKey(subCat3Id)  ){
							 int sortOrde = (Integer) catShopStructHashMap.get(subCat3Id);
							 if(sortOrde == subCat3Order){
								//do nothing
								}else{
									updateCategorySortOrder(conn,catalogId,subCat3Id,subCat3Order,catalogloader);
								}
						}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat3Id,subCat3Order,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(subCat3Id,categoryOrder);
						}
					//End new addCategiry Subcat3


					if(itemAssocCheck.containsKey(itemID)  ){
						int item2Id  = (Integer)  itemAssocCheck.get(itemID);
						if(item2Id == subCat3Id) {
						//do nothing
						}else{
							associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}
					}else{
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						itemAssocCheck.put(itemID,subCat3Id);
					}
				/*	itemAssocID = checkItemCatAssoc(conn,itemID,subCat3Id,catalogId);
					if(itemAssocID == 0){
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}else{
						associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}*/

					///new addCategory subcat2

					if(categoryHashMap.containsKey(subcat2Cd)){
						subCat2Id = (Integer) categoryHashMap.get(subcat2Cd);
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat2Cd + " store Catalog_id = " + storeCatalogId);
					}

					if (itemIdList.contains(subCat2Id)){
			            //do nothing
			        }else {
			        	itemIdList.add(subCat2Id);
			       }

					if(  catShopStructHashMap.containsKey(subCat2Id)  ){
							int sortOrde = (Integer) catShopStructHashMap.get(subCat2Id);
							if(sortOrde == subCat2Order){
								//do nothing
							}else{
								updateCategorySortOrder(conn,catalogId,subCat2Id,subCat2Order,catalogloader);
							}
						}else{
							tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catShopStructHashMap);
							catShopStructHashMap.put(subCat2Id,subCat2Order);
					}

					///new addCategory subcat1
					if(categoryHashMap.containsKey(subcat1Cd)){
						subCat1Id = (Integer) categoryHashMap.get(subcat1Cd);
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat1Cd + " store Catalog_id = " + storeCatalogId);
					}

					if (itemIdList.contains(subCat1Id)){
			            //do nothing
			        }else {
			        	itemIdList.add(subCat1Id);
			       }

					if(  catShopStructHashMap.containsKey(subCat1Id)  ){
							int sortOrde = (Integer) catShopStructHashMap.get(subCat1Id);
						 if(sortOrde == subCat1Order){
							//do nothing
							}else{
								updateCategorySortOrder(conn,catalogId,subCat1Id,subCat1Order,catalogloader);
							}
						}else{
							tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catShopStructHashMap);
							catShopStructHashMap.put(subCat1Id,subCat1Order);
						}

					//End new addCategiry Subcat1
					///new addCategory Main

					if(categoryHashMap.containsKey(categoryName)){
						mainCategoryId = (Integer) categoryHashMap.get(categoryName);
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
					}

					if (itemIdList.contains(mainCategoryId)){
			            //do nothing
			        }else {
			        	itemIdList.add(mainCategoryId);
			       }

					if(  catShopStructHashMap.containsKey(mainCategoryId)  ){
						 int sortOrde = (Integer) catShopStructHashMap.get(mainCategoryId);
						 if(sortOrde == categoryOrder){
							//do nothing
							}else{
								updateCategorySortOrder(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);
							}
						}else{
								tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catShopStructHashMap);
								catShopStructHashMap.put(mainCategoryId,categoryOrder);
						}
					//End new addCategiry Main
				}

			}
			pstmt.close();
			deleteShoppingCatStruct(conn,itemIdList,catalogId);
			long endTime = System.currentTimeMillis();
			log.info("createCatlogStructure That took " + (endTime - startTime) + " milliseconds catalogId  =" + catalogId + "accRefNum=" + accRefNum + "catalogKey=" + catalogKey);
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateShopCatalogStructure()=> "
                               + e.getMessage());
    	}
	}

public void deleteShoppingCatStruct(Connection conn,ArrayList itemIdList,int catalogId) throws RemoteException{
	log.info("delete from catalogstructure catalog_id ========================= " + catalogId);

//	String deleteShopCat = "delete from clw_catalog_structure where catalog_id = ? " +
//	"and item_id in(" + itemList + )";
	StringBuffer deleteSql = new StringBuffer();
	deleteSql.append("delete from clw_catalog_structure where catalog_id = ? and (item_id not in( ");

	StringBuffer deleteItemAssoc = new StringBuffer();
	deleteItemAssoc.append("delete from clw_item_assoc where catalog_id = ? and (item1_id not in( ");

	StringBuffer itemList = new StringBuffer();
	Iterator it = itemIdList.iterator();
	int ct = 0;
	while(it.hasNext()){
		ct++;
		itemList.append(it.next());
		if(ct > 990 || !it.hasNext()){
			//log.info("Deleting item Data from Shopping Catalog catalogId =" + catalogId + " and itemList ====" + itemList);

			try{
				//String deleteShopCat = "delete from clw_catalog_structure where catalog_id = ? " +
				//"and item_id not in(" + itemList + ")";
				if(it.hasNext()){
					deleteSql.append(itemList);
					deleteSql.append(") and item_id not in(");

					deleteItemAssoc.append(itemList);
					deleteItemAssoc.append(") and item1_id not in(");

				}else{
				deleteSql.append(itemList);
				deleteSql.append("))");
				String catStru = deleteSql.toString();
				PreparedStatement pstmt = conn.prepareStatement(catStru);
				pstmt.setInt(1,catalogId);
				//pstmt.setString(2,itemList);
				pstmt.executeUpdate();
				pstmt.close();
				log.info("Delete CatalogStructure==== ========= " + deleteSql);

				deleteItemAssoc.append(itemList);
				deleteItemAssoc.append("))");
				String itemAsso = deleteItemAssoc.toString();
/*				String deleteShopItemAssoc = "delete from clw_item_assoc where catalog_id = ? " +
				"and item1_id not in(" + itemList + ")";  */
				pstmt = conn.prepareStatement(itemAsso);
				pstmt.setInt(1,catalogId);
				pstmt.executeUpdate();
				pstmt.close();
				log.info("Delete Item Assoc =================== " + deleteItemAssoc);

				 }
			}
			catch(Exception e){
				e.printStackTrace();
				//throw e;
				   throw new RemoteException(
		                   "Error.IntegrationServicesBean.deleteShoppingCatStruct()=> "
		                           + e.getMessage());
			}
			itemList = new StringBuffer();
			ct = 0;
		}else{
			itemList.append(',');
		}
	}

	//String itemList = itemList.toString();
}

public void updateCategorySortOrder(Connection conn,int catalogId,int categoryId,int sortOrder,String catalogloader) throws RemoteException{
			String updateCat = "update clw_catalog_structure set sort_order = ?,mod_date=sysdate,mod_by=? " +
			"where catalog_id = ? and item_id = ? and catalog_structure_cd = ?";

			try{
				PreparedStatement pstmt = conn.prepareStatement(updateCat);
    			pstmt.setInt(1,sortOrder);
    			pstmt.setString(2,catalogloader);
    			pstmt.setInt(3,catalogId);
    			pstmt.setInt(4,categoryId);
    			pstmt.setString(5, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			pstmt.executeUpdate();
    			pstmt.close();
			}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateCategorySortOrder()=> "
                               + e.getMessage());
    	}
	}


        public void createCatlogStructureN(Connection conn,int busEntityId,int catalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum, String tmpTableName,HashMap itemIdHashMap) throws RemoteException{
           createCatlogStructureN( conn, busEntityId, catalogId, storeCatalogId, accRefNum, catalogKey, catalogloader,storeNum, tmpTableName, itemIdHashMap, null);
         }

      private void createCatlogStructureN(Connection conn,int busEntityId,int catalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum, String tmpTableName,HashMap itemIdHashMap, Map costCenterKeyToIdMap) throws RemoteException{
	log.info("Create or update CatalogStructureNNNNNN bus_entity_id = " + busEntityId + "catalog_id =" + catalogId + "AccountRefNum=" + accRefNum + "catalogKey= " + catalogKey);
	long startTime = System.currentTimeMillis();
	String selectSku = "select dist_sku,distributor,customer_sku,category_name,category_order,subcat1," +
	"subcat1_order,subcat2,subcat2_order,subcat3,subcat3_order, uom, cost_center_key " +
	"from "+tmpTableName+" "+
	"where account_ref_num = ? and catalog_key = ? and add_by = ?";

	String insertCatalogStruct = " insert into clw_catalog_structure(catalog_structure_id," +
	"catalog_id,bus_entity_id,catalog_structure_cd,item_id," +
	"customer_sku_num,eff_date,status_cd,add_date,add_by,mod_date,mod_by,cost_center_id,sort_order) " +
	"values(clw_catalog_structure_seq.nextval,?,?,?,?,?,sysdate,?,sysdate,?,sysdate,?,?,0)";

	String selectDist = "select distinct distributor from "+tmpTableName+ " where add_by = ?";

	String selectDistID = "select cbe.bus_entity_id	from clw_bus_entity cbe,clw_bus_entity_assoc cbea " +
	"where cbe.bus_entity_id = cbea.bus_entity1_id " +
	"and upper(cbe.short_desc) = upper(?) " +
	"and cbea.bus_entity2_id = ? " +
	"and cbe.bus_entity_type_cd = ?	" +
	"and cbe.bus_entity_status_cd = ?";

	Date runDate = new Date();
	HashMap catStructHashMap  = new HashMap();
	HashMap categoryHashMap  = new HashMap();

	try{
		 String uom = "";
		String distSku = "";
		String distributor = "";
		String customerSku = "";
		String categoryName = "";
                String costCenterKey = "";
                int categoryOrder = 0;
		String subcat1Cd = "";
		int subCat1Order = 0;
		String subcat2Cd = "";
		int subCat2Order = 0;
		String subcat3Cd = "";
		int subCat3Order = 0;
		int itemID = 0;
		int mainCategoryId = 0;
		int subCat1Id = 0;
		int subCat2Id = 0;
		int subCat3Id = 0;
		int distId = 0;

		String mcatO = "";
		String sub1O = "";
		String sub2O = "";
		String sub3O = "";

		HashMap distHashMap  = new HashMap();

		PreparedStatement pstmt = conn.prepareStatement(selectDist);
		pstmt.setString(1,catalogloader);
		ResultSet rs = pstmt.executeQuery();
		while(rs.next()){
			int distID = 0;
			String distName= rs.getString(1);
			PreparedStatement pstmt1 = conn.prepareStatement(selectDistID);
			pstmt1.setString(1, distName);
			pstmt1.setInt(2, storeNum);
			pstmt1.setString(3, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt1.setString(4, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
			ResultSet rs1 = pstmt1.executeQuery();
			while(rs1.next()){
				distID = rs1.getInt(1);
			}

			if(distID == 0){
				throw new IllegalArgumentException("Distributor Not FOund distName = " + distName + "storeID = " + storeNum);
			}
			pstmt1.close();

			if(distHashMap.containsKey(distName)  ){
				//do nothing
			}else{
				distHashMap.put(distName,distID);
			}

		}

		pstmt.close();

		pstmt = conn.prepareStatement(selectSku);
		pstmt.setString(1, accRefNum);
		pstmt.setString(2,catalogKey);
		pstmt.setString(3,catalogloader);
		rs = pstmt.executeQuery();



		while(rs.next()){
			distSku = rs.getString(1);
			distributor= rs.getString(2);
			customerSku = rs.getString(3);
			categoryName = rs.getString(4);
			mcatO = rs.getString(5);
			subcat1Cd = rs.getString(6);
			sub1O = rs.getString(7);
			subcat2Cd = rs.getString(8);
			sub2O = rs.getString(9);
			subcat3Cd = rs.getString(10);
			sub3O = rs.getString(11);
			 uom = rs.getString(12);
                         costCenterKey = rs.getString(13);
                         int costCenterId = (costCenterKeyToIdMap!=null && costCenterKeyToIdMap.get(costCenterKey)!= null)? ((Integer)costCenterKeyToIdMap.get(costCenterKey)).intValue() : 0;
			if(mcatO != null){
				categoryOrder = Integer.parseInt(mcatO);
			}

			if(sub1O != null){
				subCat1Order = Integer.parseInt(sub1O);
			}

			if(sub2O != null){
				subCat2Order = Integer.parseInt(sub2O);
			}

			if(sub3O != null){
				subCat3Order = Integer.parseInt(sub3O);
			}

			if(itemIdHashMap.containsKey(distSku)){
				itemID = (Integer)  itemIdHashMap.get(distSku);
			}else{
				itemID = getItemId(conn, distSku,distributor,uom,storeNum );
			}
			//itemID = getItemId(conn, distSku,distributor,uom,storeNum );//getItemId(conn,distSku,uom,storeNum);

			if(distHashMap.containsKey(distributor)  ){
				distId  = (Integer)  distHashMap.get(distributor);
			}else{
				distId = getDistId(conn,distributor,storeNum);
			}


			pstmt = conn.prepareStatement(insertCatalogStruct);
			pstmt.setInt(1,catalogId);
			pstmt.setInt(2,distId);
			pstmt.setString(3,RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
			pstmt.setInt(4,itemID);
			pstmt.setString(5,customerSku);
			pstmt.setString(6,RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
			pstmt.setString(7,catalogloader);
			pstmt.setString(8,catalogloader);
                        pstmt.setInt(9, costCenterId);
			pstmt.executeUpdate();
			pstmt.close();

			HashMap tempHashMap  = new HashMap();
			HashMap tempSortHashMap  = new HashMap();

			int itemAssocID = 0;
			int sortOrder = 0;
			if(subcat3Cd == null){
				if(subcat2Cd == null){
					if(subcat1Cd == null){
						//associate Main Category
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap, costCenterId);
						if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
							mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    		}else{
			    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
			    		}

						///new addCategory Main
						if(  catStructHashMap.containsKey(mainCategoryId)  ){
			//					log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap, costCenterId);
						int sortOrd0 = 0;
						if( catStructHashMap.containsKey(mainCategoryId)  ){
							sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

			    		}else{
			 //   			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
			    			catStructHashMap.put(mainCategoryId,sortOrd0);
			    		}
			//			log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
						}

						//End new addCategiry Main

						associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}else{
						//associate sub cat 1
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap, costCenterId);
						if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
							subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
			    		}else{
			    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
			    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
			    		}
						///new addCategory subcat1
						if(  catStructHashMap.containsKey(subCat1Id)  ){
								log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap, costCenterId);
						int sortOrd1 = 0;
						if( catStructHashMap.containsKey(subCat1Id)  ){
							sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

			    		}else{
		//	    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
			    			catStructHashMap.put(subCat1Id,sortOrd1);
			    		}
					//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
						}

						//End new addCategiry Subcat1

						associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						//Check Main Category and subcat1 Association
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap, costCenterId);
						if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
							mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    		}else{
			    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
			    		}

						///new addCategory Main
						if(  catStructHashMap.containsKey(mainCategoryId)  ){
//								log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap, costCenterId);
						int sortOrd0 = 0;
						if( catStructHashMap.containsKey(mainCategoryId)  ){
							sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

			    		}else{
//			    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
			    			catStructHashMap.put(mainCategoryId,sortOrd0);
			    		}
//						log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
						}

						//End new addCategiry Main
					}
				}else{
					//associate sub cat 2
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,categoryHashMap, costCenterId);
					if(  categoryHashMap.containsKey(subcat2Cd.toUpperCase())  ){
						subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
		    		}else{
		    			subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
		    			categoryHashMap.put(subcat2Cd.toUpperCase(),subCat2Id);
		    		}
				///new addCategory subcat2
					if(  catStructHashMap.containsKey(subCat2Id)  ){
		//					log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat2Id);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catStructHashMap, costCenterId);
					int sortOrd2 = 0;
					if( catStructHashMap.containsKey(subCat2Id)  ){
						sortOrd2  = (Integer)  tempSortHashMap.get(subCat2Id);

		    		}else{
		  //  			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat2Id);
		    			catStructHashMap.put(subCat2Id,sortOrd2);
		    		}
		//			log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat2Id + "/" + sortOrd2);
					}

					//End new addCategiry Subcat2


					associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);

					//NEWWW METHOD ALTERNATE subcat1
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap, costCenterId);
					if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
						subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
		    		}else{
		    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
		    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
		    		}
//					log.info("subcat1111111 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat11111IDDDD = " + subCat1Id);

					///new addCategory subcat1
					if(  catStructHashMap.containsKey(subCat1Id)  ){
//							log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap, costCenterId);
					int sortOrd1 = 0;
					if( catStructHashMap.containsKey(subCat1Id)  ){
						sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

		    		}else{
	//	    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
		    			catStructHashMap.put(subCat1Id,sortOrd1);
		    		}
				//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
					}

					//NEWWW METHOD ALTERNATE Main Cat
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap, costCenterId);
					if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
						mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
		    		}else{
		    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
		    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
		    		}

					///new addCategory Main
					if(  catStructHashMap.containsKey(mainCategoryId)  ){
			//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap, costCenterId);
					int sortOrd0 = 0;
					if( catStructHashMap.containsKey(mainCategoryId)  ){
						sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

		    		}else{
		    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
		    			catStructHashMap.put(mainCategoryId,sortOrd0);
		    		}
			//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
					}

					//End new addCategiry Main
			//		log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 22222222222 subCat2Id = " + subCat2Id);
				}
			}else{
				//associate sub cat 3
				tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,categoryHashMap, costCenterId);
				if(  categoryHashMap.containsKey(subcat3Cd.toUpperCase())  ){
					subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
	    		}else{
	    			subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
	    			categoryHashMap.put(subcat3Cd.toUpperCase(),subCat3Id);
	    		}
				///new addCategory subcat3
				if(  catStructHashMap.containsKey(subCat3Id)  ){
		//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat3Id);
				}else{
				tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat3Id,subCat3Order,catalogloader,catStructHashMap, costCenterId);
				int sortOrd3 = 0;
				if( catStructHashMap.containsKey(subCat3Id)  ){
					sortOrd3  = (Integer)  tempSortHashMap.get(subCat3Id);

	    		}else{
	    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat3Id);
	    			catStructHashMap.put(subCat3Id,sortOrd3);
	    		}
		//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat3Id + "/" + sortOrd3);
				}

				//End new addCategiry Subcat3


				associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
				//NEWWW METHOD ALTERNATE subcat2
				tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,categoryHashMap, costCenterId);
				if(  categoryHashMap.containsKey(subcat2Cd.toUpperCase())  ){
					subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
	    		}else{
	    			subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
	    			categoryHashMap.put(subcat2Cd.toUpperCase(),subCat2Id);
	    		}
				///new addCategory subcat2
				if(  catStructHashMap.containsKey(subCat2Id)  ){
			//			log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat2Id);
				}else{
				tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catStructHashMap, costCenterId);
				int sortOrd2 = 0;
				if( catStructHashMap.containsKey(subCat2Id)  ){
					sortOrd2  = (Integer)  tempSortHashMap.get(subCat2Id);

	    		}else{
	    	//		log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat2Id);
	    			catStructHashMap.put(subCat2Id,sortOrd2);
	    		}
			//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat2Id + "/" + sortOrd2);
				}

				//End new addCategiry Subcat2

				tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap, costCenterId);
				if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
					subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
	    		}else{
	    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
	    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
	    		}
			///new addCategory subcat1
				if(  catStructHashMap.containsKey(subCat1Id)  ){
			//			log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
				}else{
				tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap, costCenterId);
				int sortOrd1 = 0;
				if( catStructHashMap.containsKey(subCat1Id)  ){
					sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

	    		}else{
	    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
	    			catStructHashMap.put(subCat1Id,sortOrd1);
	    		}
			//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
				}

				//End new addCategiry Subcat1
				tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap, costCenterId);
				if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
					mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
	    		}else{
	    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
	    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
	    		}
				///new addCategory Main
				if(  catStructHashMap.containsKey(mainCategoryId)  ){
		//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
				}else{
				tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap, costCenterId);
				int sortOrd0 = 0;
				if( catStructHashMap.containsKey(mainCategoryId)  ){
					sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

	    		}else{
	    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
	    			catStructHashMap.put(mainCategoryId,sortOrd0);
	    		}
		//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
				}

				//End new addCategiry Main
			}

		}
		pstmt.close();
		long endTime = System.currentTimeMillis();
		log.info("createCatlogStructureNNN That took " + (endTime - startTime) + " milliseconds catalogId  =" + catalogId + "accRefNum=" + accRefNum + "catalogKey=" + catalogKey);
	}catch(Exception e){
		e.printStackTrace();
		//throw e;
		   throw new RemoteException(
                   "Error.IntegrationServicesBean.createCatlogStructureN()=> "
                           + e.getMessage());
	}
}

      public void createCatlogStructure(Connection conn,int busEntityId,int catalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum, String tmpTableName) throws RemoteException{
        createCatlogStructure( conn, busEntityId, catalogId, storeCatalogId, accRefNum, catalogKey, catalogloader,storeNum, tmpTableName, null);
      }


	private void createCatlogStructure(Connection conn,int busEntityId,int catalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum, String tmpTableName, Map costCenterKeyToIdMap) throws RemoteException{
		log.info("Create or update Catalog Structure bus_entity_id = " + busEntityId + "catalog_id =" + catalogId);
		long startTime = System.currentTimeMillis();
		String selectSku = "select dist_sku,distributor,customer_sku,category_name,category_order,subcat1," +
		"subcat1_order,subcat2,subcat2_order,subcat3,subcat3_order, uom, cost_center_key " +
		"from "+tmpTableName+" "+
		"where account_ref_num = ? and catalog_key = ? and add_by = ?";

		String insertCatalogStruct = " insert into clw_catalog_structure(catalog_structure_id," +
		"catalog_id,bus_entity_id,catalog_structure_cd,item_id," +
		"customer_sku_num,eff_date,status_cd,add_date,add_by,mod_date,mod_by,cost_center_id,sort_order) " +
		"values(clw_catalog_structure_seq.nextval,?,?,?,?,?,sysdate,?,sysdate,?,sysdate,?,?,0)";

		String selectDist = "select distinct distributor from "+tmpTableName+ " where add_by = ?";

		String selectDistID = "select cbe.bus_entity_id	from clw_bus_entity cbe,clw_bus_entity_assoc cbea " +
		"where cbe.bus_entity_id = cbea.bus_entity1_id " +
		"and upper(cbe.short_desc) = upper(?) " +
		"and cbea.bus_entity2_id = ? " +
		"and cbe.bus_entity_type_cd = ?	" +
		"and cbe.bus_entity_status_cd = ?";

		//log.info("FROM CATALOG STRUCTUREEEEEEEEEEE catalog_id = " + catalogId);

		Date runDate = new Date();
		HashMap catStructHashMap  = new HashMap();
		HashMap categoryHashMap  = new HashMap();

		try{
			 String uom = "";
			String distSku = "";
			String distributor = "";
			String customerSku = "";
			String categoryName = "";
                        String costCenterKey = "";
			int categoryOrder = 0;
			String subcat1Cd = "";
			int subCat1Order = 0;
			String subcat2Cd = "";
			int subCat2Order = 0;
			String subcat3Cd = "";
			int subCat3Order = 0;
			int itemID = 0;
			int mainCategoryId = 0;
			int subCat1Id = 0;
			int subCat2Id = 0;
			int subCat3Id = 0;
			int distId = 0;

			String mcatO = "";
			String sub1O = "";
			String sub2O = "";
			String sub3O = "";

			HashMap distHashMap  = new HashMap();

			PreparedStatement pstmt = conn.prepareStatement(selectDist);
			pstmt.setString(1,catalogloader);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				int distID = 0;
				String distName= rs.getString(1);
				PreparedStatement pstmt1 = conn.prepareStatement(selectDistID);
				pstmt1.setString(1, distName);
				pstmt1.setInt(2, storeNum);
				pstmt1.setString(3, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
				pstmt1.setString(4, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
				ResultSet rs1 = pstmt1.executeQuery();
				while(rs1.next()){
					distID = rs1.getInt(1);
				}

				if(distID == 0){
					throw new IllegalArgumentException("Distributor Not FOund distName = " + distName + "storeID = " + storeNum);
				}
				pstmt1.close();

				if(distHashMap.containsKey(distName)  ){
					//do nothing
				}else{
					distHashMap.put(distName,distID);
				}

			}

			pstmt.close();

			pstmt = conn.prepareStatement(selectSku);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2,catalogKey);
			pstmt.setString(3,catalogloader);
			rs = pstmt.executeQuery();



			while(rs.next()){
				distSku = rs.getString(1);
				distributor= rs.getString(2);
				customerSku = rs.getString(3);
				categoryName = rs.getString(4);
			//	categoryOrder = Integer.parseInt(rs.getString(5));
				mcatO = rs.getString(5);
				subcat1Cd = rs.getString(6);
			//	subCat1Order = Integer.parseInt(rs.getString(7));
				sub1O = rs.getString(7);
				subcat2Cd = rs.getString(8);
		//		subCat2Order = Integer.parseInt(rs.getString(9));
				sub2O = rs.getString(9);
				subcat3Cd = rs.getString(10);
		//		subCat3Order = Integer.parseInt(rs.getString(11));
				sub3O = rs.getString(11);
				 uom = rs.getString(12);
                                 costCenterKey = rs.getString(13);
                                 int costCenterId = (costCenterKeyToIdMap!=null && costCenterKeyToIdMap.get(costCenterKey)!= null)? ((Integer)costCenterKeyToIdMap.get(costCenterKey)).intValue() : 0;

				if(mcatO != null){
					categoryOrder = Integer.parseInt(mcatO);
				}

				if(sub1O != null){
					subCat1Order = Integer.parseInt(sub1O);
				}

				if(sub2O != null){
					subCat2Order = Integer.parseInt(sub2O);
				}

				if(sub3O != null){
					subCat3Order = Integer.parseInt(sub3O);
				}


			//	log.info("FROM CATALOG STRUCTUREEEEEEEEEEE distSku = " + distSku);
				itemID = getItemId(conn, distSku,distributor,uom,storeNum );//getItemId(conn,distSku,uom,storeNum);

				if(distHashMap.containsKey(distributor)  ){
					distId  = (Integer)  distHashMap.get(distributor);
				}else{
					distId = getDistId(conn,distributor,storeNum);
				}


		/*		CatalogStructureData catalogStructureData = CatalogStructureData.createValue();

				catalogStructureData.setCatalogId(catalogId);
				catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
				catalogStructureData.setBusEntityId(distId);
				catalogStructureData.setItemId(itemID);
				catalogStructureData.setCustomerSkuNum(customerSku);
				catalogStructureData.setEffDate(runDate);
				catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
				catalogStructureData.setAddBy(catalogloader);
				CatalogStructureDataAccess.insert(conn, catalogStructureData); */

				pstmt = conn.prepareStatement(insertCatalogStruct);
				pstmt.setInt(1,catalogId);
				pstmt.setInt(2,distId);
				pstmt.setString(3,RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
				pstmt.setInt(4,itemID);
				pstmt.setString(5,customerSku);
				pstmt.setString(6,RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
				pstmt.setString(7,catalogloader);
				pstmt.setString(8,catalogloader);
                                pstmt.setInt(9, costCenterId);
				pstmt.executeUpdate();
				pstmt.close();

				HashMap tempHashMap  = new HashMap();
				HashMap tempSortHashMap  = new HashMap();



				int itemAssocID = 0;
				int sortOrder = 0;
				if(subcat3Cd == null){
					if(subcat2Cd == null){
						if(subcat1Cd == null){
							//associate Main Category
			//				mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,categoryOrder);
							//NEWWW METHOD ALTERNATE Main Cat
			//				int CatID0 = 0;
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap, costCenterId);
							if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
								mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
				    		}else{
				    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
				    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
				    		}
				//			log.info("subcat Main TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat Main IDDDD = " + mainCategoryId);

					//--		addCategoryCatalogStructure(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);

							///new addCategory Main
							if(  catStructHashMap.containsKey(mainCategoryId)  ){
				//					log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
							}else{
							tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap,costCenterId);
							int sortOrd0 = 0;
							if( catStructHashMap.containsKey(mainCategoryId)  ){
								sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

				    		}else{
				 //   			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
				    			catStructHashMap.put(mainCategoryId,sortOrd0);
				    		}
				//			log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
							}

							//End new addCategiry Main

							associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
				/*temp			itemAssocID = checkItemCatAssoc(conn,itemID,mainCategoryId,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							} temp*/
						//	log.info("CCCCCCCAAAAAAAATTTTTTTT associate Main Category mainCategoryId = " + mainCategoryId);
						}else{
							//associate sub cat 1
			//				subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order);
							//NEWWW METHOD ALTERNATE subcat1
			//				int CatID1 = 0;
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap,costCenterId);
							if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
								subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
				    		}else{
				    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
				    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
				    		}
			//				log.info("subcat1111111 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat11111IDDDD = " + subCat1Id);


				//--			addCategoryCatalogStructure(conn,catalogId,subCat1Id,subCat1Order,catalogloader);

							///new addCategory subcat1
							if(  catStructHashMap.containsKey(subCat1Id)  ){
									log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
							}else{
							tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap,costCenterId);
							int sortOrd1 = 0;
							if( catStructHashMap.containsKey(subCat1Id)  ){
								sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

				    		}else{
			//	    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
				    			catStructHashMap.put(subCat1Id,sortOrd1);
				    		}
						//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
							}

							//End new addCategiry Subcat1

							associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
				/*temp			itemAssocID = checkItemCatAssoc(conn,itemID,subCat1Id,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							} temp*/
							//Check Main Category and subcat1 Association
				//			mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,categoryOrder);

							//NEWWW METHOD ALTERNATE Main Cat
				//			int CatID0 = 0;
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap,costCenterId);
							if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
								mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
				    		}else{
				    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
				    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
				    		}
		//					log.info("subcat Main TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat Main IDDDD = " + mainCategoryId);

					//--		addCategoryCatalogStructure(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);
		//					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1Id = " + subCat1Id);

							///new addCategory Main
							if(  catStructHashMap.containsKey(mainCategoryId)  ){
	//								log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
							}else{
							tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap,costCenterId);
							int sortOrd0 = 0;
							if( catStructHashMap.containsKey(mainCategoryId)  ){
								sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

				    		}else{
	//			    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
				    			catStructHashMap.put(mainCategoryId,sortOrd0);
				    		}
	//						log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
							}

							//End new addCategiry Main
						}
					}else{
						//associate sub cat 2
				//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat2Cd);
				//		log.info("subcat22222 start +++++++++++++++++++++++++++++ ");
				//		subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order);
				//		log.info("subcat22222 end +++++++++++++++++++++++++++++ subcat222222IDDDD = " + subCat2Id);
						//NEWWW METHOD ALTERNATE subcat2
				//		int CatID2 = 0;
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,categoryHashMap,costCenterId);
						if(  categoryHashMap.containsKey(subcat2Cd.toUpperCase())  ){
							subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
			    		}else{
			    			subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
			    			categoryHashMap.put(subcat2Cd.toUpperCase(),subCat2Id);
			    		}
		//				log.info("subcat22222 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat222222IDDDD = " + subCat2Id);
						///
					//--	addCategoryCatalogStructure(conn,catalogId,subCat2Id,subCat2Order,catalogloader);
					//--	log.info("METHOD SUBCAT2 ID/sortorder check old = " + subCat2Id + "/" + subCat2Order);


						///new addCategory subcat2
						if(  catStructHashMap.containsKey(subCat2Id)  ){
			//					log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat2Id);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catStructHashMap,costCenterId);
						int sortOrd2 = 0;
						if( catStructHashMap.containsKey(subCat2Id)  ){
							sortOrd2  = (Integer)  tempSortHashMap.get(subCat2Id);

			    		}else{
			  //  			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat2Id);
			    			catStructHashMap.put(subCat2Id,sortOrd2);
			    		}
			//			log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat2Id + "/" + sortOrd2);
						}

						//End new addCategiry Subcat2


						associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
				/*temp		itemAssocID = checkItemCatAssoc(conn,itemID,subCat2Id,catalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}else{
							associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}temp*/

						//Check subcat1 and subcat2 Association
			//			log.info("subcat1111 start +++++++++++++++++++++++++++++");
				//		subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order);
		//				log.info("subcat1111 end +++++++++++++++++++++++++++++" + subCat1Id);

						//NEWWW METHOD ALTERNATE subcat1
			//			int CatID1 = 0;
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap,costCenterId);
						if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
							subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
			    		}else{
			    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
			    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
			    		}
//						log.info("subcat1111111 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat11111IDDDD = " + subCat1Id);

				//--		addCategoryCatalogStructure(conn,catalogId,subCat1Id,subCat1Order,catalogloader);

						///new addCategory subcat1
						if(  catStructHashMap.containsKey(subCat1Id)  ){
	//							log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap,costCenterId);
						int sortOrd1 = 0;
						if( catStructHashMap.containsKey(subCat1Id)  ){
							sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

			    		}else{
		//	    			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
			    			catStructHashMap.put(subCat1Id,sortOrd1);
			    		}
					//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
						}

						//End new addCategiry Subcat1

						//Check Main Category and subcat1 Association
			//			log.info("subcat Main start +++++++++++++++++++++++++++++");
			//			mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,categoryOrder);
			//			log.info("subcat Main End +++++++++++++++++++++++++++++" + mainCategoryId);

						//NEWWW METHOD ALTERNATE Main Cat
			//			int CatID0 = 0;
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap,costCenterId);
						if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
							mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    		}else{
			    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
			    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
			    		}
			//			log.info("subcat Main TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat Main IDDDD = " + mainCategoryId);


				//-		addCategoryCatalogStructure(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);

						///new addCategory Main
						if(  catStructHashMap.containsKey(mainCategoryId)  ){
				//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
						}else{
						tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap,costCenterId);
						int sortOrd0 = 0;
						if( catStructHashMap.containsKey(mainCategoryId)  ){
							sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

			    		}else{
			    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
			    			catStructHashMap.put(mainCategoryId,sortOrd0);
			    		}
				//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
						}

						//End new addCategiry Main
				//		log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 22222222222 subCat2Id = " + subCat2Id);
					}
				}else{
					//associate sub cat 3
			//		subCat3Id = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order);

					//NEWWW METHOD ALTERNATE subcat3
			//		int CatID3 = 0;
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,categoryHashMap,costCenterId);
					if(  categoryHashMap.containsKey(subcat3Cd.toUpperCase())  ){
						subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
		    		}else{
		    			subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
		    			categoryHashMap.put(subcat3Cd.toUpperCase(),subCat3Id);
		    		}
			//		log.info("subcat22222 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat222222IDDDD = " + subCat3Id);


		//--			addCategoryCatalogStructure(conn,catalogId,subCat3Id,subCat3Order,catalogloader);


					///new addCategory subcat3
					if(  catStructHashMap.containsKey(subCat3Id)  ){
			//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat3Id);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat3Id,subCat3Order,catalogloader,catStructHashMap,costCenterId);
					int sortOrd3 = 0;
					if( catStructHashMap.containsKey(subCat3Id)  ){
						sortOrd3  = (Integer)  tempSortHashMap.get(subCat3Id);

		    		}else{
		    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat3Id);
		    			catStructHashMap.put(subCat3Id,sortOrd3);
		    		}
			//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat3Id + "/" + sortOrd3);
					}

					//End new addCategiry Subcat3


					associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
	/*temp			itemAssocID = checkItemCatAssoc(conn,itemID,subCat3Id,catalogId);
					if(itemAssocID == 0){
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}else{
						associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}temp*/
		//			subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order);

					//NEWWW METHOD ALTERNATE subcat2
		//			int CatID2 = 0;
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,categoryHashMap,costCenterId);
					if(  categoryHashMap.containsKey(subcat2Cd.toUpperCase())  ){
						subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
		    		}else{
		    			subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
		    			categoryHashMap.put(subcat2Cd.toUpperCase(),subCat2Id);
		    		}
			//		log.info("subcat22222 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat222222IDDDD = " + subCat2Id);

			//--		addCategoryCatalogStructure(conn,catalogId,subCat2Id,subCat2Order,catalogloader);


					///new addCategory subcat2
					if(  catStructHashMap.containsKey(subCat2Id)  ){
				//			log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat2Id);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat2Id,subCat2Order,catalogloader,catStructHashMap,costCenterId);
					int sortOrd2 = 0;
					if( catStructHashMap.containsKey(subCat2Id)  ){
						sortOrd2  = (Integer)  tempSortHashMap.get(subCat2Id);

		    		}else{
		    	//		log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat2Id);
		    			catStructHashMap.put(subCat2Id,sortOrd2);
		    		}
				//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat2Id + "/" + sortOrd2);
					}

					//End new addCategiry Subcat2



					//Check subcat1 and subcat2 Association
			//		subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order);

					//NEWWW METHOD ALTERNATE subcat1
			//		int CatID1 = 0;
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap,costCenterId);
					if(  categoryHashMap.containsKey(subcat1Cd.toUpperCase())  ){
						subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
		    		}else{
		    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd.toUpperCase());
		    			categoryHashMap.put(subcat1Cd.toUpperCase(),subCat1Id);
		    		}
			//		log.info("subcat1111111 TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat11111IDDDD = " + subCat1Id);

			//--		addCategoryCatalogStructure(conn,catalogId,subCat1Id,subCat1Order,catalogloader);


					///new addCategory subcat1
					if(  catStructHashMap.containsKey(subCat1Id)  ){
				//			log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + subCat1Id);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,subCat1Id,subCat1Order,catalogloader,catStructHashMap,costCenterId);
					int sortOrd1 = 0;
					if( catStructHashMap.containsKey(subCat1Id)  ){
						sortOrd1  = (Integer)  tempSortHashMap.get(subCat1Id);

		    		}else{
		    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + subCat1Id);
		    			catStructHashMap.put(subCat1Id,sortOrd1);
		    		}
				//	log.info("METHOD SUBCAT2 ID/sortorder check new = " + subCat1Id + "/" + sortOrd1);
					}

					//End new addCategiry Subcat1



					//Check Main Category and subcat1 Association
			//		mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,categoryOrder);
					//NEWWW METHOD ALTERNATE Main Cat
			//		int CatID0 = 0;
					tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap,costCenterId);
					if(  categoryHashMap.containsKey(categoryName.toUpperCase())  ){
						mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
		    		}else{
		    			mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
		    			categoryHashMap.put(categoryName.toUpperCase(),mainCategoryId);
		    		}
			//		log.info("subcat Main TOOOOOO CHECKKKKKKK +++++++++++++++++++++++++++++ subcat Main IDDDD = " + mainCategoryId);

			//--		addCategoryCatalogStructure(conn,catalogId,mainCategoryId,categoryOrder,catalogloader);

					///new addCategory Main
					if(  catStructHashMap.containsKey(mainCategoryId)  ){
			//				log.info("Itemmmmmmm Already in catalog so don't do anything Catalog_id =" + catalogId + "categoryId= " + mainCategoryId);
					}else{
					tempSortHashMap = addCategoryCatalogStructureN(conn,catalogId,mainCategoryId,categoryOrder,catalogloader,catStructHashMap,costCenterId);
					int sortOrd0 = 0;
					if( catStructHashMap.containsKey(mainCategoryId)  ){
						sortOrd0  = (Integer)  tempSortHashMap.get(mainCategoryId);

		    		}else{
		    //			log.info("Sort Orderrrrrrrrrrrrrrrrrrrrrrrrrr catid = " + catalogId + "category_id = " + mainCategoryId);
		    			catStructHashMap.put(mainCategoryId,sortOrd0);
		    		}
			//		log.info("METHOD SUBCAT2 ID/sortorder check new = " + mainCategoryId + "/" + sortOrd0);
					}

					//End new addCategiry Main

//					log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 333333333333 subCat3Id = " + subCat3Id);
				}

			}
			pstmt.close();
			long endTime = System.currentTimeMillis();
			log.info("createCatlogStructure That took " + (endTime - startTime) + " milliseconds catalogId  =" + catalogId + "accRefNum=" + accRefNum + "catalogKey=" + catalogKey);
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createCatlogStructure()=> "
                               + e.getMessage());
    	}
	}
public HashMap addCategoryCatalogStructureN(Connection conn,int catalogId,int categoryId,int sortOrder,String catalogloader,HashMap catStructHashMap) throws RemoteException{
  return addCategoryCatalogStructureN( conn, catalogId, categoryId, sortOrder, catalogloader, catStructHashMap, 0) ;
}
private HashMap addCategoryCatalogStructureN(Connection conn,int catalogId,int categoryId,int sortOrder,String catalogloader,HashMap catStructHashMap, int costCenterId) throws RemoteException{
		log.info("AddCategoryCatalogStructure New Start catalog_id = " + catalogId);
		Date runDate = new Date();

		String selectCatalogItem = "select item_id,sort_order from clw_catalog_structure where catalog_id = ? " +
		"and item_id = ?";

		//String selectCatalogItem = "select count(*) from clw_catalog_structure where catalog_id = ? " +
		//		"and item_id = ?";

		String updateCategoryOrder = "UPDATE CLW_CATALOG_STRUCTURE set sort_order = ?,mod_date=sysdate," +
		"mod_by = ?, cost_center_id =? where item_id = ? and catalog_id = ? and catalog_structure_cd = ?";
		int itemId = 0;
		int sortOrd = 0;
		try{
			if( catStructHashMap.containsKey(categoryId)  ){
    			//categoryId  = (Integer)  categoryHashMap.get(catName);
    			log.info("HashMapppppppppppppppppppQQQQQQQQQQQQQQQQ:" + categoryId + "catalogid=" + catalogId);
   			}else{
			PreparedStatement pstmt = conn.prepareStatement(selectCatalogItem);
			pstmt.setInt(1, catalogId);
			pstmt.setInt(2, categoryId);
			ResultSet rs = pstmt.executeQuery();
		//	int count = 0;
			while(rs.next()){
				//count = rs.getInt(1);
				itemId = rs.getInt(1);
				sortOrd = rs.getInt(2);
			}
			pstmt.close();

			if(itemId == 0){
			CatalogStructureData catalogStructureData = CatalogStructureData.createValue();
			catalogStructureData.setCatalogId(catalogId);
			catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
			catalogStructureData.setItemId(categoryId);
			catalogStructureData.setEffDate(runDate);
			catalogStructureData.setSortOrder(sortOrder);
                        catalogStructureData.setCostCenterId(costCenterId);
			catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
			catalogStructureData.setAddBy(catalogloader);

			CatalogStructureDataAccess.insert(conn, catalogStructureData);
   			catStructHashMap.put(categoryId,sortOrder);

			}

			if(itemId > 0){

	   			catStructHashMap.put(categoryId,sortOrder);

				if(itemId == categoryId && sortOrd == sortOrder) {
				}else{
				pstmt = conn.prepareStatement(updateCategoryOrder);
    			pstmt.setInt(1,sortOrder);
    			pstmt.setString(2,catalogloader);
                        pstmt.setInt(3,costCenterId);
    			pstmt.setInt(4,categoryId);
    			pstmt.setInt(5,catalogId);
    			pstmt.setString(6, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			pstmt.executeUpdate();
    			pstmt.close();
				}
			}
   			}
			return catStructHashMap;

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.addCategoryCatalogStructureN()=> "
                               + e.getMessage());
    	}
	}

	public void addCategoryCatalogStructure(Connection conn,int catalogId,int categoryId,int sortOrder,String catalogloader) throws RemoteException{
		log.info("AddCategoryCatalogStructure Start ==" + catalogId);
		Date runDate = new Date();

		String selectCatalogItem = "select item_id,sort_order from clw_catalog_structure where catalog_id = ? " +
				"and item_id = ?";

		//String selectCatalogItem = "select count(*) from clw_catalog_structure where catalog_id = ? " +
		//		"and item_id = ?";

		String updateCategoryOrder = "UPDATE CLW_CATALOG_STRUCTURE set sort_order = ?,mod_date=sysdate," +
		"mod_by = ? where item_id = ? and catalog_id = ? and catalog_structure_cd = ?";
		int itemId = 0;
		int sortOrd = 0;
		try{

			PreparedStatement pstmt = conn.prepareStatement(selectCatalogItem);
			pstmt.setInt(1, catalogId);
			pstmt.setInt(2, categoryId);
			ResultSet rs = pstmt.executeQuery();
		//	int count = 0;
			while(rs.next()){
				//count = rs.getInt(1);
				itemId = rs.getInt(1);
				sortOrd = rs.getInt(2);
			}
			pstmt.close();

		/*	pstmt = conn.prepareStatement(selectCatalogItem1);
			pstmt.setInt(1, catalogId);
			pstmt.setInt(2, categoryId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				itemId = rs.getInt(1);
				sortOrd = rs.getInt(2);
				log.info("New Method itemId = " + itemId + "Sort Order=" + sortOrd + "catalog_id =" + catalogId);
			}

			if(itemId == 0){
				log.info("New Method itemId is nULL + item_id = " + itemId + "catalog_id =  " + catalogId + "sortordr =" + sortOrd);
			}
			pstmt.close(); */

			if(itemId == 0){
			CatalogStructureData catalogStructureData = CatalogStructureData.createValue();
			catalogStructureData.setCatalogId(catalogId);
			catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
			catalogStructureData.setItemId(categoryId);
			catalogStructureData.setEffDate(runDate);
			catalogStructureData.setSortOrder(sortOrder);
			catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
			catalogStructureData.setAddBy(catalogloader);

			CatalogStructureDataAccess.insert(conn, catalogStructureData);
			}

			if(itemId > 0){
				if(itemId == categoryId && sortOrd == sortOrder) {
					log.info("Don't have to do anything ------------ ");
				}else{
				log.info("BBB CHECK AND CREATE CATEGORY FOUND CATEGORYYYYYYY UPDATE SORT ORDER sort_order =" + sortOrder + "catalog_id = " + catalogId + " category_id = " + categoryId);
				pstmt = conn.prepareStatement(updateCategoryOrder);
    			pstmt.setInt(1,sortOrder);
    			pstmt.setString(2,catalogloader);
    			pstmt.setInt(3,categoryId);
    			pstmt.setInt(4,catalogId);
    			pstmt.setString(5, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    			pstmt.executeUpdate();
    			pstmt.close();
			}
		}

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.addCategoryCatalogStructure()=> "
                               + e.getMessage());
    	}
	}

        public void updateAccountCatalogStructureN(Connection conn,int accountCatalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName,HashMap itemIdHashMap) throws RemoteException{
          updateAccountCatalogStructureN( conn, accountCatalogId, storeCatalogId, accRefNum, catalogKey, catalogloader, storeNum, tmpTableName,itemIdHashMap, null);
        }

	private void updateAccountCatalogStructureN(Connection conn,int accountCatalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName,HashMap itemIdHashMap, Map costCenterKeyToIdMap) throws RemoteException{
		log.info("UpdateAccountCatalogStructureN Start");

		String selectSku = "select dist_sku,distributor,customer_sku,upper(category_name),category_order,upper(subcat1)," +
		"subcat1_order,upper(subcat2),subcat2_order,upper(subcat3),subcat3_order, uom, cost_center_key " +
		"from " + tmpTableName + " "  +
		"where account_ref_num = ? and catalog_key = ? and add_by = ? ";

		String selectAccCatStructItems = "select item_id,sort_order,cost_center_id from clw_catalog_structure " +
			"where catalog_id = ?";

		String itemAssocCk = "select item1_id,item2_id from clw_item_assoc where catalog_id = ?";

		String selectStoreCategory = "select item_id,sort_order from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY'";

		String selectAllStoreCategory = "select item_id,upper(short_desc||long_desc) from clw_item where item_id in " +
		"(select item_id from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY')";

		Date runDate = new Date();
		int catalogId = accountCatalogId;

		try{
			 String uom = "";
                         String costCenterKey = "";
			String distSku = "";
			String distributor = "";
			String customerSku = "";
			String categoryName = "";
			int categoryOrder = 0;
			String subcat1Cd = "";
			int subCat1Order = 0;
			String subcat2Cd = "";
			int subCat2Order = 0;
			String subcat3Cd = "";
			int subCat3Order = 0;
			int itemID = 0;
			int mainCategoryId = 0;
			int subCat1Id = 0;
			int subCat2Id = 0;
			int subCat3Id = 0;
			int sortOrder = 0;
			String mcatO = "";
			String sub1O = "";
			String sub2O = "";
			String sub3O = "";
			//int storeCatalogId = 0;

			HashMap categoryHashMap  = new HashMap();
                        HashMap categoryCostCenterHashMap  = new HashMap();

			HashMap tempHashMap  = new HashMap();
			HashMap acctCatItems = new HashMap();
			int accItemCatId = 0;

			HashMap itemAssocCheck = new HashMap();
			HashMap storeCategoryHashMap = new HashMap();

			PreparedStatement pstmt = conn.prepareStatement(selectAccCatStructItems);
			pstmt.setInt(1,catalogId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				accItemCatId = rs.getInt(1);
				int accSortOrd = rs.getInt(2);
                                int accCostCenterId = rs.getInt(3);

				if(  acctCatItems.containsKey(accItemCatId)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		acctCatItems.put(accItemCatId,accSortOrd);
		    	}
                            if (!categoryCostCenterHashMap.containsKey(accItemCatId)  ){
                              categoryCostCenterHashMap.put(accItemCatId,accCostCenterId);
                            }

			}
			pstmt.close();

			pstmt = conn.prepareStatement(itemAssocCk);
			pstmt.setInt(1,catalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int item11Id = rs.getInt(1);
				int item22Id = rs.getInt(2);
				if(  itemAssocCheck.containsKey(item11Id)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemAssocCheck.put(item11Id,item22Id);
		    	}
			}
			pstmt.close();

			//Add Category to Catalog HashMap
			pstmt = conn.prepareStatement(selectStoreCategory);
			pstmt.setInt(1,storeCatalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int storeCategoryId = rs.getInt(1);
				int storeCatSortOrd = rs.getInt(2);

				if(categoryHashMap.containsKey(storeCategoryId)  ){
					//do nothing
				}else{
					categoryHashMap.put(storeCategoryId,storeCatSortOrd);
				}
			}
			pstmt.close();


			pstmt = conn.prepareStatement(selectAllStoreCategory);
			pstmt.setInt(1,storeCatalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int cateID = rs.getInt(1);
				String cateName = rs.getString(2);
				if(  storeCategoryHashMap.containsKey(cateName)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		storeCategoryHashMap.put(cateName,cateID);
		    	}
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectSku);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2,catalogKey);
			pstmt.setString(3,catalogloader);
			rs = pstmt.executeQuery();

			//storeCatalogId = getStoreCatalog(conn,storeNum);

			while(rs.next()){
				distSku = rs.getString(1);
				distributor= rs.getString(2);
				customerSku = rs.getString(3);
				categoryName = rs.getString(4);
			//	categoryOrder = Integer.parseInt(rs.getString(5));
				mcatO = rs.getString(5);
				subcat1Cd = rs.getString(6);
			//	subCat1Order = Integer.parseInt(rs.getString(7));
				sub1O = rs.getString(7);
				subcat2Cd = rs.getString(8);
		//		subCat2Order = Integer.parseInt(rs.getString(9));
				sub2O = rs.getString(9);
				subcat3Cd = rs.getString(10);
		//		subCat3Order = Integer.parseInt(rs.getString(11));
				sub3O = rs.getString(11);
				uom = rs.getString(12);
                                costCenterKey =rs.getString(13);
                                int costCenterId = (costCenterKeyToIdMap!=null && costCenterKeyToIdMap.get(costCenterKey)!= null)? ((Integer)costCenterKeyToIdMap.get(costCenterKey)).intValue() : 0;
				if(mcatO != null){
					categoryOrder = Integer.parseInt(mcatO);
				}

				if(sub1O != null){
					subCat1Order = Integer.parseInt(sub1O);
				}

				if(sub2O != null){
					subCat2Order = Integer.parseInt(sub2O);
				}

				if(sub3O != null){
					subCat3Order = Integer.parseInt(sub3O);
				}

				if(itemIdHashMap.containsKey(distSku)){
					itemID = (Integer)  itemIdHashMap.get(distSku);
				}else{
				itemID = getItemId(conn, distSku,distributor,uom,storeNum );
				}
				//itemID = getItemId(conn, distSku, distributor,uom, storeNum);

				if(  acctCatItems.containsKey(itemID)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
				checkAndAddItemAccountCatalog(conn,itemID,accountCatalogId,sortOrder,catalogloader);
		    	}
                            // update cost_center_id
                             boolean costCenterFl = false;
                             if (costCenterKey != null){
                               mainCategoryId =(storeCategoryHashMap != null && categoryName != null &&
                                                storeCategoryHashMap.containsKey(categoryName.toUpperCase()))
                                                ? (Integer) storeCategoryHashMap.get(categoryName.toUpperCase()) : 0;
                               if (mainCategoryId > 0 && categoryCostCenterHashMap != null && categoryCostCenterHashMap.containsKey(mainCategoryId)){
                                 int oldCostCenterId = (Integer)categoryCostCenterHashMap.get(mainCategoryId);
                                 costCenterFl = (oldCostCenterId != costCenterId);
                                 log.info("updateAccountCatalogStructureN() ==> mainCategoryId = " + mainCategoryId+ ", costCenterFl = " + costCenterFl);
                               }
                             }

				if(subcat1Cd != null){
					if(storeCategoryHashMap.containsKey(subcat1Cd.toUpperCase())){
						subCat1Id = (Integer) storeCategoryHashMap.get(subcat1Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subCat1Id + " store Catalog_id = " + storeCatalogId);
					}

					if(  categoryHashMap.containsKey(subCat1Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat1Id);
						if(sortOrde == subCat1Order){
							//do nothing
						}else{
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,storeCategoryHashMap, costCenterId);
                                                subCat1Id = (Integer) tempHashMap.get(subcat1Cd.toUpperCase());
						categoryHashMap.put(subCat1Id,subCat1Order);
					}
					if(  acctCatItems.containsKey(subCat1Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat1Id);
						if(sortOrde != subCat1Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat1Id,accountCatalogId,subCat1Order,catalogloader, costCenterId);
						}
			    	}else{
					checkAndAddCategoryAccountCatalog(conn,subCat1Id,accountCatalogId,subCat1Order,catalogloader, costCenterId);
			    	}
				}

				if(subcat2Cd != null){
					if(storeCategoryHashMap.containsKey(subcat2Cd.toUpperCase())){
						subCat2Id = (Integer) storeCategoryHashMap.get(subcat2Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat2Cd + " store Catalog_id = " + storeCatalogId);
					}


					if(  categoryHashMap.containsKey(subCat2Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat2Id);
						if(sortOrde == subCat2Order){
							//do nothing
						}else{
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,storeCategoryHashMap, costCenterId);
                                                subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
						categoryHashMap.put(subCat2Id,subCat2Order);
					}
					if(  acctCatItems.containsKey(subCat2Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat2Id);
						if(sortOrde != subCat2Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat2Id,accountCatalogId,subCat2Order,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,subCat2Id,accountCatalogId,subCat2Order,catalogloader, costCenterId);
					}

				}

				if(subcat3Cd != null){
					if(storeCategoryHashMap.containsKey(subcat3Cd.toUpperCase())){
						subCat3Id = (Integer) storeCategoryHashMap.get(subcat3Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat3Cd + " store Catalog_id = " + storeCatalogId);
					}
					if(  categoryHashMap.containsKey(subCat3Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat3Id);
						if(sortOrder == subCat3Order){
							//do nothing
						}else{
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,storeCategoryHashMap, costCenterId);
                                                subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
						categoryHashMap.put(subCat3Id,subCat3Order);
					}

					if(  acctCatItems.containsKey(subCat3Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat3Id);
						if(sortOrde != subCat3Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat3Id,accountCatalogId,subCat3Order,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,subCat3Id,accountCatalogId,subCat3Order,catalogloader, costCenterId);
					}

				}

				if(categoryName != null){

					if(storeCategoryHashMap.containsKey(categoryName.toUpperCase())){
						mainCategoryId = (Integer) storeCategoryHashMap.get(categoryName.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
					}


					if(  categoryHashMap.containsKey(mainCategoryId)  ){
						int sortOrde = (Integer) categoryHashMap.get(mainCategoryId);
						if(sortOrde == categoryOrder){
							//do nothing
						}else{
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,storeCategoryHashMap, costCenterId);
                                                mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
						categoryHashMap.put(mainCategoryId,categoryOrder);
					}

					if(  acctCatItems.containsKey(mainCategoryId)  ){
						int sortOrde = (Integer) acctCatItems.get(mainCategoryId);
						if(sortOrde != categoryOrder || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,mainCategoryId,accountCatalogId,categoryOrder,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,mainCategoryId,accountCatalogId,categoryOrder,catalogloader, costCenterId);
					}

				}

				int itemAssocID = 0;
//**//
				if(subcat3Cd == null){
					if(subcat2Cd == null){
						if(subcat1Cd == null){
							//associate Main Category
							//int item2Id = 0;
							if(  itemAssocCheck.containsKey(itemID)  ){
								int item2Id  = (Integer)  itemAssocCheck.get(itemID);
								if(item2Id == mainCategoryId) {
									//do nothing
								}else{
									associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
									associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,catalogloader);
								}
							}else{
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}

						}else{
							//associate sub cat 1

							if(  itemAssocCheck.containsKey(itemID)  ){
								int item2Id  = (Integer)  itemAssocCheck.get(itemID);
								if(item2Id == subCat1Id) {
									//do nothing
								}else{
									associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
									associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,catalogloader);
								}
							}else{
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}
						}
					}else{
						//associate sub cat 2
						if(  itemAssocCheck.containsKey(itemID)  ){
							int item2Id  = (Integer)  itemAssocCheck.get(itemID);
							if(item2Id == subCat2Id) {
								//do nothing
							}else{
								associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,catalogloader);
							}
						}else{
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}
					}
				}else{
					//associate sub cat 3
					if(  itemAssocCheck.containsKey(itemID)  ){
						int item2Id  = (Integer)  itemAssocCheck.get(itemID);
						if(item2Id == subCat3Id) {
							//do nothing
						}else{
							associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,storeCatalogId,catalogloader);
						}
					}else{
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}
				}
			}
			pstmt.close();
			log.info("UpdateAccountCatalog END");
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateAccountCatalogStructureN()=> "
                               + e.getMessage());
    	}

	}

        public void updateAccountCatalogStructure(Connection conn,int accountCatalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName) throws RemoteException{
          updateAccountCatalogStructure( conn, accountCatalogId, storeCatalogId, accRefNum, catalogKey, catalogloader, storeNum, tmpTableName, null);
        }

	private void updateAccountCatalogStructure(Connection conn,int accountCatalogId,int storeCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName, Map costCenterKeyToIdMap) throws RemoteException{
		log.info("UpdateAccountCatalog Start");

		String selectSku = "select dist_sku,distributor,customer_sku,upper(category_name),category_order,upper(subcat1)," +
		"subcat1_order,upper(subcat2),subcat2_order,upper(subcat3),subcat3_order, uom, cost_center_key " +
		"from " + tmpTableName + " "  +
		"where account_ref_num = ? and catalog_key = ? and add_by = ? ";

		String selectAccCatStructItems = "select item_id,sort_order, cost_center_id from clw_catalog_structure " +
			"where catalog_id = ?";

		String itemAssocCk = "select item1_id,item2_id from clw_item_assoc where catalog_id = ?";

		String selectStoreCategory = "select item_id,sort_order from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY'";

		String selectAllStoreCategory = "select item_id, upper(short_desc||long_desc) from clw_item where item_id in " +
		"(select item_id from clw_catalog_structure where catalog_id = ? " +
		"and catalog_structure_cd = 'CATALOG_CATEGORY')";

		Date runDate = new Date();
		int catalogId = accountCatalogId;

		try{
			 String uom = "";
                        String costCenterKey = "";
			String distSku = "";
			String distributor = "";
			String customerSku = "";
			String categoryName = "";
			int categoryOrder = 0;
			String subcat1Cd = "";
			int subCat1Order = 0;
			String subcat2Cd = "";
			int subCat2Order = 0;
			String subcat3Cd = "";
			int subCat3Order = 0;
			int itemID = 0;
			int mainCategoryId = 0;
			int subCat1Id = 0;
			int subCat2Id = 0;
			int subCat3Id = 0;
			int sortOrder = 0;
			String mcatO = "";
			String sub1O = "";
			String sub2O = "";
			String sub3O = "";
			//int storeCatalogId = 0;

			HashMap categoryHashMap  = new HashMap();
                        HashMap categoryCostCenterHashMap  = new HashMap();
			HashMap tempHashMap  = new HashMap();
			HashMap acctCatItems = new HashMap();
			int accItemCatId = 0;

			HashMap itemAssocCheck = new HashMap();
			HashMap storeCategoryHashMap = new HashMap();

			PreparedStatement pstmt = conn.prepareStatement(selectAccCatStructItems);
			pstmt.setInt(1,catalogId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				accItemCatId = rs.getInt(1);
				int accSortOrd = rs.getInt(2);
                                int accCostCenterId = rs.getInt(3);
				if( !acctCatItems.containsKey(accItemCatId)  ){
                                  acctCatItems.put(accItemCatId,accSortOrd);
                                }
                                if (!categoryCostCenterHashMap.containsKey(accItemCatId)  ){
                                  categoryCostCenterHashMap.put(accItemCatId,accCostCenterId);
                                }

			}
			pstmt.close();

			pstmt = conn.prepareStatement(itemAssocCk);
			pstmt.setInt(1,catalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int item11Id = rs.getInt(1);
				int item22Id = rs.getInt(2);
				if(  itemAssocCheck.containsKey(item11Id)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		itemAssocCheck.put(item11Id,item22Id);
		    	}
			}
			pstmt.close();

			//Add Category to Catalog HashMap
			pstmt = conn.prepareStatement(selectStoreCategory);
                        pstmt.setInt(1,storeCatalogId);
                        rs = pstmt.executeQuery();
                        while(rs.next()){
                                int storeCategoryId = rs.getInt(1);
                                int storeCatSortOrd = rs.getInt(2);

                                if(categoryHashMap.containsKey(storeCategoryId)  ){
                                        //do nothing
                                }else{
                                        categoryHashMap.put(storeCategoryId,storeCatSortOrd);
                                }

                        }
                        pstmt.close();


			pstmt = conn.prepareStatement(selectAllStoreCategory);
			pstmt.setInt(1,storeCatalogId);
			rs = pstmt.executeQuery();
			while(rs.next()){
				int cateID = rs.getInt(1);
				String cateName = rs.getString(2);
				if(  storeCategoryHashMap.containsKey(cateName)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
		    		storeCategoryHashMap.put(cateName,cateID);
		    	}
			}
			pstmt.close();

			pstmt = conn.prepareStatement(selectSku);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2,catalogKey);
			pstmt.setString(3,catalogloader);
			rs = pstmt.executeQuery();

			//storeCatalogId = getStoreCatalog(conn,storeNum);

			while(rs.next()){
				distSku = rs.getString(1);
				distributor= rs.getString(2);
				customerSku = rs.getString(3);
				categoryName = rs.getString(4);
			//	categoryOrder = Integer.parseInt(rs.getString(5));
				mcatO = rs.getString(5);
				subcat1Cd = rs.getString(6);
			//	subCat1Order = Integer.parseInt(rs.getString(7));
				sub1O = rs.getString(7);
				subcat2Cd = rs.getString(8);
		//		subCat2Order = Integer.parseInt(rs.getString(9));
				sub2O = rs.getString(9);
				subcat3Cd = rs.getString(10);
		//		subCat3Order = Integer.parseInt(rs.getString(11));
				sub3O = rs.getString(11);
				uom = rs.getString(12);
                                costCenterKey =rs.getString(13);
                                int costCenterId = (costCenterKeyToIdMap!=null && costCenterKeyToIdMap.get(costCenterKey)!= null)? ((Integer)costCenterKeyToIdMap.get(costCenterKey)).intValue() : 0;
				if(mcatO != null){
					categoryOrder = Integer.parseInt(mcatO);
				}

				if(sub1O != null){
					subCat1Order = Integer.parseInt(sub1O);
				}

				if(sub2O != null){
					subCat2Order = Integer.parseInt(sub2O);
				}

				if(sub3O != null){
					subCat3Order = Integer.parseInt(sub3O);
				}

				itemID = getItemId(conn, distSku, distributor,uom, storeNum);//getItemId(conn,distSku,uom,storeNum);
		//		log.info("updateAccountCatalogStructure getItemId  itemID =" + itemID  + "distSku =" + distSku);

				if(  acctCatItems.containsKey(itemID)  ){
					//subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
		    	}else{
				checkAndAddItemAccountCatalog(conn,itemID,accountCatalogId,sortOrder,catalogloader, costCenterId);
		    	}
                         // update cost_center_id
                          boolean costCenterFl = false;
                          if (costCenterKey != null){
                            mainCategoryId =(storeCategoryHashMap != null && categoryName != null &&
                                             storeCategoryHashMap.containsKey(categoryName.toUpperCase()))
                                             ? (Integer) storeCategoryHashMap.get(categoryName.toUpperCase()) : 0;
                            if (mainCategoryId > 0 && categoryCostCenterHashMap != null && categoryCostCenterHashMap.containsKey(mainCategoryId)){
                              int oldCostCenterId = (Integer)categoryCostCenterHashMap.get(mainCategoryId);
                              costCenterFl = (oldCostCenterId != costCenterId);
                              log.info("updateAccountCatalogStructure() ==> mainCategoryId = " + mainCategoryId+ ", costCenterFl = " + costCenterFl);
                            }
                          }
				if(subcat1Cd != null){
					//subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,catalogloader,sortOrder);
		//			subCat1Id = checkAndCreateCategory(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order);
		//			log.info("UUUUUUUUUUUUUUupdateAccountCatalogStructure Check 01 subCat1Id =" + subCat1Id  + "subcat1Cd =" + subcat1Cd);
					//NEWWW METHOD ALTERNATE subcat1
		//			int CatID1 = 0;


					if(storeCategoryHashMap.containsKey(subcat1Cd.toUpperCase())){
						subCat1Id = (Integer) storeCategoryHashMap.get(subcat1Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subCat1Id + " store Catalog_id = " + storeCatalogId);
					}

					if(  categoryHashMap.containsKey(subCat1Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat1Id);
						if(sortOrde != subCat1Order ){
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,storeCategoryHashMap, costCenterId);
                                                subCat1Id = (Integer) tempHashMap.get(subcat1Cd.toUpperCase());
                                                categoryHashMap.put(subCat1Id,subCat1Order);
					}

				/*	tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat1Cd,catalogloader,subCat1Order,categoryHashMap);
					if(  categoryHashMap.containsKey(subcat1Cd)  ){
						subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd);
		    		}else{
		    			subCat1Id  = (Integer)  tempHashMap.get(subcat1Cd);
		    			categoryHashMap.put(subcat1Cd,subCat1Id);
		    		} */




		//			log.info("UUUUUUUUUUUUUUupdateAccountCatalogStructure Check 01 subCat1Id =" + subCat1Id);

					if(  acctCatItems.containsKey(subCat1Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat1Id);
						if(sortOrde != subCat1Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat1Id,accountCatalogId,subCat1Order,catalogloader, costCenterId);
						}
			    	}else{
					checkAndAddCategoryAccountCatalog(conn,subCat1Id,accountCatalogId,subCat1Order,catalogloader, costCenterId);
			    	}
				}

				if(subcat2Cd != null){
					//subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,catalogloader,sortOrder);
		//			subCat2Id = checkAndCreateCategory(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order);
		//			log.info("UUUUUUUUUUUUUUUUUUUUUUupdateAccountCatalogStructure Check 02 subCat2Id =" + subCat2Id  + "subcat2Cd =" + subcat2Cd);

					//NEWWW METHOD ALTERNATE subcat2
		//			int CatID2 = 0;

					if(storeCategoryHashMap.containsKey(subcat2Cd.toUpperCase())){
						subCat2Id = (Integer) storeCategoryHashMap.get(subcat2Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat2Cd + " store Catalog_id = " + storeCatalogId);
					}


					if(  categoryHashMap.containsKey(subCat2Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat2Id);
						if(sortOrde != subCat2Order ){
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,storeCategoryHashMap, costCenterId);
                                                subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd.toUpperCase());
                                                categoryHashMap.put(subCat2Id,subCat2Order);
					}

				/*	tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat2Cd,catalogloader,subCat2Order,categoryHashMap);
						if(  categoryHashMap.containsKey(subcat2Cd)  ){
							subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
				    	}else{
				    		subCat2Id  = (Integer)  tempHashMap.get(subcat2Cd);
				    		categoryHashMap.put(subcat2Cd,subCat2Id);
				    	}  */
			//		log.info("UUUUUUUUUUUUUUUUUUUUUUupdateAccountCatalogStructure Check 02 subCat2Id =" + subCat2Id);



					if(  acctCatItems.containsKey(subCat2Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat2Id);
						if(sortOrde != subCat2Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat2Id,accountCatalogId,subCat2Order,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,subCat2Id,accountCatalogId,subCat2Order,catalogloader, costCenterId);
					}

				}

				if(subcat3Cd != null){
					//subCat3Id = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,catalogloader,sortOrder);
		//			subCat3Id = checkAndCreateCategory(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order);
		//			log.info("UUUUUUUUUUUUUUUupdateAccountCatalogStructure Check 03 subCat3Id =" + subCat3Id  + "subcat3Cd =" + subcat3Cd);
					//NEWWW METHOD ALTERNATE subcat3
		//			int CatID3 = 0;

					if(storeCategoryHashMap.containsKey(subcat3Cd.toUpperCase())){
						subCat3Id = (Integer) storeCategoryHashMap.get(subcat3Cd.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + subcat3Cd + " store Catalog_id = " + storeCatalogId);
					}


					if(  categoryHashMap.containsKey(subCat3Id)  ){
						int sortOrde = (Integer) categoryHashMap.get(subCat3Id);
						if(sortOrder != subCat3Order ){
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,storeCategoryHashMap, costCenterId);
						subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd.toUpperCase());
                                                categoryHashMap.put(subCat3Id,subCat3Order);
					}

				/*	tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,subcat3Cd,catalogloader,subCat3Order,categoryHashMap);
						if(  categoryHashMap.containsKey(subcat3Cd)  ){
							subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd);
				    	}else{
				    		subCat3Id  = (Integer)  tempHashMap.get(subcat3Cd);
				    		categoryHashMap.put(subcat3Cd,subCat3Id);
				    	}*/
			//			log.info("UUUUUUUUUUUUUUUupdateAccountCatalogStructure Check 03 subCat3Id = " + subCat3Id);


					if(  acctCatItems.containsKey(subCat3Id)  ){
						int sortOrde = (Integer) acctCatItems.get(subCat3Id);
						if(sortOrde != subCat3Order || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,subCat3Id,accountCatalogId,subCat3Order,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,subCat3Id,accountCatalogId,subCat3Order,catalogloader, costCenterId);
					}

				}

				if(categoryName != null){
					//mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,sortOrder);
		//			mainCategoryId = checkAndCreateCategory(conn,storeCatalogId,categoryName,catalogloader,categoryOrder);
		//			log.info("UUUUUUUUUUUUUupdateAccountCatalogStructure Check 04 mainCategoryId =" + mainCategoryId  + "categoryName =" + categoryName);

					//NEWWW METHOD ALTERNATE Main Cat
		//			int CatID0 = 0;

					if(storeCategoryHashMap.containsKey(categoryName.toUpperCase())){
						mainCategoryId = (Integer) storeCategoryHashMap.get(categoryName.toUpperCase());
					}else{
						log.info("Category Does not Exits in store Catalof catName=" + categoryName + " store Catalog_id = " + storeCatalogId);
					}


					if(  categoryHashMap.containsKey(mainCategoryId)  ){
						int sortOrde = (Integer) categoryHashMap.get(mainCategoryId);
						if(sortOrde != categoryOrder ){
							tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,storeCategoryHashMap, costCenterId);
						}
					}else{
						tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,storeCategoryHashMap, costCenterId);
						mainCategoryId  = (Integer)  tempHashMap.get(categoryName.toUpperCase());
                                                categoryHashMap.put(mainCategoryId,categoryOrder);
					}





					/*tempHashMap = checkAndCreateCategoryN(conn,storeCatalogId,categoryName,catalogloader,categoryOrder,categoryHashMap);
						if(  categoryHashMap.containsKey(categoryName)  ){
							mainCategoryId  = (Integer)  tempHashMap.get(categoryName);
				    	}else{
				    		mainCategoryId  = (Integer)  tempHashMap.get(categoryName);
				    		categoryHashMap.put(categoryName,mainCategoryId);
				    	} */
				//		log.info("UUUUUUUUUUUUUupdateAccountCatalogStructure Check 04 mainCategoryId = " + mainCategoryId);


					if(  acctCatItems.containsKey(mainCategoryId)  ){
						int sortOrde = (Integer) acctCatItems.get(mainCategoryId);
						if(sortOrde != categoryOrder || costCenterFl){
							checkAndAddCategoryAccountCatalog(conn,mainCategoryId,accountCatalogId,categoryOrder,catalogloader, costCenterId);
						}
					}else{
						checkAndAddCategoryAccountCatalog(conn,mainCategoryId,accountCatalogId,categoryOrder,catalogloader, costCenterId);
					}

				}


				int itemAssocID = 0;
//**//
				if(subcat3Cd == null){
					if(subcat2Cd == null){
						if(subcat1Cd == null){
							//associate Main Category
							//int item2Id = 0;
							if(  itemAssocCheck.containsKey(itemID)  ){
								int item2Id  = (Integer)  itemAssocCheck.get(itemID);
								if(item2Id == mainCategoryId) {
									//do nothing
								}else{
									associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								}
							}else{
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}

					/*		itemAssocID = checkItemCatAssoc(conn,itemID,mainCategoryId,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,mainCategoryId,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							} */

						}else{
							//associate sub cat 1

							if(  itemAssocCheck.containsKey(itemID)  ){
								int item2Id  = (Integer)  itemAssocCheck.get(itemID);
								if(item2Id == subCat1Id) {
									//do nothing
								}else{
									associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
								}
							}else{
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}

					/*		itemAssocID = checkItemCatAssoc(conn,itemID,subCat1Id,catalogId);
							if(itemAssocID == 0){
								associateItem(conn,itemID,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}else{
								associateItem(conn,itemID,subCat1Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}  */
							//Check Main Category and subcat1 Association
					/*		itemAssocID = checkItemCatAssoc(conn,subCat1Id,mainCategoryId,catalogId);
							log.info("UpdateAccountCatalog check33 subCat1Id =" + subCat1Id + "mainCategoryId =" + mainCategoryId + "itemAssocId = " + itemAssocID);
							if(itemAssocID == 0){
								associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
							}*/

					//		log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 111111111 subCat1Id = " + subCat1Id);
						}
					}else{
						//associate sub cat 2
						if(  itemAssocCheck.containsKey(itemID)  ){
							int item2Id  = (Integer)  itemAssocCheck.get(itemID);
							if(item2Id == subCat2Id) {
								//do nothing
							}else{
								associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
							}
						}else{
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}

			/*			itemAssocID = checkItemCatAssoc(conn,itemID,subCat2Id,catalogId);
						if(itemAssocID == 0){
							associateItem(conn,itemID,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}else{
							associateItem(conn,itemID,subCat2Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						} */

						//Check subcat1 and subcat2 Association
					/*	itemAssocID = checkItemCatAssoc(conn,subCat2Id,subCat1Id,catalogId);
						log.info("UpdateAccountCatalog check55 subCat2Id =" + subCat2Id + "subCat1Id =" + subCat1Id + "itemAssocId = " + itemAssocID);
						if(itemAssocID == 0){
							associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
						}*/


						//Check Main Category and subcat1 Association
				/*		itemAssocID = checkItemCatAssoc(conn,subCat1Id,mainCategoryId,catalogId);
						log.info("UpdateAccountCatalog check66 subCat1Id =" + subCat1Id + "mainCategoryId =" + mainCategoryId + "itemAssocId = " + itemAssocID);
						if(itemAssocID == 0){
							associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
						}*/
//						log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 22222222222 subCat2Id = " + subCat2Id);
					}
				}else{
					//associate sub cat 3
			//		catId = checkIfCategoryExists(conn,storeCatalogId,subcat3Cd);

					if(  itemAssocCheck.containsKey(itemID)  ){
						int item2Id  = (Integer)  itemAssocCheck.get(itemID);
						if(item2Id == subCat3Id) {
							//do nothing
						}else{
							associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
						}
					}else{
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}

	/*				itemAssocID = checkItemCatAssoc(conn,itemID,subCat3Id,catalogId);
					if(itemAssocID == 0){
						associateItem(conn,itemID,subCat3Id,0,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}else{
						associateItem(conn,itemID,subCat3Id,1,RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY,catalogId,catalogloader);
					}*/
					//check subcat2 and subcat3 Association
			/*		itemAssocID = checkItemCatAssoc(conn,subCat3Id,subCat2Id,catalogId);
					log.info("UpdateAccountCatalog check88 subCat3Id =" + subCat3Id + "subCat2Id =" + subCat2Id + "itemAssocId = " + itemAssocID);
					if(itemAssocID == 0){
						associateItem(conn,subCat3Id,subCat2Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
					} */

					//Check subcat1 and subcat2 Association
				/*	itemAssocID = checkItemCatAssoc(conn,subCat2Id,subCat1Id,catalogId);
					log.info("UpdateAccountCatalog check99 subCat2Id =" + subCat2Id + "subCat1Id =" + subCat1Id + "itemAssocId = " + itemAssocID);
					if(itemAssocID == 0){
						associateItem(conn,subCat2Id,subCat1Id,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
					} */


					//Check Main Category and subcat1 Association
				/*	itemAssocID = checkItemCatAssoc(conn,subCat1Id,mainCategoryId,catalogId);
					log.info("UpdateAccountCatalog check10 subCat1Id =" + subCat1Id + "mainCategoryId =" + mainCategoryId + "itemAssocId = " + itemAssocID);
					if(itemAssocID == 0){
						associateItem(conn,subCat1Id,mainCategoryId,0,RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY,catalogId,catalogloader);
					} */
		//			log.info("CCCCCCCAAAAAAAATTTTTTTT associate Sub CAT 333333333333 subCat3Id = " + subCat3Id);
				}

//**//


			}
			pstmt.close();
			log.info("UpdateAccountCatalog END");
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateAccountCatalogStructure()=> "
                               + e.getMessage());
    	}

	}

        public void checkAndAddItemAccountCatalog(Connection conn,int itemId,int catalogId,int sortOrder,String catalogloader) throws RemoteException{
          checkAndAddItemAccountCatalog(conn, itemId, catalogId, sortOrder, catalogloader, 0);
        }

	private void checkAndAddItemAccountCatalog(Connection conn,int itemId,int catalogId,int sortOrder,String catalogloader, int costCenterId) throws RemoteException{
	//	log.info("checkAndAddItemCatalogStructure Start");

		String selectItemCat = "select count(*) from clw_catalog_structure where catalog_id = ? and item_id = ?";

		String insertCatalogItem = "insert into clw_catalog_structure(catalog_structure_id,catalog_id,catalog_structure_cd," +
				"item_id,eff_date,status_cd,add_date,add_by,mod_date,mod_by,sort_order, cost_center_id) " +
				"values(clw_catalog_structure_seq.nextval,?,?,?,sysdate,'ACTIVE',sysdate,?,sysdate,?,?,?)";

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectItemCat);
			pstmt.setInt(1, catalogId);
			pstmt.setInt(2, itemId);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}

			pstmt.close();

			if(count == 0){
				log.info("Item Does not Exists in Catalog Structure Item_id =" + itemId + "Catalog Id = " + catalogId);
				pstmt = conn.prepareStatement(insertCatalogItem);
				pstmt.setInt(1, catalogId);
				pstmt.setString(2, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
				pstmt.setInt(3, itemId);
				pstmt.setString(4, catalogloader);
				pstmt.setString(5, catalogloader);
				pstmt.setInt(6, sortOrder);
                                pstmt.setInt(7, costCenterId);
				pstmt.executeUpdate();
				pstmt.close();

			}


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndAddItemCatalogStructure()=> "
                               + e.getMessage());
    	}

	}
        public void checkAndAddCategoryAccountCatalog(Connection conn,int itemId,int catalogId,int sortOrder,String catalogloader) throws RemoteException{
          checkAndAddCategoryAccountCatalog(conn, itemId, catalogId, sortOrder, catalogloader, 0);
        }
	private void checkAndAddCategoryAccountCatalog(Connection conn,int itemId,int catalogId,int sortOrder,String catalogloader, int costCenterId) throws RemoteException{
		log.info("checkAndAddCategoryAccountCatalog Start ==> catalogId =" + catalogId+ ", Item_id =" + itemId);

//		String selectItemCat = "select count(*) from clw_catalog_structure where catalog_id = ? and item_id = ?";

//		String insertCatalogItem = "insert into clw_catalog_structure(catalog_structure_id,catalog_id,catalog_structure_cd," +
//				"item_id,eff_date,status_cd,add_date,add_by,mod_date,mod_by,sort_order, cost_center_id) " +
//				"values(clw_catalog_structure_seq.nextval,?,?,?,sysdate,'ACTIVE',sysdate,?,sysdate,?,?, ?)";

		try{
/*			PreparedStatement pstmt = conn.prepareStatement(selectItemCat);
			pstmt.setInt(1, catalogId);
			pstmt.setInt(2, itemId);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}

			pstmt.close();
*/
                        DBCriteria dbc = new  DBCriteria();
                        dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_ID, catalogId);
                        dbc.addEqualTo(CatalogStructureDataAccess.ITEM_ID, itemId);
                        dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_STRUCTURE_CD, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
                        CatalogStructureDataVector csDV = CatalogStructureDataAccess.select(conn, dbc);
			if(csDV == null || csDV.isEmpty()){
//				log.info("checkAndAddItemCatalogStructure() ==> Item Does not Exists in Catalog Structure Item_id =" + itemId + "Catalog Id = " + catalogId);
/*				pstmt = conn.prepareStatement(insertCatalogItem);
				pstmt.setInt(1, catalogId);
				pstmt.setString(2, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
				pstmt.setInt(3, itemId);
				pstmt.setString(4, catalogloader);
				pstmt.setString(5, catalogloader);
				pstmt.setInt(6, sortOrder);
                                pstmt.setInt(7, costCenterId);
				pstmt.executeUpdate();
				pstmt.close();
*/
                                CatalogStructureData catalogStructureData = CatalogStructureData.createValue();

                                catalogStructureData.setCatalogId(catalogId);
                                catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
                                catalogStructureData.setItemId(itemId);
                                catalogStructureData.setEffDate(new Date());
                                catalogStructureData.setSortOrder(sortOrder);
                                catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
                                catalogStructureData.setAddBy(catalogloader);
                                catalogStructureData.setModBy(catalogloader);
                                catalogStructureData.setCostCenterId(costCenterId);

                                CatalogStructureDataAccess.insert(conn, catalogStructureData);

			} else if (csDV.size() >1){
                          throw new Exception("checkAndAddCategoryAccountCatalog() : more than 1 catalog category found. catalog_id =" + catalogId + ", item_id = " + itemId);
			} else {
                          CatalogStructureData catalogStructureData = (CatalogStructureData)csDV.get(0);
                          catalogStructureData.setSortOrder(sortOrder);
                          catalogStructureData.setCostCenterId(costCenterId);
                          catalogStructureData.setModBy(catalogloader);

                          CatalogStructureDataAccess.update(conn, catalogStructureData);

                        }


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndAddCategoryAccountCatalog()=> "
                               + e.getMessage());
    	}

	}


	public int createContractN(Connection conn,int shoppingCatalogId,String catalogKey,int storeNum,String catalogloader,String accRefNum) throws RemoteException{
		String selectLocale = "select distinct locale from CLT_POLLOCK_CATALOG_LOADER " +
		"where account_ref_num = ? and catalog_key = ? ";
		String localeCd = "";
		String refContractNum = "0";
		String contractTypeCd = "UNKNOWN";
		Date runDate = new Date();
		int contractId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectLocale);
			pstmt.setString(1,accRefNum);
			pstmt.setString(2,catalogKey);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				localeCd = rs.getString(1);

			}
			if(localeCd == null){
				throw new IllegalArgumentException("Locale is null for catalog_key/account_ref_num = " + catalogKey + "/" + accRefNum);
			}
			pstmt.close();

			ContractData contractData = ContractData.createValue();
			contractData.setRefContractNum(refContractNum);
			contractData.setShortDesc(catalogKey);
			contractData.setCatalogId(shoppingCatalogId);
			contractData.setContractStatusCd(RefCodeNames.CONTRACT_STATUS_CD.ACTIVE);
			contractData.setContractTypeCd(contractTypeCd);
			contractData.setEffDate(runDate);
			contractData.setLocaleCd(localeCd);
			contractData.setAddBy(catalogloader);
			contractData.setAddDate(runDate);
			contractData.setModBy(catalogloader);
			contractData.setModDate(runDate);
			ContractDataAccess.insert(conn, contractData);

			contractId = contractData.getContractId();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createContractN()=> "
                               + e.getMessage());
    	}

		return contractId;
	}

	public int createContract(Connection conn,int shoppingCatalogId,String catalogKey,int storeNum,String catalogloader) throws RemoteException{
		String refContractNum = "0";
		String contractTypeCd = "UNKNOWN";
		Date runDate = new Date();
		int contractId = 0;

		try{
			ContractData contractData = ContractData.createValue();
			contractData.setRefContractNum(refContractNum);
			contractData.setShortDesc(catalogKey);
			contractData.setCatalogId(shoppingCatalogId);
			contractData.setContractStatusCd(RefCodeNames.CONTRACT_STATUS_CD.ACTIVE);
			contractData.setContractTypeCd(contractTypeCd);
			contractData.setEffDate(runDate);
			contractData.setLocaleCd(RefCodeNames.LOCALE_CD.EN_US);
			contractData.setAddBy(catalogloader);
			contractData.setAddDate(runDate);
			contractData.setModBy(catalogloader);
			contractData.setModDate(runDate);
			ContractDataAccess.insert(conn, contractData);

			contractId = contractData.getContractId();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndAddItemCatalogStructure()=> "
                               + e.getMessage());
    	}

		return contractId;
	}



	public void createContractItemN(Connection conn,int contractId,String accRefNum,String catalogKey,int storeNum,String catalogloader,String tmpTableName,HashMap itemIdHashMap) throws RemoteException{
		log.info("createContractItem Start contractId = " + contractId + "accRefNum = " + accRefNum + "catalogkey= " + catalogKey);
		long startTime = System.currentTimeMillis();
		String selectContractItem = "select dist_sku,price,uom, distributor from "+tmpTableName+" "+
		"where account_ref_num = ? and catalog_key = ? and add_by = ? ";


		String insertContractItem = "insert into clw_contract_item" +
				"(contract_item_id,contract_id,item_id,amount,dist_cost,currency_cd,add_date,add_by,mod_date) " +
				"values(clw_contract_item_seq.nextval,?,?,?,?,?,sysdate,?,sysdate)";


		try{
			PreparedStatement pstmt = conn.prepareStatement(selectContractItem);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2, catalogKey);
			pstmt.setString(3, catalogloader);
			ResultSet rs = pstmt.executeQuery();
			String distSku = "";
			//int price = 0;
			String stringPrice = "";
			String uom = "";
                        String distributor = "";
			int itemId = 0;

			PreparedStatement pstmt1 = conn.prepareStatement(insertContractItem);
			pstmt1.setString(5, RefCodeNames.CURRENCY_CD.USD);
			pstmt1.setString(6, catalogloader);
			while(rs.next()){
				distSku = rs.getString(1);
				stringPrice = rs.getString(2);
				uom = rs.getString(3);
				distributor = rs.getString(4);

                                log.info("distSku = " + distSku + "priceString = " + stringPrice);
				BigDecimal price = new BigDecimal(rs.getString(2));
				//price = Integer.parseInt(rs.getString(2));

				if(itemIdHashMap.containsKey(distSku)){
					itemId = (Integer)  itemIdHashMap.get(distSku);
				}else{
					itemId = getItemId(conn, distSku,distributor,uom,storeNum );
				}
				//itemId = getItemId(conn, distSku, distributor,uom, storeNum);//getItemId(conn,distSku,uom, storeNum);

				pstmt1.setInt(1, contractId);
				pstmt1.setInt(2, itemId);
				pstmt1.setBigDecimal(3, price);
				pstmt1.setBigDecimal(4, price);
				pstmt1.addBatch();


			}
			pstmt1.executeBatch();
			pstmt1.close();

			pstmt.close();
			long endTime = System.currentTimeMillis();
			log.info("createContractItem That took " + (endTime - startTime) + " milliseconds contractId=" + contractId + "accRefNum=" + accRefNum + "catalogKey=" + catalogKey );

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createContractItem()=> "
                               + e.getMessage());
    	}
	}


	public void createContractItem(Connection conn,int contractId,String accRefNum,String catalogKey,int storeNum,String catalogloader,String tmpTableName) throws RemoteException{
		log.info("createContractItem Start contractId = " + contractId + "accRefNum = " + accRefNum + "catalogkey= " + catalogKey);
		long startTime = System.currentTimeMillis();
		String selectContractItem = "select dist_sku,cost,uom, distributor,price from "+tmpTableName+" "+
		"where account_ref_num = ? and catalog_key = ? and add_by = ? ";


		String insertContractItem = "insert into clw_contract_item" +
				"(contract_item_id,contract_id,item_id,amount,dist_cost,currency_cd,add_date,add_by,mod_date) " +
				"values(clw_contract_item_seq.nextval,?,?,?,?,?,sysdate,?,sysdate)";


		try{
			PreparedStatement pstmt = conn.prepareStatement(selectContractItem);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2, catalogKey);
			pstmt.setString(3, catalogloader);
			ResultSet rs = pstmt.executeQuery();
			String distSku = "";
			//int price = 0;
			String stringPrice = "";
			String uom = "";
                        String distributor = "";
			int itemId = 0;

			PreparedStatement pstmt1 = conn.prepareStatement(insertContractItem);
			pstmt1.setString(5, RefCodeNames.CURRENCY_CD.USD);
			pstmt1.setString(6, catalogloader);
			while(rs.next()){
				distSku = rs.getString(1);
				BigDecimal cost = new BigDecimal(rs.getString(2));				
				uom = rs.getString(3);
				distributor = rs.getString(4);
				BigDecimal price = rs.getBigDecimal(5);
				itemId = getItemId(conn, distSku, distributor,uom, storeNum);//getItemId(conn,distSku,uom, storeNum);

				pstmt1.setInt(1, contractId);
				pstmt1.setInt(2, itemId);
				pstmt1.setBigDecimal(3, price);
				pstmt1.setBigDecimal(4, cost);
				pstmt1.addBatch();


			}
			pstmt1.executeBatch();
			pstmt1.close();

			pstmt.close();
			long endTime = System.currentTimeMillis();
			log.info("createContractItem That took " + (endTime - startTime) + " milliseconds contractId=" + contractId + "accRefNum=" + accRefNum + "catalogKey=" + catalogKey );

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createContractItem()=> "
                               + e.getMessage());
    	}
	}

	public void deleteCatalogStructure(Connection conn,int shoppingCatalogId) throws RemoteException{
		log.info("deleteCatalogStructure Start shoppingCatalogId = " + shoppingCatalogId);
		long startTime = System.currentTimeMillis();
		String delShopCatStruct = "delete from clw_catalog_structure where catalog_id = ?";

		String delItemAssoc = "delete from clw_item_assoc where catalog_id = ?";
		int delRecord = 0;
		try{

			log.info("deleteCatalogStructure Start Delete ItemAssoc catalog_id = " + shoppingCatalogId);
			PreparedStatement pstmt = conn.prepareStatement(delItemAssoc);
			pstmt.setInt(1, shoppingCatalogId);
			pstmt.executeUpdate();
			pstmt.close();
		//	log.info("deleteCatalogStructure END Delete ItemAssoc catalog_id = " + shoppingCatalogId);

			log.info("deleteCatalogStructure Start Delete Catalog Structure catalog_id = " + shoppingCatalogId);
			pstmt = conn.prepareStatement(delShopCatStruct);
			pstmt.setInt(1, shoppingCatalogId);
			delRecord = pstmt.executeUpdate();
			pstmt.close();
			long endTime = System.currentTimeMillis();
			log.info("deleteCatalogStructure That took " + (endTime - startTime) + " milliseconds shoppingCatalogId =" + shoppingCatalogId );
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.deleteCatalogStructure()=> "
                               + e.getMessage());
    	}

	}

	public int getContractId(Connection conn,int shoppingCatalogId) throws RemoteException{
		log.info("getContractId Start catalog_id = " + shoppingCatalogId);
		String selectContractId = "select contract_id from clw_contract where catalog_id = ? " +
				"and contract_status_cd = ?";

		int contractId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectContractId);
			pstmt.setInt(1, shoppingCatalogId);
			pstmt.setString(2, RefCodeNames.CONTRACT_STATUS_CD.ACTIVE);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				contractId = rs.getInt(1);
				if(rs.next())
				throw new IllegalArgumentException("Two Active Contracts found for Catalog_id = " + shoppingCatalogId);
			}
			pstmt.close();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getContractId()=> "
                               + e.getMessage());
    	}
		return contractId;
	}


	public void deleteContractItem(Connection conn, int contractId) throws RemoteException{
		log.info("deleteContractItem Start contract_id = " + contractId);
		long startTime = System.currentTimeMillis();
		String deleteContractItems = "delete from clw_contract_item where contract_id = ?";

		try{
			log.info("deleteContractItem Start Delete Contract items contract_id = " + contractId);
			PreparedStatement pstmt = conn.prepareStatement(deleteContractItems);
			pstmt.setInt(1, contractId);
			pstmt.executeUpdate();
			pstmt.close();
			long endTime = System.currentTimeMillis();
			log.info("deleteContractItem That took " + (endTime - startTime) + " milliseconds contractId=" + contractId);

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.deleteContractItem()=> "
                               + e.getMessage());
    	}
	}

	public int createTemplateOrderGuide(Connection conn,int shoppingCatalogId,String orderGuideName,String catalogloader) throws RemoteException{
		log.info("createTemplateOrderGuide Start");
		int templateOrderGuideId = 0;
		Date runDate = new Date();

		try{
			OrderGuideData orderGuideData = OrderGuideData.createValue();
			orderGuideData.setShortDesc(orderGuideName);
			orderGuideData.setCatalogId(shoppingCatalogId);
			orderGuideData.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
			orderGuideData.setAddBy(catalogloader);
			orderGuideData.setAddDate(runDate);
			orderGuideData.setModBy(catalogloader);
			orderGuideData.setModDate(runDate);

			OrderGuideDataAccess.insert(conn,orderGuideData);
			templateOrderGuideId = orderGuideData.getOrderGuideId();


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createTemplateOrderGuide()=> "
                               + e.getMessage());
    	}
		log.info("createTemplateOrderGuide end return templateOrderGuideId=" + templateOrderGuideId);
		return templateOrderGuideId;
	}

	public void checkCreateTemplateOrderGuide(Connection conn,int shoppingCatalogId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName) throws RemoteException{
		log.info("checkCreateTemplateOrderGuide Start");

		String orderGuideCheck = "select count(*) from CLT_POLLOCK_CATALOG_LOADER " +
		"where account_ref_num = ? and catalog_key = ? and upper(order_guide) = ? " +
		"and add_by = ? ";

		String checkOrderGuide = "select order_guide_id from clw_order_guide where short_desc = ? " +
		"and catalog_id = ?	and order_guide_type_cd = ?";

		int templateOrderGuideId = 0;
		Date runDate = new Date();
		String orderGuide = "TRUE";
		try{
			PreparedStatement pstmt = conn.prepareStatement(orderGuideCheck);
			pstmt.setString(1, accRefNum);
			pstmt.setString(2, catalogKey);
			pstmt.setString(3, orderGuide);
			pstmt.setString(4,catalogloader);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
				if(rs.next())
				throw new IllegalArgumentException("Two Active Contracts found for Catalog_id = " + shoppingCatalogId);
			}
			pstmt.close();
			if(count > 0){
				pstmt = conn.prepareStatement(checkOrderGuide);
				pstmt.setString(1, catalogKey);
				pstmt.setInt(2, shoppingCatalogId);
				pstmt.setString(3,RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
				rs = pstmt.executeQuery();
				while(rs.next()){
					templateOrderGuideId = rs.getInt(1);
					if(rs.next())
					throw new IllegalArgumentException("Two Active order Guide found for Catalog_id = " + shoppingCatalogId);
				}
				pstmt.close();

				if(templateOrderGuideId > 0){
					updateTemplateOrderGuideDate(conn,templateOrderGuideId,catalogloader);
					createTemplateOrderGuideStruct(conn,templateOrderGuideId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);
				}else{
					templateOrderGuideId = createTemplateOrderGuide(conn,shoppingCatalogId,catalogKey,catalogloader);
					createTemplateOrderGuideStruct(conn,templateOrderGuideId,accRefNum,catalogKey,catalogloader,storeNum,tmpTableName);

				}

			}

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkCreateTemplateOrderGuide()=> "
                               + e.getMessage());
    	}
		log.info("checkCreateTemplateOrderGuide end return templateOrderGuideId=" + templateOrderGuideId);

	}


	public void updateTemplateOrderGuideDate(Connection conn,int templateOrderGuideId,String catalogloader) throws RemoteException{
		String updateorderGuide = "update clw_order_guide set mod_by = ?,mod_date = sysdate " +
				"where order_guide_id = ?";
		try{
			log.info("Start Update Order Guide Date");
			PreparedStatement pstmt = conn.prepareStatement(updateorderGuide);
			pstmt.setString(1,catalogloader);
			pstmt.setInt(2, templateOrderGuideId);
			pstmt.executeUpdate();
			pstmt.close();
		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.updateTemplateOrderGuideDate()=> "
                               + e.getMessage());
    	}
	}

        public void createTemplateOrderGuideStructByName(Connection conn,int templateOrderGuideId,String accRefNum,String orderGuideName,String catalogloader,int storeNum,String tmpTableName) throws RemoteException{
          log.info("createTemplateOrderGuideStructByName() order_guide_id = " + templateOrderGuideId);
          String selectDistSku = "select distinct  dist_sku,order_guide,uom,distributor from " + tmpTableName +" " +
              "where add_by = ?  " +
              "and account_ref_num = ? and order_guide_name = ? and upper(order_guide) = ?";

          try{
            // get order guide items
             DBCriteria dbc = new DBCriteria();
             dbc.addEqualTo(OrderGuideStructureDataAccess.ORDER_GUIDE_ID, templateOrderGuideId);
             IdVector ogItemIdV =OrderGuideStructureDataAccess.selectIdOnly(conn, OrderGuideStructureDataAccess.ITEM_ID,dbc);
             log.info("createTemplateOrderGuideStructByName()===> ogItemIdV = " + ((ogItemIdV!=null) ?ogItemIdV.toString(): "null"));

            PreparedStatement pstmt = conn.prepareStatement(selectDistSku);
                  pstmt.setString(1, catalogloader);
                  pstmt.setString(2, accRefNum);
                  pstmt.setString(3, orderGuideName);
                  pstmt.setString(4, "TRUE");
                  ResultSet rs = pstmt.executeQuery();
                  String distSku = "";
                  String orderGuideType = "";
                  String uom = "";
                  String distributor = "";
                  int itemId = 0;
                  boolean itemExist = false;
                  while(rs.next()){
                          distSku = rs.getString(1);
                          orderGuideType = rs.getString(2);
                          uom = rs.getString(3) ;
                          distributor = rs.getString(4);

                          itemId = getItemId(conn, distSku, distributor,uom, storeNum);//getItemId(conn,distSku,uom, storeNum);
                          itemExist = ogItemIdV!= null && ogItemIdV.contains(new Integer(itemId));
                          //itemCheck = checkIfOrderItemExist(conn,templateOrderGuideId,itemId);

                          if(! itemExist ){
                           log.info("createTemplateOrderGuideStructByName() : Add Item to Order Guide Template. orderGuideId = " + templateOrderGuideId);
                            OrderGuideStructureData ogsData = OrderGuideStructureData.createValue();
                            ogsData.setItemId(itemId);
                            ogsData.setOrderGuideId(templateOrderGuideId);
                            ogsData.setCategoryItemId(0);
                            ogsData.setQuantity(0);
                            ogsData.setAddBy(catalogloader);
                            ogsData.setAddDate(new Date());
                            ogsData.setModBy(catalogloader);
                            ogsData.setModDate(new Date());
                            OrderGuideStructureDataAccess.insert(conn, ogsData);
                          }
                  }
                  pstmt.close();

          }catch(Exception e){
          e.printStackTrace();
          //throw e;
             throw new RemoteException(
                 "Error.IntegrationServicesBean.createTemplateOrderGuideStruct()=> "
                         + e.getMessage());
           }


        }

	public void createTemplateOrderGuideStruct(Connection conn,int templateOrderGuideId,String accRefNum,String catalogKey,String catalogloader,int storeNum,String tmpTableName) throws RemoteException{
		log.info("createTemplateOrderGuideStruct order_guide_id = " + templateOrderGuideId);

		String selectDistSku = "select distinct  dist_sku,order_guide,uom,distributor from " + tmpTableName +" " +
		"where add_by = ?  " +
		"and account_ref_num = ? and catalog_key = ?";


/*		String insertOrderGuideStruct = "insert into clw_order_guide_structure(order_guide_structure_id,order_guide_id," +
				"item_id,category_id,quantity,add_date,add_by,mod_date,mod_by) " +
				"values(clw_order_guide_structure_seq.nextval,?,?,?,?,sysdate,?,sysdate,?)";
*/
		try{

			PreparedStatement pstmt = conn.prepareStatement(selectDistSku);
			pstmt.setString(1, catalogloader);
			pstmt.setString(2, accRefNum);
			pstmt.setString(3, catalogKey);
			ResultSet rs = pstmt.executeQuery();
			String distSku = "";
			String orderGuideType = "";
                        String uom = "";
                        String distributor = "";
			int itemId = 0;
			int itemCheck = 0;
			while(rs.next()){
				distSku = rs.getString(1);
				orderGuideType = rs.getString(2);
                                uom = rs.getString(3) ;
                                distributor = rs.getString(4);

				itemId = getItemId(conn, distSku, distributor,uom, storeNum);//getItemId(conn,distSku,uom, storeNum);
				itemCheck = checkIfOrderItemExist(conn,templateOrderGuideId,itemId);

				if(itemCheck == 0){
                                  OrderGuideStructureData ogsData = OrderGuideStructureData.createValue();
                                  ogsData.setItemId(itemId);
                                  ogsData.setOrderGuideId(templateOrderGuideId);
                                  ogsData.setCategoryItemId(0);
                                  ogsData.setQuantity(0);
                                  ogsData.setAddBy(catalogloader);
                                  ogsData.setAddDate(new Date());
                                  ogsData.setModBy(catalogloader);
                                  ogsData.setModDate(new Date());
                                  OrderGuideStructureDataAccess.insert(conn, ogsData);

				}

			}
  			pstmt.close();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.createTemplateOrderGuideStruct()=> "
                               + e.getMessage());
    	}

	}

	public int checkIfOrderItemExist(Connection conn,int templateOrderGuideId,int itemId) throws RemoteException{
		String selectOrderGuide = "select count(*) from clw_order_guide_structure where " +
				"order_guide_id = ? and item_id = ?";
		int itemCheck = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
			pstmt.setInt(1, templateOrderGuideId);
			pstmt.setInt(2,itemId);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				itemCheck = rs.getInt(1);
			}
			pstmt.close();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkIfOrderItemExist()=> "
                               + e.getMessage());
    	}
		return itemCheck;
	}

        private int getTemplateOrderGuideIdByName(Connection conn,int shoppingCatalogId, String orderGuideName, String loader) throws Exception{
          DBCriteria dbc = new DBCriteria();
          dbc.addEqualTo(OrderGuideDataAccess.CATALOG_ID, shoppingCatalogId);
          dbc.addEqualTo(OrderGuideDataAccess.ORDER_GUIDE_TYPE_CD, RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
          dbc.addEqualTo(OrderGuideDataAccess.SHORT_DESC, orderGuideName);
          IdVector idV =  OrderGuideDataAccess.selectIdOnly(conn, dbc);
          int templateOrderGuideId = 0;
          if (idV != null ){
            if (idV.size() > 1) {
              throw new IllegalArgumentException("More than 1 Order Guide Templates found. Catalog_id = " +  shoppingCatalogId + ", Order Guide name = " + orderGuideName);
            } else if (idV.size() >0){
              Integer idI = (Integer) idV.get(0);
              templateOrderGuideId = (idI != null) ? idI.intValue() : 0;
            }
          }
          if (templateOrderGuideId == 0){
             templateOrderGuideId= createTemplateOrderGuide(conn,shoppingCatalogId,orderGuideName,loader);
          }

          return templateOrderGuideId;
        }

      public int getTemplateOrderGuideId(Connection conn,int shoppingCatalogId) throws RemoteException{
		String selectOrderGuide = "select order_guide_id from clw_order_guide " +
				"where catalog_id = ? and order_guide_type_cd = ?";

		int templateOrderGuideId = 0;

		try{
			PreparedStatement pstmt = conn.prepareStatement(selectOrderGuide);
			pstmt.setInt(1, shoppingCatalogId);
			pstmt.setString(2, RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				templateOrderGuideId = rs.getInt(1);
				if(rs.next())
					throw new IllegalArgumentException("Error Two Order Guide Templates for Catalog_id = " + shoppingCatalogId);
			}
			pstmt.close();

		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.getTemplateOrderGuideId()=> "
                               + e.getMessage());
    	}


		return templateOrderGuideId;
	}

	public void processCatalogAssoc(Connection conn,String catalogassocloader,int storeNum) throws RemoteException{
		log.info("Process Catalog Assoc");
                String tempTable = "CLT_POLLOCK_CATALOG_ASSOC";

    	try{
              int storeCatalogId = getStoreCatalog(conn, storeNum);

              StringBuffer errMess = new StringBuffer();
// check : No (or multiple) Account Ref Num is found in the store (active or inactive)
              HashMap accMap= checkAllAccountRefNumFound(conn, storeNum, tempTable, errMess);
// check : No (or multiple) sites found with Site Ref Num found in the account (active or inactive)
//              HashMap siteMap= checkAllSiteRefNumFound(conn, storeNum, tempTable, errMess);
// check : Compatibility Site to Account
              HashMap siteMap= checkCompatibilitySiteToAccount( conn,   tempTable,  errMess);

// check : No (or multiple) catalogs found with Catalog Id  found with Buy List
              HashMap catalogMap= checkAllShoppingCatalogFound(conn, storeNum, "catalog_key", tempTable, errMess);
// check : No (or multiple) catalogs found with Catalog Id or buy lists found with Buy List
              HashMap buyListMap= checkAllShoppingCatalogFound(conn, storeNum, "buy_list", tempTable, errMess);
// check : No (or multiple) price lists(level 1) found with Price List (Level 1)
              HashMap priceList1Map= checkAllPriceListFound(conn, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST, 1, tempTable, errMess);
// check : No (or multiple) price lists(level 2) found with Price List (Level 2)
              HashMap priceList2Map= checkAllPriceListFound(conn, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST, 2, tempTable, errMess);
// check : No (or multiple) proprietary lists found with Proprietary List
              HashMap propietaryListMap= checkAllPriceListFound(conn, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PROPRIETARY_LIST, 0, tempTable, errMess);
              //-------------------
                if (Utility.isSet(errMess.toString())){
                  throw new RemoteException("^clw^"+errMess.toString()+"^clw^");
                }
              //-------------------
              processCatalogAssoc(conn, accMap, siteMap, catalogMap, storeNum, "catalog_key", catalogassocloader, tempTable);
              processCatalogAssoc(conn, accMap, siteMap, buyListMap, storeNum, "buy_list", catalogassocloader, tempTable);

              processPriceListAssoc(conn, accMap, siteMap, priceList1Map, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST, 1, catalogassocloader, tempTable);
              processPriceListAssoc(conn, accMap, siteMap, priceList2Map, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST, 2, catalogassocloader, tempTable);
              processPriceListAssoc(conn, accMap, siteMap, propietaryListMap, storeNum, RefCodeNames.PRICE_LIST_TYPE_CD.PROPRIETARY_LIST, 0, catalogassocloader, tempTable);



    	}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
                String errMess =  e.getMessage();
    		if (!e.getMessage().startsWith("^clw^")) {
                  errMess = "^clw^"+ "Error.IntegrationServicesBean.processCatalogAssoc()=> "+ e.getMessage()+ "^clw^";
    		}
                throw new RemoteException(errMess);
    	}
	}
        private void processCatalogAssoc(Connection conn, HashMap accMap, HashMap siteMap, HashMap catalogOrBuyListMap, int storeId, String attrName, String loader, String tempTable) throws Exception{
          log.info("processCatalogAssoc() ===> Begin for attrName =" + attrName);

           String selectDistinctCat = "select distinct account_ref_num,site_ref_num," +
                          attrName + " from " + tempTable +
                          " where " + attrName +" is not null";
           log.info("processCatalogAssoc() ===> selectDistinctCat SQL= "+selectDistinctCat);
           PreparedStatement pstmt =null;
           ResultSet rs = null;

           pstmt = conn.prepareStatement(selectDistinctCat);
           //pstmt.setString(1,catalogassocloader);
           rs = pstmt.executeQuery();
           String accRefNum = "";
           String siteRefNum = "";
           String catalogName = "";
//           String buyList = "";
           HashMap inboundSiteCatalogMap = new HashMap();
           HashSet catalogSet = null;

           while(rs.next()){

                   accRefNum = rs.getString(1);
                   siteRefNum = rs.getString(2)+"-"+accRefNum;
                   catalogName = rs.getString(3);
//                   buyList = rs.getString(4);

                   int siteId = (siteMap!= null  && siteMap.get(siteRefNum)!=null) ? ((Integer) siteMap.get(siteRefNum)).intValue() : 0;
                   int accountId = (accMap!=null && accMap.get(accRefNum)!= null) ? ((Integer) accMap.get(accRefNum)).intValue() : 0;
                   int catalogId = (catalogOrBuyListMap!= null && catalogOrBuyListMap.get(catalogName) != null) ? ( (Integer) catalogOrBuyListMap.get(catalogName)).intValue() : 0;

                   // create map of catalogs related to the site (INBOUND)
                   Integer site = new Integer(siteId);
                   if (!inboundSiteCatalogMap.containsKey(site)){
                      catalogSet = new HashSet();
                      inboundSiteCatalogMap.put(site, catalogSet );
                   }
                   catalogSet.add(new Integer(catalogId));
                   log.info("processCatalogAssoc() ===> inboundSiteCatalogMap = " + inboundSiteCatalogMap.toString());

                   //catalogId = getShoppingCatalogId(conn,accountId,catalogKey);

                   if(catalogId == 0){
                      log.info("Catalog Does't NOT EXIST for "+attrName+"= " + catalogName);
                   }else{
                      addUpdateCatalogAssoc(conn, siteId, catalogId, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE, loader);
                       //checkAndCreateSiteCatalogAssoc(conn,siteId,catalogId,loader);
                      checkAndCreateAccountCatalogAssoc(conn, storeId,accountId, siteId,catalogId,loader);
                   }

           }
           pstmt.close();
           String selectToDelete = "select distinct site_ref_key from ( select  site_ref_num||'-'||account_ref_num site_ref_key, max(catalog_key) cat, max(buy_list) buy from " +
               tempTable+ " group by site_ref_num, account_ref_num ) where cat is null and buy is null";

           IdVector siteV = getSitesToDeleteAssoc (conn, siteMap, selectToDelete);

           if (siteV!= null && siteV.size()> 0  ) {
             deleteSiteCatalogAssoc( conn, siteV, inboundSiteCatalogMap, attrName, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE, RefCodeNames.CATALOG_TYPE_CD.SHOPPING) ;
           }

           log.info("processCatalogAssoc() ===> End.");

        }

        private void processPriceListAssoc(Connection conn, HashMap accMap, HashMap siteMap, HashMap priceListMap, int storeId, String priceListTypeCd, int level, String loader, String tempTable) throws Exception{
          log.info("processPriceListAssoc() ===> Begin:" + " priceListTypeCd=" + priceListTypeCd+ ", level=" + level);

          String attrName = (level>0) ? priceListTypeCd +"_" + level : priceListTypeCd;
          String priceListAssocCd = (RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST.equals(priceListTypeCd)) ?
                                     RefCodeNames.PRICE_LIST_ASSOC_CD.PRICE_LIST_SITE :
                                     RefCodeNames.PRICE_LIST_ASSOC_CD.PROPRIETARY_LIST_SITE;

          String selectToAddUpdate = "select distinct account_ref_num,site_ref_num," +
                          attrName +"  from " + tempTable+
                          " where "+attrName+" is not null ";
          log.info("processPriceListAssoc() ===> selectToAddUpdate= "+selectToAddUpdate);


             //-------------------------Price List Assoc -------------//
             PreparedStatement pstmt =null;
             ResultSet rs = null;
             //  Create or Update Association for Site
             pstmt = conn.prepareStatement(selectToAddUpdate);
            // pstmt.setString(1, catalogassocloader);
             rs = pstmt.executeQuery();
             HashMap inboundSitePriceListMap = new HashMap();
             HashSet priceListSet = null;
             while (rs.next()) {
               String accRefNum = rs.getString(1);
               String siteRefKey = rs.getString(2)+"-"+rs.getString(1);
               String listName = rs.getString(3);

               int siteId = (siteMap!= null && siteMap.get(siteRefKey)!=null) ? ((Integer) siteMap.get(siteRefKey)).intValue() : 0;
               int accountId = (accMap!=null && accMap.get(accRefNum)!= null) ? ((Integer) accMap.get(accRefNum)).intValue() : 0;
               int listId = (priceListMap!=null && priceListMap.get(listName) != null) ? ((Integer) priceListMap.get(listName)).intValue() : 0;
               if (siteId == 0 || accountId==0 || listId==0)
            	   continue;
               // create map of price lists related to the site (INBOUND)
               Integer site = new Integer(siteId);
               if (!inboundSitePriceListMap.containsKey(site)){
                  priceListSet = new HashSet();
                  inboundSitePriceListMap.put(site, priceListSet );
               } else {
                 priceListSet = (HashSet)inboundSitePriceListMap.get(site);
               }
               priceListSet.add(new Integer(listId));
               log.info("processPriceListAssoc() ===> inboundSitePriceListMap = " + inboundSitePriceListMap.toString());

               if (listId == 0) {
                 log.info("Price List Does NOT EXIST "+attrName+" = " + listName);
               }
               else {
                 addUpdateSitePriceListAssoc(conn, siteId, listId, priceListAssocCd,level, loader);
               }
             }
             pstmt.close();

             // delete Association for Site if site has a record
             // with a list but related field in the file is blank
             String selectToDelete =  "select distinct site_ref_key from( "+
                 " select  site_ref_num||'-'||account_ref_num site_ref_key, max("+attrName+") attr from "+tempTable+" group by site_ref_num, account_ref_num) " +
                 " where attr is null ";

             IdVector siteV = getSitesToDeleteAssoc (conn, siteMap, selectToDelete);

             if (siteV !=null && siteV.size() > 0) {
               deleteSitePriceListAssoc( conn, siteV, inboundSitePriceListMap, priceListTypeCd, level, priceListAssocCd);
             }
             log.info("processPriceListAssoc() ===> End" );
      }

      private IdVector getSitesToDeleteAssoc(Connection conn, HashMap siteMap, String selectToDelete) throws Exception {
        log.info("processPriceListAssoc() ===> selectToDelete= "+selectToDelete);
        PreparedStatement pstmt = conn.prepareStatement(selectToDelete);
        ResultSet rs = pstmt.executeQuery();
        IdVector siteV = new IdVector();
        while (rs.next()) {
          String siteRefKey = rs.getString(1);
          Integer siteIdI = (Integer) siteMap.get(siteRefKey);
          if (siteIdI != null){
            siteV.add(siteIdI);
          }
        }
        pstmt.close();
        return siteV;

      }
      private void deleteSitePriceListAssoc(Connection conn, IdVector siteV, HashMap inboundSitePriceListMap, String priceListTypeCd, int level, String priceListAssocCd) throws Exception {
        log.info("deleteSitePriceListAssoc() ===> Begin." );
        DBCriteria dbc = new DBCriteria();
        dbc.addEqualTo(PriceListAssocDataAccess.PRICE_LIST_ASSOC_CD, priceListAssocCd);
        dbc.addOneOfIsolated(PriceListAssocDataAccess.CLW_PRICE_LIST_ASSOC, PriceListAssocDataAccess.BUS_ENTITY_ID, siteV);
        dbc.addJoinCondition(PriceListDataAccess.CLW_PRICE_LIST, PriceListDataAccess.PRICE_LIST_ID, PriceListAssocDataAccess.CLW_PRICE_LIST_ASSOC, PriceListAssocDataAccess.PRICE_LIST_ID);
        dbc.addJoinTableGreaterOrEqual(PriceListDataAccess.CLW_PRICE_LIST, PriceListDataAccess.PRICE_LIST_TYPE_CD, priceListTypeCd);
        dbc.addJoinTableGreaterOrEqual(PriceListDataAccess.CLW_PRICE_LIST, PriceListDataAccess.RANK, level);
        PriceListAssocDataVector plaDV =PriceListAssocDataAccess.select (conn, dbc);
        HashSet toDeleteAssocIds = new HashSet();
        for (int i = 0; plaDV != null && i < plaDV.size(); i++) {
          PriceListAssocData plaD = (PriceListAssocData)plaDV.get(i);
          Integer siteIdI = new Integer(plaD.getBusEntityId());
          Integer listIdI = new Integer(plaD.getPriceListId());

          if (!inboundSitePriceListMap.containsKey(siteIdI)){
            toDeleteAssocIds.add(new  Integer(plaD.getPriceListAssocId()));
          } else  {
            HashSet inboundPriceListIds = (HashSet)inboundSitePriceListMap.get(siteIdI);
            if (!inboundPriceListIds.contains(listIdI)) {
              toDeleteAssocIds.add(new  Integer(plaD.getPriceListAssocId()));
            }
          }
        }
        IdVector toDeleteAssocIdsV = new IdVector();
        toDeleteAssocIdsV.addAll(toDeleteAssocIds);
        log.info("deleteSitePriceListAssoc() ===> toDeleteAssocIdsV = " + toDeleteAssocIdsV.toString() );
        dbc = new DBCriteria();
        dbc.addOneOf(PriceListAssocDataAccess.PRICE_LIST_ASSOC_ID, toDeleteAssocIdsV);
        int dd= PriceListAssocDataAccess.remove(conn, dbc);
        log.info("deleteSitePriceListAssoc() ===>End. DELETED  dd= " + dd );


    }

       private void addUpdateSitePriceListAssoc (Connection conn, int siteId, int listId, String listAssocCd, int level, String loader) throws Exception {
         log.info("addUpdateSitePriceListAssoc() ===> Begin.");
          Date date = new Date();
          DBCriteria dbc = new DBCriteria();
          dbc.addEqualTo(PriceListAssocDataAccess.PRICE_LIST_ASSOC_CD, listAssocCd);
          if (listAssocCd.equals(RefCodeNames.PRICE_LIST_ASSOC_CD.PROPRIETARY_LIST_SITE)){
            dbc.addEqualTo(PriceListAssocDataAccess.PRICE_LIST_ID, listId);
          } else {
            String sql ="select price_list_id from CLW_PRICE_LIST where rank =" + level;
            dbc.addOneOf(PriceListAssocDataAccess.PRICE_LIST_ID, sql);
          }
          dbc.addEqualTo(PriceListAssocDataAccess.BUS_ENTITY_ID, siteId);
          PriceListAssocDataVector plaDV = PriceListAssocDataAccess.select(conn, dbc);

          if (plaDV ==null || plaDV.size() == 0){
            // Add
            PriceListAssocData plaD = PriceListAssocData.createValue() ;
            plaD.setBusEntityId (siteId);
            plaD.setPriceListId(listId);
            plaD.setPriceListAssocCd(listAssocCd);
            plaD.setAddBy(loader);
            plaD.setModBy(loader);
            plaD.setAddDate(date);
            plaD.setModDate(date);
            plaD = PriceListAssocDataAccess.insert(conn, plaD);
            log.info("addUpdateSitePriceListAssoc() ==> ADDED :  priceListId=" + listId + ", siteId="+ siteId +", priceListAssocCd ="+ listAssocCd);

          } else if (plaDV.size() > 1){
            throw new Exception ("^clw^"+ "More then 1 record found in CLW_PRICE_LIST_ASSOC. siteId="+siteId +", priceListId="+listId +", priceListAssocCd ="+ listAssocCd+"^clw^");
          } else {
            PriceListAssocData plaD = (PriceListAssocData)plaDV.get(0);
            if (listId != plaD.getPriceListId()){
              plaD.setPriceListId(listId);
              plaD.setModBy(loader);
              plaD.setModDate(date);
              int n = PriceListAssocDataAccess.update(conn, plaD);
              log.info("addUpdateSitePriceListAssoc() ==> UPDATED : old priceListId = " +plaD.getPriceListId() +" new priceListId=" + listId + ", siteId="+ siteId +", priceListAssocCd ="+ listAssocCd);
            }
          }
          log.info("addUpdateSitePriceListAssoc() ===> End.");

        }

        private void deleteSiteCatalogAssoc(Connection conn, IdVector siteV, HashMap inboundSiteCatalogMap, String attrName, String catalogAssocCd, String catalogTypeCd) throws Exception {
          log.info("deleteSiteCatalogAssoc() ===> Begin." );
          DBCriteria dbc = new DBCriteria();
          dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ASSOC_CD, catalogAssocCd);
//          dbc.addOneOf(CatalogAssocDataAccess.BUS_ENTITY_ID, siteV);
          dbc.addOneOfIsolated(CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.BUS_ENTITY_ID, siteV);
          dbc.addJoinCondition(CatalogDataAccess.CLW_CATALOG, CatalogDataAccess.CATALOG_ID, CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.CATALOG_ID);
          dbc.addJoinTableEqualTo(CatalogDataAccess.CLW_CATALOG, CatalogDataAccess.CATALOG_TYPE_CD, catalogTypeCd);
          CatalogAssocDataVector plaDV =CatalogAssocDataAccess.select (conn, dbc);
          HashSet toDeleteAssocIds = new HashSet();
          for (int i = 0; plaDV != null && i < plaDV.size(); i++) {
            CatalogAssocData plaD = (CatalogAssocData)plaDV.get(i);
            Integer siteIdI = new Integer(plaD.getBusEntityId());
            Integer catalogIdI = new Integer(plaD.getCatalogId());

            if (!inboundSiteCatalogMap.containsKey(siteIdI)){
              toDeleteAssocIds.add(new  Integer(plaD.getCatalogAssocId()));
            } else  {
              HashSet inboundCatalogIds = (HashSet)inboundSiteCatalogMap.get(siteIdI);
              if (!inboundCatalogIds.contains(catalogIdI)) {
                toDeleteAssocIds.add(new  Integer(plaD.getCatalogAssocId()));
              }
            }
          }
          IdVector toDeleteAssocIdsV = new IdVector();
          toDeleteAssocIdsV.addAll(toDeleteAssocIds);
          log.info("deleteSiteCatalogAssoc() ===> toDeleteAssocIdsV = " + toDeleteAssocIdsV.toString() );
          dbc = new DBCriteria();
          dbc.addOneOf(CatalogAssocDataAccess.CATALOG_ASSOC_ID, toDeleteAssocIdsV);
          int dd= CatalogAssocDataAccess.remove(conn, dbc);
          log.info("deleteSiteCatalogAssoc() ===>End. DELETED  dd= " + dd );


      }

	public void checkAndCreateSiteCatalogAssoc(Connection conn,int siteId,int catalogId,String catalogassocloader) throws RemoteException{

		//String selectSiteCatAssoc = "select count(*) from clw_catalog_assoc where catalog_id = ? and bus_entity_id = ?";
		String selectSiteCatAssoc = "select count(*) from clw_catalog_assoc where bus_entity_id = ?";
		String updateCatAssoc = "update clw_catalog_assoc set catalog_id = ?,mod_date=sysdate,mod_by=? where bus_entity_id = ?";
		Date runDate = new Date();
		log.info("Catalog_id = " + catalogId + "Site Id =" + siteId);
		try{
			PreparedStatement pstmt = conn.prepareStatement(selectSiteCatAssoc);
			//pstmt.setInt(1, catalogId);
			pstmt.setInt(1, siteId);
			int count = 0;
			ResultSet rs = pstmt.executeQuery();
			while(rs.next()){
				count = rs.getInt(1);
			}
			pstmt.close();

			if(count == 0){
				CatalogAssocData catalogAssocData = CatalogAssocData.createValue();
				catalogAssocData.setCatalogId(catalogId);
				catalogAssocData.setBusEntityId(siteId);
				catalogAssocData.setCatalogAssocCd(RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE);
				catalogAssocData.setAddBy(catalogassocloader);
				catalogAssocData.setAddDate(runDate);
				catalogAssocData.setModBy(catalogassocloader);
				catalogAssocData.setModDate(runDate);

				CatalogAssocDataAccess.insert(conn, catalogAssocData);
			}

			if(count == 1){
				pstmt = conn.prepareStatement(updateCatAssoc);
				pstmt.setInt(1, catalogId);
				pstmt.setString(2,catalogassocloader);
				pstmt.setInt(3, siteId);
				pstmt.executeUpdate();
			}

			if(count > 1){
				throw new IllegalArgumentException("Error Two Catalog's are associated with site id = " + siteId);
			}


		}catch(Exception e){
                  e.printStackTrace();
                  //throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.checkAndCreateSiteCatalogAssoc()=> "
                               + e.getMessage());
                }
	}
        private void addUpdateCatalogAssoc(Connection conn, int busEntityId, int catalogId, String assocCd, String loader) throws Exception {
          log.info("addUpdateCatalogAssoc() ===> Begin.");
          Date date = new Date();
          DBCriteria dbc = new DBCriteria();
          dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ASSOC_CD, assocCd);
          if (assocCd.equals(RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT)){
            dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ID, catalogId);
          }
          dbc.addEqualTo(CatalogAssocDataAccess.BUS_ENTITY_ID, busEntityId);
          log.info("addUpdateSiteCatalogAssoc() ==> select existing catalog: where clause SQL="+dbc.getWhereClause());

          CatalogAssocDataVector caDV = CatalogAssocDataAccess.select(conn, dbc);

          if (caDV ==null || caDV.size() == 0){
            // Add
            CatalogAssocData caD = addNewCatalogAssoc( conn, busEntityId, catalogId, assocCd, loader);
            log.info("addUpdateSiteCatalogAssoc() ==> ADDED :  catalogId=" + catalogId + ", busEntityId="+ busEntityId +", catalogAssocCd ="+ assocCd);
          } else if (caDV.size() > 1){
            throw new Exception ("^clw^"+ "More then 1 record found in CLW_CATALOG_ASSOC. busEntityId="+busEntityId +", catalogId="+catalogId +", catalogAssocCd ="+ assocCd+"^clw^");
          } else {
            CatalogAssocData caD = (CatalogAssocData)caDV.get(0);
            if (catalogId != caD.getCatalogId()){
              caD.setCatalogId(catalogId);
              caD.setModBy(loader);
              caD.setModDate(date);
              int n = CatalogAssocDataAccess.update(conn, caD);
              log.info("addUpdateCatalogAssoc() ==> UPDATED : old catalogId = " +caD.getCatalogId() +" new catalogId=" + catalogId + ", busEntityId="+ busEntityId +", assocCd ="+ assocCd);
            }
          }
          log.info("addUpdateCatalogAssoc() ===> End.");
        }

        private CatalogAssocData addNewCatalogAssoc(Connection conn, int busEntityId, int catalogId, String assocCd, String loader)  throws Exception {
          Date date = new Date();
          CatalogAssocData caD = CatalogAssocData.createValue() ;
          caD.setBusEntityId (busEntityId);
          caD.setCatalogId(catalogId);
          caD.setCatalogAssocCd(assocCd);
          caD.setAddBy(loader);
          caD.setModBy(loader);
          caD.setAddDate(date);
          caD.setModDate(date);
          caD = CatalogAssocDataAccess.insert(conn, caD);
          log.info("addCatalogAssoc() ==> ADDED CATALOG ASSOC:  catalogId=" + catalogId + ", busEntityId="+ busEntityId +", catalogAssocCd ="+ assocCd);
          return caD;
        }


        private void checkAndCreateAccountCatalogAssoc(Connection conn, int storeId, int accountId,int siteId,int catalogId,String loader) throws Exception{
              //create or update 'CATALOG_ACCOUNT' accociation
              addUpdateCatalogAssoc(conn, accountId, catalogId, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT, loader);

              // create ACCOUNT catalogs or update it's items
              DBCriteria dbc =  new DBCriteria();
              dbc.addJoinCondition(CatalogDataAccess.CLW_CATALOG, CatalogDataAccess.CATALOG_ID, CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.CATALOG_ID);
              dbc.addJoinTableEqualTo(CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.BUS_ENTITY_ID, accountId);
              dbc.addJoinTableEqualTo(CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.CATALOG_ASSOC_CD, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT);
              dbc.addEqualTo(CatalogDataAccess.CATALOG_TYPE_CD, RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
 //             dbc.addEqualTo(CatalogDataAccess.CATALOG_STATUS_CD, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
              CatalogDataVector cDV = CatalogDataAccess.select(conn, dbc);

              if (cDV ==null || cDV.size() == 0) {
                // create ACCOUNT catalog and 'CATALOG_STORE' & 'CATALOG_ACCOUNT' accociations for ACCOUNT catalog
                createAccountCatalogFromShopping(conn, storeId, accountId, siteId, catalogId, loader);
              } else if (cDV.size() > 1) {
                throw new Exception ("^clw^"+ "More then 1 ACCOUNT catalog found for accountId="+accountId +"^clw^");
              } else {
                CatalogData cD =  (CatalogData)cDV.get(0);
                int accountCatalogId = cD.getCatalogId();
                // add or delete items in ACCOUNT catalog according to site SHOPPING catalog
                updateAccountCatalogFromShopping(conn, accountCatalogId, accountId, siteId, catalogId, loader);
              }
         }

	public void processXpedxCatalog(Connection conn, String catalogloader,int storeNum) throws RemoteException{
		log.info("Process Xpedx Catalog");

		String selectNull = "select count(*) from clt_xpedx_catalog_loader " +
		"where add_by = ? " +
		"and (MASTER_CUSTOMER_NAME is null or ORDERLINE_ACCOUNT_NUMBER is null " +
		"or CATALOG_KEY is null or LOCALE is null or DIST_SKU is null or MFG_SKU is null or	" +
		"MANUFACTURER is null or DISTRIBUTOR is null or PACK is null or UOM is null or COST is null or " +
		"PRICE is null or CATEGORY is null or SHORT_DESCRIPTION is null or LONG_DESCRIPTION is null or " +
		"ITEM_SIZE is null or INVENTORY_ITEMS is null or AUTO_ORDER_ITEM is null or ADMIN_ONLY_ITEM is null)";

		String selectDistCheck = "select count(*) from CLT_POLLACK_ITEM_LOADER t where add_by = ? " +
		"and add_date >=trunc(sysdate) and not exists " +
		"(select short_desc from clw_bus_entity cbe where bus_entity_type_cd = ? and " +
		"upper(cbe.short_desc) = upper(t.distributor) " +
		"and cbe.bus_entity_id in " +
		"(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))";

		try{
	    	PreparedStatement pstmt = conn.prepareStatement(selectNull);
			pstmt.setString(1, catalogloader);
			ResultSet rs = pstmt.executeQuery();
			int count = 0;
			while(rs.next()){
				count = rs.getInt(1);
			}
			//log.info("Check 1, check if any of the mandatory field is not null  = " + selectNull);
			if (count > 0) {
				throw new IllegalArgumentException("CHECK 1111111111111111111111 Oneeeeee of the mandatory field is null" +  selectNull);
			} else{
				log.info("CHECK 1111111111111111111111 is success Counttttt is zero continue = " + count);
			}

			pstmt.close();


			pstmt = conn.prepareStatement(selectDistCheck);
			pstmt.setString(1, catalogloader);
			pstmt.setString(2, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
			pstmt.setInt(3, storeNum);
			rs = pstmt.executeQuery();
			count = 0;
			while(rs.next()){
				count = rs.getInt(1);

			}
			log.info("Check 3, check if all the Distributor are present  = " + selectDistCheck);
			if (count > 0) {
				throw new IllegalArgumentException("Error CHECK 333333333333 Distributor does not exists");
			} else{
				log.info("CHECK 22222222222222 Counttttt is zero continue = " + selectDistCheck);
			}
			pstmt.close();


		}catch(Exception e){
    		e.printStackTrace();
    		//throw e;
    		   throw new RemoteException(
                       "Error.IntegrationServicesBean.processXpedxCatalog()=> "
                               + e.getMessage());
    	}
	}

    public int processPricing (ContractItemPriceViewVector priceViewV, HashSet catalogKeys,  int storeId ) throws RemoteException{
         Connection conn = null;
         int recordsProcessed = -1;
         try {
           if (priceViewV != null && priceViewV.size() > 0){
             conn = getConnection();
             recordsProcessed = 0;
             ArrayList errors = new ArrayList() ;

             HashMap catalogKeyToContractIdMap = getContractIdsByCatalogKeys(conn, catalogKeys, storeId, errors);
             if (errors.size()== 0){
               HashMap<Integer,ContractItemPriceView > contractMap =  new HashMap();
               for (int i = 0; i < priceViewV.size(); i++) {
                 ContractItemPriceView priceView = (ContractItemPriceView)priceViewV.get(i);
                 Integer contractId = (Integer)catalogKeyToContractIdMap.get(priceView.getContractName());
                 updateContractItemPricing(conn, priceView, storeId, contractId.intValue(), errors);
               }
             }
             if (errors.size()>0){
               throw new RemoteException("^clw^"+errors.toString()+ "^clw^");
             }
           }
         } catch (Exception e) {
              throw processException(e);
          } finally {
              closeConnection(conn);
          }
          return recordsProcessed;
       }
   private int storeDistributor = 0;
    public int processBuyList (BuyListViewVector buyListVV,  int storeId , int distributorId, String loader) throws RemoteException{
       Connection conn = null;
       int recordsProcessed = -1;
       int MAX_ERR = 100;
       ArrayList errors = new ArrayList() ;
       try {
         if (buyListVV != null && buyListVV.size() > 0){
           conn = getConnection();
           recordsProcessed = 0;
           int storeCatalogId = getStoreCatalog(conn, storeId);
           log.info("processBuyList() ====> storeCatalogId= "+ storeCatalogId);
           HashMap storeItemCategoryAssocMap = getItemCategoryAssocMap(conn, storeCatalogId, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
           HashSet undefinedStoreItemCategoryAssoc = new HashSet();
           String errComment = "";
           // new catalogs
           HashMap newListNamesMap = new HashMap();
           HashSet newListNames = new HashSet();
           BuyListViewVector newListItems = null;

           HashMap existListNamesMap = new HashMap();
           BuyListViewVector existListItems = null;

           for (int i = 0; i < buyListVV.size(); i++) {
             BuyListView blV = (BuyListView)buyListVV.get(i);
             int catalogId = blV.getCatalogId();
             int itemId = blV.getItemId();
             //------ Check all category assoc exist for items in store catalog----
             if (!storeItemCategoryAssocMap.containsKey(new Integer(itemId))) {
               undefinedStoreItemCategoryAssoc.add(new Integer(itemId));
             }
             if (undefinedStoreItemCategoryAssoc.size() > MAX_ERR){
               errComment = " First "+MAX_ERR;
               break;
             } else if (undefinedStoreItemCategoryAssoc.size() >0){
               continue;
             }
             //-------------------------------------------------------------------
             if (catalogId == 0){
               if (!newListNamesMap.containsKey(blV.getListName())){
                 newListItems = new BuyListViewVector();
                 newListNamesMap.put(blV.getListName(), newListItems);
               } else {
                 newListItems = (BuyListViewVector)newListNamesMap.get(blV.getListName());
               }
               newListNames.add(blV.getListName());
               newListItems.add(blV);
             } else {
               Integer catId = new Integer(blV.getCatalogId());
               if (!existListNamesMap.containsKey(catId)){
                 existListItems = new BuyListViewVector();
                 existListNamesMap.put(catId, existListItems);
               } else {
                 existListItems =(BuyListViewVector)existListNamesMap.get(catId);
               }
               existListItems.add(blV);
             }
           }
           //------------------------------------------------------------------
           if (undefinedStoreItemCategoryAssoc.size()>0){
             String errMess = "Items do not have category assigned in Store Catalog."+errComment+ " Items ="+undefinedStoreItemCategoryAssoc.toString();
             throw new Exception("^clw^"+errMess+ "^clw^");
           }
           //-------------------------------------------------------------------
           log.info("processBuyList() ===> newListNames=" + newListNames.toString());
           log.info("processBuyList() ===> newListNamesMap=" + newListNamesMap.toString());
           if (newListNamesMap.size() > 0){
             createBuyListShoppingCatalog(conn, newListNamesMap, storeId, distributorId, storeCatalogId, loader, errors);
           }
           if (existListNamesMap.size() > 0){
              updateBuyListShoppingCatalog(conn, existListNamesMap, storeId, distributorId, storeCatalogId, loader, errors );
           }

           if (errors.size()>0){
             throw new Exception("^clw^"+errors.toString()+ "^clw^");
           }
        //   checkIntegrity(conn, newListNamesMap, existListNamesMap, storId, storeCatalogId, distributorId );
         }
       } catch (Exception  e) {
             e.printStackTrace() ;
             String errMess =  e.getMessage();
              if (!e.getMessage().startsWith("^clw^")) {
                errMess = "^clw^"+ "Error.IntegrationServicesBean.processBuyList()=> "+ e.getMessage()+ "^clw^";
              }
              throw new RemoteException(errMess);

    //        throw processException(e);
       } finally {
            closeConnection(conn);
       }
       return recordsProcessed;
    }

    public int processPricingList (PricingListViewVector priceListVV,  int storeId , int distributorId, String listType, String loader) throws RemoteException{
       
       log.info("processPricingList() ===> BEGIN");
       log.info("priceListVV.size()=" + priceListVV.size());
       //log.info("priceListVV=" + priceListVV);
           	
       Connection conn = null;
       int recordsProcessed = -1;
       ArrayList errors = new ArrayList() ;
       try {
         if (priceListVV != null && priceListVV.size() > 0){
           conn = getConnection();
           recordsProcessed = 0;
           // new Pricing/Proprietary Lists
           HashMap newListNamesMap = new HashMap();
           HashSet newListNames = new HashSet();
           PricingListViewVector newListItems = null;

           HashMap existListNamesMap = new HashMap();
           PricingListViewVector existListItems = null;

           for (int i = 0; i < priceListVV.size(); i++) {
             PricingListView plV = (PricingListView)priceListVV.get(i);
             int listId = plV.getListId();
             if (listId == 0){
               if (!newListNamesMap.containsKey(plV.getListName())){
                 newListItems = new PricingListViewVector();
                 newListNamesMap.put(plV.getListName(), newListItems);
               } else {
                 newListItems = (PricingListViewVector)newListNamesMap.get(plV.getListName());
               }
               newListNames.add(plV.getListName());
               newListItems.add(plV);
             } else {
               Integer listIdI = new Integer(plV.getListId());
               if (!existListNamesMap.containsKey(listIdI)){
                 existListItems = new PricingListViewVector();
                 existListNamesMap.put(listIdI, existListItems);
               } else {
                 existListItems = (PricingListViewVector)existListNamesMap.get(listIdI);
               }
               existListItems.add(plV);
             }
           }
           log.info("processPricingList() ===> newListNames=" + newListNames.toString());
           //log.info("processPricingList() ===> newListNamesMap=" + newListNamesMap.toString());
           
           //log.info("processPricingList() ===> =" + .toString());
           log.info("processPricingList() ===> existListNamesMap=" + existListNamesMap.toString());
           
           if (newListNamesMap.size() > 0){
              createPricingList(conn, newListNamesMap, storeId, listType, loader, errors);
           }
           if (existListNamesMap.size() > 0) {
              updatePricingList(conn, existListNamesMap, storeId, listType, loader, errors );
           }
           
           verifyPriceListAssocIntegrity (conn, listType);
                      
           //checkInputDataAgainstCreatedPriceListTbl(conn, listNames, listType);
           checkInputDataAgainstCreatedPriceListDetailTbl(conn, newListNamesMap, existListNamesMap, listType);
                      
           if (errors.size()>0){
             throw new RemoteException("^clw^"+errors.toString()+ "^clw^");
           }
         }
       } catch (Exception  e) {
             e.printStackTrace() ;
             String errMess =  e.getMessage();
              if (!e.getMessage().startsWith("^clw^")) {
                errMess = "^clw^"+ "Error.IntegrationServicesBean.processPricingList()=> "+ e.getMessage()+ "^clw^";
              }
              throw new RemoteException(errMess);
    //        throw processException(e);
       } finally {
            closeConnection(conn);
       }
       log.info("processPricingList() ===> END");
       return recordsProcessed;
    }

    // method checkPricingList() compares data from intput text file Pollock_PriceList.txt with the data
    // in the database after the Pollock_Price loader finishes its work, and reports discrepancies if it finds any
    public void checkInputDataAgainstCreatedPriceListTbl(Connection conn, ArrayList listNames, String listType) throws RemoteException{
       if (!RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST.equals(listType)){
    	   return;
       }
       log.info("checkInputDataAgainstCreatedPriceListTbl ====> BEGIN.");
       log.info("listNames.size()=" + listNames.size());
       log.info("listNames=" + listNames);
       
       StringBuffer stbListNames = new StringBuffer();
       if (listNames != null && listNames.size() > 0){
           stbListNames.append(listNames.get(0).toString());           
       }

       for (int i1 = 1; i1 < listNames.size(); i1++) {
    	   stbListNames.append(',');
           stbListNames.append(listNames.get(i1).toString()); 
       }
            	
       //Connection conn = null;
       int recordsProcessed = -1;
       ArrayList errors = new ArrayList() ;
       Statement stmt = null;
       ResultSet rs = null;
       IdVector v = null;
       //ArrayList v = new ArrayList();
       if (listNames != null && listNames.size() > 0){
         try {	  
            //conn = getConnection();
            recordsProcessed = 0;
            
            //DBCriteria dbc = new DBCriteria();
            String columnName = "SHORT_DESC";
            
            //dbc.addOneOf(columnName, listNames);
            //IdVector = PriceListdataAccess.selectIdOnly(conn, columnName, DBCriteria);
            
            String sql =
                "SELECT DISTINCT short_desc " +
                " FROM clw_price_list " +
                " WHERE short_desc in ( " +
                stbListNames.toString().trim() +
                " )";
            log.info(".checkPricingList ===> sql = " + sql);
            
              stmt = conn.createStatement();
              rs=stmt.executeQuery(sql);
              v = new IdVector();
              while (rs.next()) {
                  String x = new String(rs.getString(1));
                  v.add(x);
              }

              rs.close();
              stmt.close();
         } catch (Exception e) {
                 e.printStackTrace();
                 throw new RemoteException(e.getMessage());

         } 
         /***
          finally {

                 closeConnection(conn);
                 
         }
         ***/
         
         // find PriceList Names which exist in the Loader's input text file but are not found in the Database
         // after the Loader was executed
         ArrayList errorListNames = new ArrayList();
         for (int i = 0; i < listNames.size(); i++) {
                int flIdVector = 0;	//PriceList Name not found            
            	for (int j = 0; j < v.size(); j++) {
            		String listNamesString = listNames.get(i).toString().trim();
            		String vString = v.get(j).toString().trim();
            		if (listNamesString.equals(vString)) {
            			flIdVector = 1; //PriceList Name found    
            			break;
            		}
            	}
            	if (flIdVector == 0) { //PriceList Name from the input text file was not found in the Database
            		errorListNames.add(listNames.get(i));
            	}
         }
         if (errorListNames.size() > 0){
    	   throw new RemoteException( "^clw^PriceList Names which were not loaded from the input file are: " + errorListNames.toString() + "^clw^");
         }
       }
       
       log.info("checkInputDataAgainstCreatedPriceListTbl ====> END.");  
       
       //return recordsProcessed;
    }
    
    public void checkInputDataAgainstCreatedPriceListDetailTbl(Connection conn, HashMap newListNamesMap, HashMap existListNamesMap, String listType) throws RemoteException{
    	if (!RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST.equals(listType)){
    		     return;
        }
    	log.info("checkInputDataAgainstCreatedPriceListDetailTbl ====> BEGIN.");  
        log.info("newListNamesMap.size()=" + newListNamesMap.size());
        //log.info("newListNamesMap=" + newListNamesMap.toString());
        
        log.info("existListNamesMap.size()=" + existListNamesMap.size());
        //log.info("existListNamesMap=" + existListNamesMap.toString());
        
        HashMap incorrectExistPriceListDetailMap = new HashMap();
        HashMap incorrectNewPriceListDetailMap = new HashMap();
        
    	Iterator it = newListNamesMap.keySet().iterator();
        while (it.hasNext()) {  
          String priceListName = (String)it.next();
          PricingListViewVector newListItems = (PricingListViewVector) newListNamesMap.get(priceListName);
          int newListItemsSize = newListItems.size();
          IdVector itemNumV = null;
          ArrayList errorDistSkus = null;
          
          //find ALL the items' DIST_SKUs, associated with one ListName, in the clw_price_list_detail table
         try {
          String sqlNewListNames =
              "SELECT im.item_num from " +
              " clw_price_list_detail pld " +
              " , clw_price_list pl " +
              " , clw_item_mapping im " +
              " where pld.price_list_id in " + 
              " (" +
              " select price_list_id from clw_price_list " +
              "	  where short_desc in ('" + priceListName.trim()  + "')" +
              ")" +
              " and pld.price_list_id = pl.price_list_id " +
              " and pld.item_id = im.item_id " +
              " and im.item_mapping_cd = '"+RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR+"' ";
              
           //log.info(".checkInputDataAgainstCreatedPriceListDetailTbl => sqlNewListNames:" +sqlNewListNames);

           PreparedStatement pstmt = conn.prepareStatement(sqlNewListNames);
           ResultSet rs = pstmt.executeQuery();
           itemNumV = new IdVector();
           errorDistSkus = new ArrayList();
          
           while (rs.next()){
        	     String itemNum = rs.getString(1);        	     
        	     itemNumV.add(itemNum);
           }

           rs.close();
           pstmt.close();   
           
         } catch (Exception e) {
             e.printStackTrace();
             throw new RemoteException(e.getMessage());

         }   
         
         log.info("comparing data from input file and Database for priceList Name  = " + priceListName);         
         log.info("itemNumV.size() = " + itemNumV.size());
         log.info("newListItems.size() = " + newListItems.size());
         
         for (int i1 = 0; i1 < newListItems.size(); i1++) {
        	  int fl = 0; //distSku not found
        	  PricingListView pricingList = (PricingListView) newListItems.get(i1);
        	  String distSku = pricingList.getDistSku();
        	  for (int j1 = 0; j1 < itemNumV.size(); j1++) {
        		  if (distSku.equals((String) itemNumV.get(j1))) {
        			  fl = 1; //distSku found
        			  break;
        		  }
        	  }
          	  if (fl == 0) { //distSku from the input text file (newListItems only) was not found in the Database
          		errorDistSkus.add(distSku);
          	  }
         }
         if (errorDistSkus.size() > 0){
        	  incorrectNewPriceListDetailMap.put(priceListName, errorDistSkus);
         } //if
          
        } // while
        
    	Iterator it1 = existListNamesMap.keySet().iterator();
        while (it1.hasNext()) {  
          int priceListId1 = ((Integer) it1.next()).intValue();
          PricingListViewVector existListItems = (PricingListViewVector) existListNamesMap.get(priceListId1);
          IdVector itemNumV1 = null;
          ArrayList errorDistSkus1 = null;
          
          //find ALL the items' DIST_SKUs, associated with one ListName, in the clw_price_list_detail table
         try {
          String sqlExistListNames =
              "SELECT im.item_num from " +
              " clw_price_list_detail pld " +
              " , clw_price_list pl " +
              " , clw_item_mapping im " +
              " where pld.price_list_id = " + priceListId1 +
              " and pld.price_list_id = pl.price_list_id " +
              " and pld.item_id = im.item_id " +
              " and im.item_mapping_cd = '"+RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR+"' ";
              
          //log.info(".checkInputDataAgainstCreatedPriceListDetailTbl => sqlExistListNames :" + sqlExistListNames);

          PreparedStatement pstmt1 = conn.prepareStatement(sqlExistListNames);
          ResultSet rs1 = pstmt1.executeQuery();
          itemNumV1 = new IdVector();
          errorDistSkus1 = new ArrayList();
          
          while (rs1.next()){
        	     String itemNum1 = rs1.getString(1);        	     
        	     itemNumV1.add(itemNum1);
          }

          rs1.close();
          pstmt1.close();     
         } catch (Exception e) {
             e.printStackTrace();
             throw new RemoteException(e.getMessage());

         }  
         
         log.info("comparing data from input file and Database for priceListId = " + priceListId1);
         log.info("itemNumV1.size() = " + itemNumV1.size());
         log.info("existListItems.size() = " + existListItems.size());
         
         for (int i2 = 0; i2 < existListItems.size(); i2++) {
        	  int fl1 = 0; //distSku not found
        	  PricingListView pricingList1 = (PricingListView) existListItems.get(i2);
        	  String distSku1 = pricingList1.getDistSku();
        	  for (int j2 = 0; j2 < itemNumV1.size(); j2++) {
        		  if (distSku1.equals((String) itemNumV1.get(j2))) {
        			  fl1 = 1; //distSku found
        			  break;
        		  }
        	  }
          	  if (fl1 == 0) { //distSku from the input text file (newListItems only) was not found in the Database
          		errorDistSkus1.add(distSku1);
          	  }
         }
         if (errorDistSkus1.size() > 0){
        	  incorrectExistPriceListDetailMap.put(priceListId1, errorDistSkus1);
         } //if
          
        } // while  
		log.info("Not loaded (inserted) by the PricingListLoader NEW PriceList product items (clw_price_list_detail table): ");
        log.info("incorrectNewPriceListDetailMap.size() = " + incorrectNewPriceListDetailMap.size()); 
        log.info("incorrectNewPriceListDetailMap = " + incorrectNewPriceListDetailMap); 
        
		log.info("Not updated by the PricingListLoader EXISTING PriceList product items (clw_price_list_detail table): ");       
        log.info("incorrectExistPriceListDetailMap.size() = " + incorrectExistPriceListDetailMap.size());
        log.info("incorrectExistPriceListDetailMap = " + incorrectExistPriceListDetailMap);
        
        /***
        StringBuffer errMsg = new StringBuffer();
        if (incorrectExistPriceListDetailMap.size() > 0){
            errMsg.append("Not updated by the Loader  PriceList product items (clw_price_list_detail table): \n");            
        	Iterator incIt = incorrectExistPriceListDetailMap.keySet().iterator();
        	while(incIt.hasNext()) {
        		String key = ((Integer) incIt.next()).toString();
        		log.info("Not updated by the Loader PriceList product items (clw_price_list_detail table): PriceList Id = " + key + "; " + " DIST SKU = " + incorrectExistPriceListDetailMap.get(key).toString());
        		errMsg.append("PriceList Id = ").append(key).append("; ").append(" DIST SKU = ").append(incorrectExistPriceListDetailMap.get(key).toString()).append("\n");
        	}
        }        
        
        if (incorrectNewPriceListDetailMap.size() > 0){
            errMsg.append("Not loaded PriceList product items (clw_price_list_detail table): \n");            
        	Iterator incIt1 = incorrectNewPriceListDetailMap.keySet().iterator();
        	while(incIt1.hasNext()) {
        		String key = (String) incIt1.next();
        		log.info("Not loaded PriceList product items (clw_price_list_detail table): PriceList Name = " + key + "; " + " DIST SKU = " + incorrectNewPriceListDetailMap.get(key).toString());
        		errMsg.append("PriceList Name = ").append(key).append("; ").append(" DIST SKU = ").append(incorrectNewPriceListDetailMap.get(key).toString()).append("\n");
        	}
        }
        if(errMsg.toString().trim() != null && errMsg.toString().trim().length() > 0 && !errMsg.toString().trim().equals("")) {
    	   throw new RemoteException(errMsg.toString());
        }
        ***/
        
    	/***
        select pl.short_desc, im.item_num from 
        clw_price_list_detail pld
        , clw_price_list pl
        , clw_item_mapping im

        where pld.price_list_id in (
        select price_list_id from clw_price_list
        where short_desc in ( '0010000050SP')
        )
        and pld.price_list_id = pl.price_list_id 
        and pld.item_id = im.item_id
        and im.item_mapping_cd = 'ITEM_DISTRIBUTOR';
        ***/
        log.info("checkInputDataAgainstCreatedPriceListDetailTbl ====> END.");  
    }
    
    private HashMap getContractIdsByCatalogKeys(Connection conn, HashSet catalogKeys, int storeId, List errors) throws Exception {
        HashMap<String, Integer > catalogKeyToContractIdMap =  new HashMap();

        for (Iterator iter = catalogKeys.iterator(); iter.hasNext(); ) {
         String catalogKey = (String) iter.next();
         DBCriteria dbc = new DBCriteria();
         dbc.addEqualTo(CatalogAssocDataAccess.BUS_ENTITY_ID, storeId);
         String subSql = CatalogAssocDataAccess.getSqlSelectIdOnly(CatalogAssocDataAccess.CATALOG_ID, dbc);
         DBCriteria dbc1 = new DBCriteria();
         dbc1.addEqualTo(CatalogDataAccess.LOADER_FIELD, catalogKey);
         dbc1.addEqualTo(CatalogDataAccess.CATALOG_TYPE_CD, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
         dbc1.addEqualTo(CatalogDataAccess.CATALOG_STATUS_CD, RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
         dbc1.addOneOf(CatalogDataAccess.CATALOG_ID, subSql);
         IdVector catIds = CatalogDataAccess.selectIdOnly(conn, dbc1);
         if (catIds == null || catIds.size() == 0){
           errors.add("***No shopping catalogs found for CatalogKey =" + catalogKey + "\n");
//           throw new Exception("^clw^No shopping catalogs found for CatalogKey =" + catalogKey + "^clw^"  );
         } else  if (catIds.size() > 1){
           errors.add("***Multiple shopping catalogs found for CatalogKey =" + catalogKey+ "\n");
//           throw new Exception("^clw^Multiple shopping catalogs found for CatalogKey =" + catalogKey+ "^clw^"  );
         } else {
           // getting contract Id
           dbc = new DBCriteria();
           dbc.addEqualTo(ContractDataAccess.CATALOG_ID, catIds.get(0) );
           IdVector contractIds = ContractDataAccess.selectIdOnly(conn, dbc);
           if (contractIds == null || contractIds.size() == 0){
             errors.add("***No contracts found for CatalogKey =" + catalogKey+"\n" );
//            throw new Exception("^clw^No contracts found for CatalogKey =" + catalogKey+"^clw^"  );
           } else  if (contractIds.size() > 1){
             errors.add("***Multiple contracts found for CatalogKey =" + catalogKey+ "\n");
//            throw new Exception("^clw^Multiple contracts found for CatalogKey =" + catalogKey+ "^clw^"  );
           }
           Integer contractId = (Integer)contractIds.get(0);
           if (contractId != null && contractId.intValue()> 0) {
             catalogKeyToContractIdMap.put(catalogKey, contractId);
           } else {
             errors.add("***Can't find Contract Id for CatalogKey =" + catalogKey +"\n");
//            throw new Exception("^clw^Can't find Contract Id for CatalogKey =" + catalogKey +"^clw^"  );
           }
         }
        }

        return catalogKeyToContractIdMap;
      }

       private void updateContractItemPricing(Connection conn, ContractItemPriceView priceView, int storeId, int contractId, List errors) throws Exception {
         if (priceView != null) {
           String itemKey = priceView.getDistName() + "'/'" +priceView.getItemCustSku() + "'/'" + priceView.getItemUom() + "'";
           String key = /*storeId + "+'" + */priceView.getContractName()+"'/'" +itemKey;
           // getting items collection for
           int itemId = 0;
           try {
             itemId = getItemId(conn, priceView.getItemCustSku(), priceView.getDistName(), priceView.getItemUom(), storeId );
           }catch (Exception ex){
             errors.add (ex.getMessage());
             return;
           }
           if (itemId == 0 ){
             errors.add ("***Item not found for key(distributor/dist_sku/UOM) = " + itemKey + "\n");
             return;
           }
           // update contract_item pricing
           DBCriteria dbc = new DBCriteria();
           dbc.addEqualTo(ContractItemDataAccess.CONTRACT_ID, contractId);
           dbc.addEqualTo(ContractItemDataAccess.ITEM_ID, itemId);
           ContractItemDataVector contractItemV = ContractItemDataAccess.select(conn, dbc);

           if (contractItemV == null || contractItemV.size() ==0){
             errors.add ("***No Contract Items found for key(Contract Name/distributor/dist_sku/UOM) = " + key + "\n");
             return;
 //            throw new Exception( "^clw^No Contract Items found for key = " + key + "^clw^");
           }
           for (int i = 0; i < contractItemV.size(); i++) {
             ContractItemData contractItem = (ContractItemData)contractItemV.get(i);
             contractItem.setAmount(priceView.getPrice());
             contractItem.setDistCost(priceView.getDistCost());
             ContractItemDataAccess.update(conn, contractItem);
           }
         }
      }


      private int getItemId(Connection conn, String distSku, String distributor, String uom, int storeNum) throws Exception{
              String key = "'" + distributor + "'/'" +distSku + "'/'" + uom + "'";
              String sql =
                      "SELECT item_id " +
                      "  FROM clw_item " +
                      " WHERE item_id IN ( " +
                          "SELECT item_id " +
                          " FROM clw_item_mapping im, clw_bus_entity ba, clw_bus_entity_assoc " +
                          "WHERE im.bus_entity_id = ba.bus_entity_id " +
                          //"  AND bus_entity_type_cd = '"  + RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR + "'" +
                          "  AND bus_entity_type_cd = ? " +
                          "  AND ba.bus_entity_id = bus_entity1_id  " +
                          //"  AND bus_entity2_id = "+ storeNum +
                          "  AND bus_entity2_id = ? " +
                          //"  AND UPPER(BA.SHORT_DESC) = UPPER('" +distributor + "')" +
                          "  AND UPPER(BA.SHORT_DESC) = ? " +
                          //"  AND BA.BUS_ENTITY_STATUS_CD = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"'" +
                          "  AND BA.BUS_ENTITY_STATUS_CD = ? "  +
                          //(Utility.isSet(uom) ?"  AND UPPER(NVL(item_uom,'NULL')) = UPPER('" + uom +"')" : "") +
                          (Utility.isSet(uom) ?"  AND UPPER(NVL(item_uom,'NULL')) = ? " : "") +
                          //"  AND NVL(item_num,'NULL') = '" + distSku + "' ) " +
                          "  AND NVL(item_num,'NULL') = ? )" +
                       //"  AND item_status_cd ='" + RefCodeNames.ITEM_STATUS_CD.ACTIVE + "'";
                       "  AND item_status_cd = ? ";

              int itemId = 0;

              PreparedStatement st = null;
              ResultSet rs = null;
              try{
                st = conn.prepareStatement(sql);

                int i = 1;
                st.setString(i++, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
                st.setInt(i++, storeNum);
                st.setString(i++, distributor.toUpperCase());
                st.setString(i++, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
                if (Utility.isSet(uom)) st.setString(i++, uom.toUpperCase());
                st.setString(i++, distSku);
                st.setString(i++, RefCodeNames.ITEM_STATUS_CD.ACTIVE);

                rs = st.executeQuery();
                int count = 0;
                if (rs ==null){
                  throw new IllegalArgumentException( "***No items found for (distributor/dist_sku/UOM) = " + key+"\n");
                }
                while(rs.next()){
                    itemId = rs.getInt(1);
                    if(rs.next()) {
                      throw new IllegalArgumentException( "***Multiple items found for (distributor/dist_sku/UOM) = " + key+"\n");
                    }
                }
              } catch (SQLException e) {
                   e.printStackTrace();
                   throw new SQLException(e.getMessage());
               } finally {
                   if (rs != null) {
                       rs.close();
                   }
                   if (st != null) {
                       st.close();
                   }
               }
               if (itemId == 0) {
                 throw new IllegalArgumentException( "***No items found for (distributor/dist_sku/UOM) = " + key+"\n");
               }

               return itemId;
      }

      public void processNSCSapCatalog(Connection conn,String catalogloader,int storeNum, String tempTable )
	        throws Exception, RemoteException{

         String selectAccCat = "select distinct account_ref_num,catalog_key,order_guide_name from " + tempTable + " " +
                      "where add_date >= trunc(sysdate) and add_by = ?";

//              String selectStoreCatalog = "select catalog_id from clw_catalog where catalog_id in" +
//              "(select catalog_id from clw_catalog_assoc where bus_entity_id = ?) " +
//              "and catalog_type_cd = ? and catalog_status_cd = ?";

              int storeCatalogId = getStoreCatalog(conn, storeNum);
              StringBuffer errMess = new StringBuffer();
              PreparedStatement pstmt = null;
              ResultSet rs = null;
              try{
// check : all Accounts are present
                  errMess.append(checkAllAccountsExists(conn, storeNum, catalogloader,tempTable));
// check : all Distributors are present
                  errMess.append(checkAllDistributorsExists(conn, storeNum, catalogloader,tempTable));
// check : unique Dist keys
                  errMess.append(checkUniqueDistKeys(conn, storeNum, catalogloader,tempTable));
// check : Cost Centers are not different across category- Already implemented in InboundNSCSapCatalog.
//                  errMess.append(checkCostCenterNotDifferentAcrossCategory(conn, storeNum, catalogloader,tempTable));
// check : all Cost Centers are present
                  errMess.append(checkAllCostCenterKeyExists(conn, storeNum, catalogloader,tempTable));
// check : all Categories are present and create category if nessesary
                  try {
                    checkCreateCategories(conn, storeNum, storeCatalogId, catalogloader, tempTable, errMess);
                  } catch (Exception ex) {
                                          ex.printStackTrace();
                      //throw new RemoteException(ex.getMessage(), ex);
                                          throw ex;
                  }
// check : all Dist SKUs are present and create master items if nessesary
                  try {
                    checkCreateMasterItemsByDistKeys(conn, storeNum, storeCatalogId, catalogloader, tempTable, errMess);
                  } catch (Exception ex) {
					  ex.printStackTrace();
                      //throw new RemoteException(ex.getMessage(), ex);
					  throw ex;
                  }
//-------------------
                  if (Utility.isSet(errMess.toString())){
                    //throw new RemoteException("^clw^"+errMess.toString()+ "^clw^");
					throw new Exception("^clw^"+errMess.toString()+ "^clw^");
                  }
//-------------------
                 HashMap<String,HashSet> catalogCostCenersMap = getCatalogCostCentersMap (conn,catalogloader, tempTable);
                 HashMap<String,Integer> costCenterKeyToIdMap = null;// NSC doesn't use loader to populate cost_centers; //getCostCenterKeyToIdMap(conn,catalogloader, tempTable);

                 pstmt = conn.prepareStatement(selectAccCat);
                  pstmt.setString(1, catalogloader);
                  rs = pstmt.executeQuery();


                      int catalogId = 0;

                      while(rs.next()){
                              String accRefNum = "";
                              String catalogKey = "";
                              String orderGuideName = "";
                              String costCenterKey = "";
                              int accountId = 0;
                              int accountCatalogId = 0;
                              int shoppingCatalogId = 0;
                              int contractId = 0;
                              int templateOrderGuideId = 0;
                              int costCenterId = 0;

                              accRefNum = rs.getString(1);
                              catalogKey = rs.getString(2);
                              orderGuideName = rs.getString(3);
              //                costCenterKey=rs.getString(3);

                              accountId = getAccountId(conn,accRefNum,storeNum);
                              accountCatalogId = getAccountCatalogId(conn,accountId);
                              shoppingCatalogId = getShoppingCatalogId(conn,accountId,catalogKey);


                              if(accountCatalogId == 0){
                                      accountCatalogId = createAccountCatalog(conn,accountId,storeNum,catalogloader);

                                      createCatlogStructure(conn,accountId,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum, tempTable, costCenterKeyToIdMap);
                              }else{
                                      updateAccountCatalogStructure(conn,accountCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum, tempTable, costCenterKeyToIdMap);
                              }

                              if(shoppingCatalogId == 0){
                                      shoppingCatalogId = createShoppingCatalog(conn,accountId,storeNum,catalogloader,catalogKey,accRefNum, tempTable);
                                      createCatlogStructure(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum, tempTable, null);
                                      contractId = createContract(conn,shoppingCatalogId,catalogKey,storeNum,catalogloader);
                                      createContractItem(conn,contractId,accRefNum,catalogKey,storeNum,catalogloader, tempTable);
//                                      templateOrderGuideId = createTemplateOrderGuide(conn,shoppingCatalogId,catalogKey,catalogloader);
                                      templateOrderGuideId = createTemplateOrderGuide(conn,shoppingCatalogId,orderGuideName,catalogloader);
                                      createTemplateOrderGuideStructByName(conn,templateOrderGuideId,accRefNum,orderGuideName,catalogloader,storeNum, tempTable);

                              }else{
                                      deleteCatalogStructure(conn,shoppingCatalogId);
                                      createCatlogStructure(conn,accountId,shoppingCatalogId,storeCatalogId,accRefNum,catalogKey,catalogloader,storeNum, tempTable, null);
                                      contractId = getContractId(conn,shoppingCatalogId);
                                      deleteContractItem(conn,contractId);
                                      createContractItem(conn,contractId,accRefNum,catalogKey,storeNum,catalogloader, tempTable);
       //                               templateOrderGuideId = getTemplateOrderGuideId(conn,shoppingCatalogId);
                                      templateOrderGuideId = getTemplateOrderGuideIdByName(conn, shoppingCatalogId,orderGuideName , catalogloader);
                                      createTemplateOrderGuideStructByName(conn,templateOrderGuideId,accRefNum,orderGuideName,catalogloader,storeNum, tempTable);
                              }
                              // creating catalog-costCenter Association for account Catalog
                              HashSet costCenterKeysHS = catalogCostCenersMap.get(catalogKey);
                              if (costCenterKeysHS != null && costCenterKeysHS.size() >0) {
                                createCatalogCostCenterAssoc(conn, costCenterKeysHS, accountCatalogId, catalogloader);
                              }
                            // freight table key - ignore
                      }

                      pstmt.close();

              }catch(SQLException e){
              e.printStackTrace();
              //throw e;
                 throw new RemoteException(
                     "Error.IntegrationServicesBean.processNSCSapCatalog()=> "
                             + e.getMessage());
      }

      }

      public void processNSCSapSite(Connection conn, String siteloader, String siteActionAdd,String siteActionChange, String siteActionDelete, int storeNum, String tempTable) throws RemoteException{
           boolean ifSiteExists;
           StringBuffer errMess = new StringBuffer();;

           try{

               String selectDistictAcc = "select distinct account_ref_num,site_ref_num, account_id, site_id from " + tempTable + " "+
               "where add_by = ? and action in(?,?) and add_date >= trunc(sysdate)";

               //Site to Inactivate
               String selectsiteInactivate = "select distinct account_ref_num,site_ref_num, account_id, site_id from " + tempTable + " "+
               "where add_by = ? and action in(?) and add_date >= trunc(sysdate)";

               PreparedStatement pstmt = null;
               ResultSet rs = null;
               int count = 0;
               /*--------------------------------------------------------*/
               // Check : all Accounts are present
//               errMess.append(checkAllAccountsExists(conn, storeNum, siteloader,tempTable));
               HashMap accountMap = getAccountsByAccRefNumMap(conn, storeNum, siteloader, tempTable, errMess);
               // Check : all catalogs are exists for Catalog Keys
               HashMap siteToAccCatalogMap = createSiteToAccCatalogMap(conn, storeNum, siteloader, tempTable, errMess);

               /*--------------------------------------------------------*/
               if (Utility.isSet(errMess.toString())){
                throw new RemoteException("^clw^"+errMess.toString()+ "^clw^");
              }
              //---------------------------------------------------------//
               ArrayList actionList = new  ArrayList();
               actionList.add(siteActionAdd);
               actionList.add(siteActionChange);
               // update temporrary table with existing site Ids by site ref num values
               int toUpdateSiteCount = updateTempTabSiteIdsBySiteRefNums(conn, storeNum, siteloader, tempTable, errMess);
               if (toUpdateSiteCount > 0) {
                 updateSites(conn, actionList, siteloader, tempTable);
               }
               // generate new site Ids into temporrary table with update flag - 'NEW'
               int toCreateSiteCount = genNewSiteIdsIntoTempTab( conn, tempTable);
               if (toCreateSiteCount > 0) {
                 createSites( conn,  actionList,   siteloader, tempTable);
               }
  //

               pstmt = conn.prepareStatement(selectDistictAcc);
               pstmt.setString(1, siteloader);
               pstmt.setString(2, siteActionAdd);
               pstmt.setString(3,siteActionChange);
               rs = pstmt.executeQuery();
               String accRefNum;
               String siteRefNum;
               int accountId ;
               int siteId ;
               while(rs.next()){
                 accRefNum = rs.getString(1);
                 siteRefNum = rs.getString(2);
                 accountId = rs.getInt(3);
                 siteId = (rs.getString(4)==null) ? 0 : rs.getInt(4);
                 // create catalog_site association
//                 accountId = ((Integer)accountMap.get(accRefNum));

                 HashMap accCatalogKeyMap = (HashMap)siteToAccCatalogMap.get(siteRefNum);
                 if (accCatalogKeyMap != null && accCatalogKeyMap.get(accountId) != null) {
                   int catalogId =((Integer)accCatalogKeyMap.get(accountId)).intValue()  ;
                   createOrUpdateCatalogSiteAssoc(conn, siteId, catalogId,siteloader);
                 }
               }
               pstmt.close();

               /*--------------------------------------------------------*/
               inactivateSites(conn, siteActionDelete, storeNum,siteloader, tempTable);

             }catch(SQLException e){
              e.printStackTrace();
              throw new RemoteException("Error.IntegrationServicesBean.processNSCSapSite()=> " + e.getMessage());
           }finally{
               if (conn != null) {
                 closeConnection(conn);
               }
           }
       }
       //****************

        public void processNSCSapAccount(Connection conn, String accountloader, String accountActionAdd,String accountActionChange, String accountActionDelete, int storeNum, String tempTable) throws RemoteException{
             String country1 = "US";
             String country2 = "USA";
             String country3 = "UNITED STATES";
             boolean ifaccountExists;

             try{


                             //action = A or C
                             String selectDistinctAccount = "select account_ref_num from " + tempTable + " " +
                             "where add_by = ? and add_date >=trunc(sysdate) and action in(?,?)";

                             String selectDistinctAccountCancel = "select account_ref_num from " + tempTable + " " +
                             "where add_by = ? and add_date >=trunc(sysdate) and action in(?)";

                     PreparedStatement pstmt = null;
                     ResultSet rs = null;
                     int count = 0;

                 /*-----------------------------------------------------------------------------------*/
                 pstmt = conn.prepareStatement(selectDistinctAccount);
                 pstmt.setString(1,accountloader);
                 pstmt.setString(2,accountActionAdd);
                 pstmt.setString(3,accountActionChange);
                 rs = pstmt.executeQuery();

                 String accRefNum = "";
                 while(rs.next()){
                         //log.info("Check 4 if Account Already Exists = " + rs.getString(1));
                         accRefNum = rs.getString(1);

                         //log.info("This is Account: = " + rs.getString(1) );
                         ifaccountExists = accountCheck(accountloader,accountActionAdd,accountActionChange,accountActionDelete,storeNum,accRefNum,conn);
                         if(ifaccountExists){
                           updateAccount(accountloader,accountActionAdd,accountActionChange,storeNum,accRefNum,conn, tempTable);

                         } else {
                           createAccount(accountloader,accountActionAdd,accountActionChange,storeNum,accRefNum,conn, tempTable);
                         }
                 }
                 pstmt.close();
                 /*-----------------------------------------------------------------------------------*/

                 pstmt = conn.prepareStatement(selectDistinctAccountCancel);
                 pstmt.setString(1,accountloader);
                 pstmt.setString(2,accountActionDelete);
                 rs = pstmt.executeQuery();

                 while(rs.next()){
                   accRefNum = rs.getString(1);
                   inactivateAccount(accountloader,accountActionDelete,storeNum,accRefNum,conn);
                 }

                 pstmt.close();
             }catch(SQLException e){
                     e.printStackTrace();
                     //throw e;
                        throw new RemoteException(
                        "Error.IntegrationServicesBean.processNSCSapAccount()=> "
                                + e.getMessage());
             }finally{
                     if (conn != null)
                             //conn.close();
                             closeConnection(conn);
             }
         }

    public void updateFiscalCalendar(Connection conn, int accountId, String fiscalCalendarYear, String fiscalCalendarStart, String fiscalCalendarPeriod, String accountloader ) throws RemoteException{
       Date runDate = new Date();
       String selectFiscalCalenderId = "select fiscal_calender_id, eff_date from clw_fiscal_calender where bus_entity_id = ? " +
               " and fiscal_year = ?";

       String selectActualFiscalCalendar = "select fiscal_calender_id, fiscal_year, eff_date from clw_fiscal_calender where eff_date =(" +
           " select max(eff_date) from clw_fiscal_calender where bus_entity_id = " + accountId +" and eff_date <= sysdate" +
           " ) " ;

       String deleteFiscalCalenderDetail = "delete from clw_fiscal_calender_detail where fiscal_calender_id = ?";

       String insertFiscalCalenderDetail = "insert into clw_fiscal_calender_detail(fiscal_calender_detail_id," +
       "fiscal_calender_id,period,mmdd,add_date,add_by,mod_date,mod_by) " +
       "values(clw_fiscal_calender_detail_seq.nextval,?,?,?,sysdate,'" + accountloader + "'," +
       "sysdate,'" + accountloader + "')";

try{
      DateFormat df = new SimpleDateFormat("dd/MM/yyyy");
       //Update Fiscal Calender
       if(fiscalCalendarYear != null && fiscalCalendarStart != null){

       PreparedStatement pstmt = null;
       ResultSet rs = null;
       Date fiscalStartDate = null;
       int fiscalYear = Integer.parseInt(fiscalCalendarYear);
       try {
       fiscalStartDate = df.parse(fiscalCalendarStart);
       }catch(Exception exc) {};
       int  fiscalStartDateYear = Utility.getYearForDate(fiscalStartDate);

       Date currentDate = new Date();
//      int currentYear = Integer.parseInt(dfYear.format(currentDate)) ;
       int currentYear = Utility.getCurrentYear();


       if (fiscalYear == 0){
         selectFiscalCalenderId = selectFiscalCalenderId +" and eff_date = to_date('"+fiscalCalendarStart+"', 'dd/MM/yyyy')";
       }
       int fiscalCalenderId = 0;
       Date effDate = null;
       pstmt = conn.prepareStatement(selectFiscalCalenderId);
       pstmt.setInt(1, accountId);
       pstmt.setInt(2, fiscalYear);

       rs = pstmt.executeQuery();
       while(rs.next()){
               fiscalCalenderId = rs.getInt(1);
               effDate = rs.getDate(2);
       }

       pstmt = conn.prepareStatement(selectActualFiscalCalendar);
       rs = pstmt.executeQuery();
       int actualFiscalCalendarId= 0;
       Date actualEffDate = null;
       int actualFiscalCalendarYear = 0;
       while(rs.next()){
             actualFiscalCalendarId = rs.getInt(1);
             actualFiscalCalendarYear = rs.getInt(2);
             actualEffDate =rs.getDate(3);
       }
//       int actualEffDateYear = Utility.getYearForDate(actualEffDate);

      //---------------------------------------------------------------------------//
      boolean toAdd = false;
      boolean toUpdate = false;
      boolean error = false;


      boolean isExistFCYear =  (fiscalCalenderId > 0);
      String errMess = "";
      if (actualFiscalCalendarId == 0  ){
        toAdd = (fiscalCalenderId == 0);
        toUpdate = (fiscalCalenderId > 0);
      } else {  //exists Actual FC
        if (fiscalCalenderId == 0){ // not found FC to update
          toAdd = (fiscalStartDate.after(actualEffDate));
          error = (fiscalStartDate.before(actualEffDate));
          errMess = "Fiscal calendar can't have Start Date("+fiscalCalendarStart+") before then Start Date of actual fiscal calendar: " +df.format(actualEffDate) ;
        } else { //FC to update has been found
          if (fiscalYear == 0) {
            // update(eff_date, periods) or create new calendar if file_calendar_start_date >= max(eff_date_bd) for account
            toAdd = (fiscalStartDate.after(actualEffDate));
            toUpdate = (fiscalStartDate.equals(actualEffDate));
            error = (fiscalStartDate.before(actualEffDate));
            errMess = "Fiscal calendar of '0' can't have Start Date("+fiscalCalendarStart+") before then Start Date of actual fiscal calendar: " +df.format(actualEffDate) ;
          } else {
            // update(eff_date, periods) if file_calendar_start_date > current_date and file_calendar_year >= current_year for account
            toUpdate = (fiscalStartDate.after(currentDate)) && (fiscalYear >= currentYear);
            error = (fiscalYear < actualFiscalCalendarYear);
            errMess = "Fiscal Calendar Year "+ fiscalYear +" updates are not allowed. Only years"+ actualFiscalCalendarYear+ " and later can be modified.";
          }
        }
      }

 /*     if ( actualFiscalCalendarId == fiscalCalenderId){
        if (fiscalYear == 0) {
          // update(eff_date, periods) or create new calendar if calendar_start_date >= max(calendar_start_date_bd) for account
          toAdd = (fiscalStartDate.after(actualEffDate));
          toUpdate = (fiscalStartDate.equals(actualEffDate));
         }
        else {
          // update(eff_date, periods) or create new calendar if calendar_year >= calendar_year_bd for account
          toUpdate = (fiscalStartDate.before(currentDate)) && (fiscalYear >= currentYear);
         }
      } else {
        if (fiscalCalenderId != 0 ) {
          toUpdate = (fiscalYear >= currentYear) && (effDate.after(currentDate));
        } else {
          toAdd = (fiscalYear >= currentYear) ;
        }
      }
 */
      error &= !toUpdate && !toAdd;
       if (error) {
         throw new IllegalArgumentException("^clw^Impossible to add/update FISCAL CALENDAR." + errMess+ ".^clw^");
       }
       //--------------------------------------------------------------------------//
       if( toAdd){
              FiscalCalenderData fiscalCalenderData = FiscalCalenderData.createValue();
               fiscalCalenderData.setBusEntityId(accountId);
               fiscalCalenderData.setShortDesc(fiscalCalendarYear);
               fiscalCalenderData.setPeriodCd("MONTHLY");
               fiscalCalenderData.setEffDate(fiscalStartDate);
               fiscalCalenderData.setAddDate(runDate);
               fiscalCalenderData.setAddBy(accountloader);
               fiscalCalenderData.setModDate(runDate);
               fiscalCalenderData.setModBy(accountloader);
               fiscalCalenderData.setFiscalYear(fiscalYear);
               fiscalCalenderData = FiscalCalenderDataAccess.insert(conn, fiscalCalenderData);
               fiscalCalenderId = fiscalCalenderData.getFiscalCalenderId();
               ///========Add Fiscal Calender Detail====================
               pstmt = conn.prepareStatement(insertFiscalCalenderDetail);
               pstmt.setInt(1,fiscalCalenderId);
               String fcd[] = fiscalCalendarPeriod.split(",");
               int fPeriod = 0;
               for(String fc:fcd) {
                   fc = fc.trim();
                   fPeriod = fPeriod + 1;
                   pstmt.setInt(2,fPeriod);
                   pstmt.setString(3, fc);
                   pstmt.addBatch();
               }
               pstmt.executeBatch();
      }else if (toUpdate){
    	FiscalCalenderData fiscalCalenderData = null;
    	try{
        fiscalCalenderData = FiscalCalenderDataAccess.select(conn, fiscalCalenderId);
    	}catch(Exception exc){};
        fiscalCalenderData.setEffDate(fiscalStartDate);
        FiscalCalenderDataAccess.update(conn, fiscalCalenderData);

        pstmt = conn.prepareStatement(deleteFiscalCalenderDetail);
        pstmt.setInt(1,fiscalCalenderId);
        pstmt.addBatch();
        pstmt.executeBatch();

         pstmt = conn.prepareStatement(insertFiscalCalenderDetail);
         pstmt.setInt(1,fiscalCalenderId);
         String fcd[] = fiscalCalendarPeriod.split(",");
         int fPeriod = 0;
         for(String fc:fcd) {
           fc = fc.trim();
           fPeriod = fPeriod + 1;
           pstmt.setInt(2,fPeriod);
           pstmt.setString(3, fc);
           pstmt.addBatch();

         }
         pstmt.executeBatch();
      }
      pstmt.close();
    }
   // pstmt.close();
}catch(SQLException e){
    e.printStackTrace();
    //throw e;
       throw new RemoteException(
       "Error.IntegrationServicesBean.updateFiscalCalendar()=> "
               + e.getMessage());
}
  }

  private String checkAllAccountsExists(Connection conn, int storeNum, String loader, String tempTable) throws SQLException{
    String selectAccCheck =
       " select distinct account_ref_num  from  " + tempTable + " t "+
       " minus "+
       " select  distinct clw_value  from clw_property p, clw_bus_entity be, clw_bus_entity_assoc bea, " + tempTable + " t "+
       " where clw_value is not null "+
       "  and p.bus_entity_id = be.bus_entity_id "+
       "  and p.bus_entity_id = bea.bus_entity1_id "+
       "  and p.short_desc = '" +RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM +"' "+
       "  and be.bus_entity_id = bea.bus_entity1_id "+
       "  and be.bus_entity_type_cd = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT +"' "+
       "  and bea.bus_entity2_id = ?  "+
       "  and bea.BUS_ENTITY_ASSOC_CD = '" + RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE + "' "+
       "  and t.account_ref_num =clw_value ";

//    log.info("checkAllAccountsExists() => SQL : " + selectAccCheck);
   log.info("checkAllAccountsExists(): ===> Begin.");
    StringBuffer errMess = new StringBuffer();
    PreparedStatement pstmt = conn.prepareStatement(selectAccCheck);
    pstmt.setInt(1, storeNum);
    ResultSet rs = pstmt.executeQuery();
    Set undefindAcc = new HashSet();
    while (rs.next()) {
      undefindAcc.add(rs.getString(1));
    }

    if (undefindAcc.size() > 0){
      errMess.append("***Account(s) with the following Account Ref Num(s) "+undefindAcc.toString() +" does not exists.");
    }
    log.info("checkAllAccountsExists(): ===> End.");

    pstmt.close();
    return errMess.toString();
  }

  private String checkAllDistributorsExists(Connection conn, int storeNum, String loader, String tempTable) throws SQLException {
    String selectDistCheck = "select distributor from " + tempTable + " t where (1=1) "+// add_by = ? and add_date >=trunc(sysdate)" +
        " and not exists " +
        "(select short_desc from clw_bus_entity cbe where bus_entity_type_cd = ? and " +
        "upper(cbe.short_desc) = upper(t.distributor) " +
        "and cbe.bus_entity_id in " +
        "(select bus_entity1_id from clw_bus_entity_assoc where bus_entity2_id = ?))";
 //   log.info("checkAllDistributorsExists(): SQL = " + selectDistCheck);
    log.info("checkAllDistributorsExists():===> Begin.");
    StringBuffer errMess = new StringBuffer();
    PreparedStatement pstmt = conn.prepareStatement(selectDistCheck);

  //  pstmt.setString(1, loader);
    pstmt.setString(1, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
    pstmt.setInt(2, storeNum);
    ResultSet rs = pstmt.executeQuery();
    Set undefindDist = new HashSet();
    while (rs.next()) {
      undefindDist.add(rs.getString(1));
    }
    if (undefindDist.size() > 0) {
      errMess.append("***Distributor(s) with the following Name(s) " +
                     undefindDist.toString() + " does not exists.");
    }
    log.info("checkAllDistributorsExists():===> End.");

    pstmt.close();
    return errMess.toString();
  }
 private String checkAllDistSkuExists (Connection conn, int storeNum, String loader, String tempTable) throws SQLException {
   String selectDistSkuCheck = "select distributor, dist_sku, uom from " + tempTable +" t " +
       " where (1=1) " +//add_by = ? and add_date >=trunc(sysdate) " +
       " and not exists " +
       "(select item_id from clw_item where item_id in "+
       "(select item_id from  clw_item_mapping where item_num = t.dist_sku and UPPER(item_uom) = UPPER(t.uom) " +
       " and item_num is not null and item_uom is not null "  +
       " and bus_entity_id in(select bus_entity_id from clw_bus_entity  where bus_entity_type_cd = ? " +
       "  AND UPPER(SHORT_DESC) = UPPER(t.distributor)" +
       "  AND BUS_ENTITY_STATUS_CD = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"'" +
       " and bus_entity_id in(select bus_entity1_id "+
       "from clw_bus_entity_assoc where bus_entity2_id = ?))) "+
       "and item_status_cd = ?  )";

//   log.info("checkAllDistSkuExists(): SQL = " + selectDistSkuCheck);
   log.info("checkAllDistSkuExists():  ====> Begin. ");
   StringBuffer errMess = new StringBuffer();
   PreparedStatement pstmt = conn.prepareStatement(selectDistSkuCheck);
//   pstmt.setString(1, loader);
   pstmt.setString(1, RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR);
   pstmt.setInt(2, storeNum);
   pstmt.setString(3, RefCodeNames.ITEM_STATUS_CD.ACTIVE);
   ResultSet rs = pstmt.executeQuery();

   Set undefinedDistSku = new HashSet();

   while(rs.next()){
     undefinedDistSku.add(rs.getString(1) + "/" +rs.getString(2) +"/"+ rs.getString(3));
   }
   if (undefinedDistSku.size() > 0) {
    errMess.append("***No Item(s) found for the following Keys (Distributor/Dist SKU/UOM): " +   undefinedDistSku.toString()  );
  }
  log.info("checkAllDistSkuExists():  ====> End. ");

   pstmt.close();
   return errMess.toString();

 }

 private String checkUniqueDistKeys (Connection conn, int storeNum, String loader, String tempTable) throws SQLException {
   String selectUniqueCheck =
  "select t.distributor, t.dist_sku, t.uom , cnt from " + tempTable +" t, "+
  " (select distributor, dist_sku, uom, count(i.item_id) cnt "+
  " from clw_item i, clw_item_mapping im, " + tempTable +" t "+
  " where i.item_id = im.item_id "+
  "  and  im.item_num = t.dist_sku "+
  "  and UPPER(item_uom) = UPPER(t.uom) "+
  "  and I.ITEM_STATUS_CD=  '"+RefCodeNames.ITEM_STATUS_CD.ACTIVE+"' " +
  "  and bus_entity_id in ( "+
  "     select bus_entity_id from clw_bus_entity be, clw_bus_entity_assoc bea "+
  "     where be.bus_entity_id = bea.bus_entity1_id "+
  "     and BUS_ENTITY_STATUS_CD = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE + "'" +
  "     and bus_entity_type_cd ='"+RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR + "' " +
  "     and bus_entity2_id = ? "+
  "     and UPPER(SHORT_DESC) = UPPER(t.distributor) "+
  "  ) group by  distributor, dist_sku, uom "+
  ")  a "+
 " where (1=1) "+ //add_by = ? and add_date >=trunc(sysdate) "+
 " and a.distributor = t.distributor " +
 " and a.dist_sku = t.dist_sku " +
 " and a.uom = t.uom " +
 " and cnt >1 ";
//  log.info("checkUniqueDistKeys(): SQL = " + selectUniqueCheck);
  log.info("checkUniqueDistKeys(): ===> Begin.");
  StringBuffer errMess = new StringBuffer();
  PreparedStatement pstmt = conn.prepareStatement(selectUniqueCheck);
  pstmt.setInt(1, storeNum);
  ResultSet rs = pstmt.executeQuery();

  Set nonuniqKeys = new HashSet();

  while(rs.next()){
    nonuniqKeys.add(rs.getString(1) + "/" +rs.getString(2) +"/"+ rs.getString(3));
  }
  if (nonuniqKeys.size() > 0) {
   errMess.append("***Multiple Item(s) found for the following Keys (Distributor/Dist SKU/UOM): " +   nonuniqKeys.toString()  );
 }
 log.info("checkUniqueDistKeys(): ===> End.");

  pstmt.close();
  return errMess.toString();

}


 private String checkAllCostCenterKeyExists (Connection conn, int storeNum, String loader, String tempTable) throws SQLException {
  String selectCostCenterCheck = "select cost_center_key from " + tempTable +" t " +
      " where cost_center_key is not null and (1=1) " +//add_by = ? and add_date >=trunc(sysdate) "+
      " and not exists " +
      "(select cost_center_id from clw_cost_center where NVL(cost_center_code,'NULL') = t.cost_center_key and store_id = ?) ";

//  log.info("checkAllCostCenterKeyExists(): SQL = " + selectCostCenterCheck);
  log.info("checkAllCostCenterKeyExists(): ===> Begin.");
  StringBuffer errMess = new StringBuffer();
  PreparedStatement pstmt = conn.prepareStatement(selectCostCenterCheck);
//  pstmt.setString(1, loader);
  pstmt.setInt(1, storeNum);
  ResultSet rs = pstmt.executeQuery();

  Set undefinedCostCenters = new HashSet();

  while(rs.next()){
    if (rs.getString(1) != null ){
      undefinedCostCenters.add(rs.getString(1));
    }
  }
  if (undefinedCostCenters.size() > 0) {
   errMess.append("***No Cost Center(s) found for the following Cost Center Key(s) " +   undefinedCostCenters.toString()  );
 }
 log.info("checkAllCostCenterKeyExists(): ===> End.");

  pstmt.close();
  return errMess.toString();

}
private String checkCostCenterNotDifferentAcrossCategory (Connection conn, int storeNum, String loader, String tempTable) throws SQLException {
  String selectCostCenterCheck = "select cost_center_key, category_name from " + tempTable + " where add_by = ? and add_date >=trunc(sysdate) and cost_center_key is not null";

  log.info("checkCostCenterNotDifferentAcrossCategory (): SQL = " + selectCostCenterCheck);
  StringBuffer errMess = new StringBuffer();
  PreparedStatement pstmt = conn.prepareStatement(selectCostCenterCheck);
  pstmt.setString(1, loader);
  ResultSet rs = pstmt.executeQuery();

  HashMap<String,HashSet> checkMap = new HashMap<String,HashSet>();

  HashSet costCenterHS = null;

  while(rs!=null && rs.next()){
    String costCenter =rs.getString(1) ;
    String category =rs.getString(2) ;
    if (checkMap.containsKey(category)){
      costCenterHS = (HashSet)checkMap.get(category);
      costCenterHS.add(costCenter);
    } else {
      costCenterHS = new HashSet();
      costCenterHS.add(costCenter);
    }
    checkMap.put(category, costCenterHS);
  }
  log.info("checkCostCenterNotDifferentAcrossCategory (): checkMap.size() = " + checkMap.size());

  if (checkMap.size() > 0) {
    Set keys = checkMap.keySet();
    if (keys != null) {
      for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
        String category = (String)iter.next();
        HashSet ccHS = (HashSet)checkMap.get(category);
        if (ccHS != null && ccHS.size()> 1){
          errMess.append("***Multiple Cost Centers "+ccHS.toString()+ " found for the following category: " +   category  );
        }
      }
    }
  }

  pstmt.close();
  return errMess.toString();

}
 private void  createCatalogCostCenterAssoc(Connection conn, HashSet costCenterKeyHS, int accountCatalogId, String catalogloader) throws SQLException{
   log.info("createCatalogCostCenterAssoc(): ===> Begin. Account catalog id =" + accountCatalogId );

   List costCenterKeys = new ArrayList();
   costCenterKeys.addAll(costCenterKeyHS);
   String costCenterKeysStr = IdVector.toCommaString(costCenterKeys);

   int costCenterId = 0;
   DBCriteria dbc = new DBCriteria();

   dbc.addOneOf(CostCenterDataAccess.COST_CENTER_CODE, costCenterKeysStr);
   IdVector costCenterIds = CostCenterDataAccess.selectIdOnly(conn, dbc);
   log.info("createCatalogCostCenterAssoc(): Inbound Cost centers: costCenterIds.toString() = " + costCenterIds.toString());

   //check for existence
   dbc = new DBCriteria();
   dbc.addEqualTo(CostCenterAssocDataAccess.CATALOG_ID,accountCatalogId);
//   dbc.addOneOf(CostCenterAssocDataAccess.COST_CENTER_ID,costCenterIds );
   dbc.addEqualTo(CostCenterAssocDataAccess.COST_CENTER_ASSOC_CD, RefCodeNames.COST_CENTER_ASSOC_CD.COST_CENTER_ACCOUNT_CATALOG);
   CostCenterAssocDataVector ccadV = CostCenterAssocDataAccess.select(conn, dbc);

   IdVector costCenterIdsToAdd = new IdVector();
   IdVector costCenterIdsToDelete = new IdVector();
   IdVector ccIdV  = new IdVector();
   if ( ccadV != null && !ccadV.isEmpty() ){
     for (int j = 0; j <  ccadV.size(); j++) {
       CostCenterAssocData ccad = (CostCenterAssocData)ccadV.get(j);
       Integer idI = new Integer(ccad.getCostCenterId());
       if (!ccIdV.contains(idI)){
         ccIdV.add(idI);
       }
     }
     log.info("createCatalogCostCenterAssoc(): DB Cost centers:  ccIdV.toString() = " + ccIdV.toString());
   }

   if (costCenterIds != null ) {
     costCenterIdsToAdd.addAll(costCenterIds);
     costCenterIdsToDelete.addAll(ccIdV);
     boolean toAdd = costCenterIdsToAdd.removeAll(ccIdV);
     boolean toDelete = costCenterIdsToDelete.removeAll(costCenterIds);
     log.info("createCatalogCostCenterAssoc()==>  to add : costCenterIdsToAdd.toString() = " + costCenterIdsToAdd.toString());
     log.info("createCatalogCostCenterAssoc()==>  to delete : costCenterIdsToDelete.toString() = " + costCenterIdsToDelete.toString());
   }

   if (costCenterIdsToAdd != null && !costCenterIdsToAdd.isEmpty() ) {
     log.info("createCatalogCostCenterAssoc(): costCenterIdsToAdd.toString() = " + costCenterIdsToAdd.toString());
     for (int i = 0; i < costCenterIdsToAdd.size(); i++) {
       CostCenterAssocData ccad = CostCenterAssocData.createValue();
       ccad.setAddBy(catalogloader);
       ccad.setAddDate(new Date());
       ccad.setCatalogId(accountCatalogId);
       ccad.setCostCenterId(((Integer)costCenterIdsToAdd.get(i)).intValue());
       ccad.setCostCenterAssocCd(RefCodeNames.COST_CENTER_ASSOC_CD.COST_CENTER_ACCOUNT_CATALOG);
       CostCenterAssocDataAccess.insert(conn, ccad);
     }
    }
    if (costCenterIdsToDelete != null && !costCenterIdsToDelete.isEmpty()) {
      log.info("createCatalogCostCenterAssoc(): costCenterIdsToDelete.toString() = " + costCenterIdsToDelete.toString());
        dbc = new DBCriteria();
        dbc.addEqualTo(CostCenterAssocDataAccess.CATALOG_ID,accountCatalogId);
        dbc.addOneOf(CostCenterAssocDataAccess.COST_CENTER_ID, costCenterIdsToDelete );
        dbc.addEqualTo(CostCenterAssocDataAccess.COST_CENTER_ASSOC_CD, RefCodeNames.COST_CENTER_ASSOC_CD.COST_CENTER_ACCOUNT_CATALOG);
        CostCenterAssocDataAccess.remove(conn, dbc);
     }
    log.info("createCatalogCostCenterAssoc(): ===> End.");
 }
 private HashMap<String,HashSet> getCatalogCostCentersMap (Connection conn, String loader, String tempTable) throws SQLException {
   HashMap<String,HashSet> map =new HashMap<String,HashSet>();
   HashSet costCenterHS = null;
   String selectCostCentersSql = "select catalog_key, cost_center_key from " + tempTable + " where add_by = ? and add_date >=trunc(sysdate) and cost_center_key is not null";
   PreparedStatement pstmt = conn.prepareStatement(selectCostCentersSql);
   pstmt.setString(1, loader);
   ResultSet rs = pstmt.executeQuery();
   while(rs!=null && rs.next()){
     String costCenterKey = rs.getString(2);
     String catalogKey = rs.getString(1);
     if (map.containsKey(catalogKey)){
       costCenterHS = (HashSet)map.get(catalogKey);
       costCenterHS.add(costCenterKey);
     } else {
       costCenterHS = new HashSet();
       costCenterHS.add(costCenterKey);
     }
     map.put(catalogKey, costCenterHS);
   }
   log.info("getCatalogCostCentersMap(): map = " + map.toString());

   return map;
 }

 private HashMap getAccountsByAccRefNumMap(Connection conn, int storeNum, String loader, String tempTable, StringBuffer errMess) throws SQLException{
   log.info("getAccountsByAccRefNumMap() ===> Begin.");
   HashMap accMap = new HashMap();
   String checkMultipleSql = " select clw_value, count(*) from clw_property p, clw_bus_entity be, clw_bus_entity_assoc bea " +
       " where clw_value is not null "+
      "  and p.bus_entity_id = be.bus_entity_id "+
      "  and p.bus_entity_id = bea.bus_entity1_id "+
      "  and p.short_desc = '" +RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM +"' "+
      "  and be.bus_entity_id = bea.bus_entity1_id "+
      "  and be.bus_entity_type_cd = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT +"' "+
      "  and bea.bus_entity2_id = " + storeNum+
      "  and bea.BUS_ENTITY_ASSOC_CD = '" + RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE + "' "+
      "  and clw_value in (select distinct account_ref_num from "+tempTable+") " +
      " group by clw_value "+
      " HAVING COUNT(*) > 1 ";

  log.info("getAccountsByAccRefNumMap() ===> checkMultipleSql =" + checkMultipleSql);
  PreparedStatement pstmt = conn.prepareStatement(checkMultipleSql);
  ResultSet rs = pstmt.executeQuery();
  ArrayList multipleAccRefNums = new ArrayList();
  while (rs.next()) {
    multipleAccRefNums.add(rs.getString(1));
  }
  if (multipleAccRefNums.size() > 0){
    errMess.append("***Multiple Account(s) found for the following Account Ref Num(s) "+multipleAccRefNums.toString() );
  }

  String updateSql =
       " update " + tempTable +" t set t.account_id =  (" +
       " select  distinct p.bus_entity_id  from clw_property p, clw_bus_entity be, clw_bus_entity_assoc bea " +
       " where clw_value is not null "+
       "  and p.bus_entity_id = be.bus_entity_id "+
       "  and p.bus_entity_id = bea.bus_entity1_id "+
       "  and p.short_desc = '" +RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM +"' "+
       "  and be.bus_entity_id = bea.bus_entity1_id "+
       "  and be.bus_entity_type_cd = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT +"' "+
       "  and bea.bus_entity2_id =" + storeNum +
       "  and bea.BUS_ENTITY_ASSOC_CD = '" + RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE + "' "+
       "  and t.account_ref_num =clw_value "+
       ((multipleAccRefNums.size()>0) ? "  and clw_value not in ("+IdVector.toCommaString(multipleAccRefNums) +")" :"")+" )";

   log.info("getAccountsByAccRefNumMap() ===>  updateSql =" + updateSql);
   pstmt = conn.prepareStatement(updateSql);
   int n = pstmt.executeUpdate();
   pstmt.close();
   log.info("getAccountsByAccRefNumMap() => Account Ids updated = " +n);

   String selectAcc ="select account_ref_num,  account_id from " + tempTable +
       " where  add_by = ? and add_date >= trunc(sysdate) " ;

   pstmt = conn.prepareStatement(selectAcc);
   pstmt.setString(1, loader);
   rs = pstmt.executeQuery();

   Set undefindAcc = new HashSet();
   while (rs.next()) {
     String accountRefNum = rs.getString(1);
     Integer accountId =( Utility.isSet(rs.getString(2))) ? new Integer(rs.getString(2)) : new Integer("0") ;
     if (accountId.intValue() == 0){
       undefindAcc.add(accountRefNum);
     } else {
       accMap.put(accountRefNum, accountId);
     }
   }
   if (undefindAcc.size() > 0){
     errMess.append("***Account(s) with the following Account Ref Num(s) "+undefindAcc.toString() +" does not exists.");
   }

   pstmt.close();
   log.info("getAccountsByAccRefNumMap() => accMap : " + accMap.toString());

   return accMap;
  }

  private HashMap createSiteToAccCatalogMap(Connection conn,  int storeNum, String loader, String tempTable, StringBuffer errMess) throws SQLException {
    HashMap siteToAccCatalogMap = new HashMap();
    String selectSql = "select t.site_ref_num, t.catalog_key, t.ACCOUNT_ID, acc.catalog_id from " + tempTable + " t,   " +
      " (select c.catalog_id, loader_field,  ca.bus_entity_id from clw_catalog c, clw_catalog_assoc ca  " +
      " where  c.catalog_id = CA.CATALOG_ID   " +
       " and CA.CATALOG_ASSOC_CD=  ? " +
       " and C.CATALOG_TYPE_CD= ? " +
       " and loader_field is not null " +
       ") acc " +
     " where add_by = ? and add_date >= trunc(sysdate)   " +
      " and acc.bus_entity_id(+) =T.ACCOUNT_ID  " +
      " and  acc.loader_field(+) =NVL(T.catalog_key, 'NULL') " ;
   PreparedStatement pstmt = conn.prepareStatement(selectSql);
   pstmt.setString(1, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT );
   pstmt.setString(2, RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
   pstmt.setString(3, loader);
   ResultSet rs = pstmt.executeQuery();
   HashMap accCatalogMap = null;
   HashMap undefinedCatalogMap = new HashMap();
   while (rs!=null && rs.next()) {
     accCatalogMap = new HashMap();
     String siteRefNum = rs.getString(1);
     String catalogKey = rs.getString(2);
     Integer accountId = new Integer(rs.getInt(3));
     Integer catalogId =( Utility.isSet(rs.getString(4))) ? new Integer(rs.getString(4)) : new Integer("0") ;
     if (Utility.isSet(catalogKey))  {
       if ( catalogId.intValue() == 0) {
         undefinedCatalogMap.put(siteRefNum, catalogKey);
       }
       else {
         accCatalogMap.put(accountId, catalogId);
         siteToAccCatalogMap.put(siteRefNum, accCatalogMap);
       }
     }
   }
    if (undefinedCatalogMap.size() > 0){
      errMess.append("***Impossible to create association between Site Ref Nums and Catalog Keys pairs: " + undefinedCatalogMap.toString() );
    }
    pstmt.close();
    return siteToAccCatalogMap;
  }
  private void createOrUpdateCatalogSiteAssoc(Connection conn, int siteId, int catalogId, String loader ) throws SQLException, RemoteException {

    CatalogAssocData caD = CatalogAssocData.createValue();
    caD.setBusEntityId(siteId);
    caD.setCatalogId(catalogId);
    caD.setCatalogAssocCd(RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE);

    DBCriteria dbc = new DBCriteria();
    dbc.addEqualTo(CatalogAssocDataAccess.BUS_ENTITY_ID, siteId);
    //dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ID, catalogId);
    dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ASSOC_CD,RefCodeNames.CATALOG_ASSOC_CD.CATALOG_SITE );
    IdVector assocIds = CatalogAssocDataAccess.selectIdOnly(conn,dbc);

    int catalogAssocId = 0;
    if (assocIds != null && assocIds.size()==1){
      catalogAssocId = ((Integer)assocIds.get(0)).intValue();
      caD.setCatalogAssocId(catalogAssocId);
      Date curDate = new Date();
      caD.setAddBy(loader);
      caD.setAddDate(curDate);
      caD.setModBy(loader);
      caD.setModDate(curDate);
      CatalogAssocDataAccess.update(conn, caD);
    } else if (assocIds != null && assocIds.size()>1){
      throw new RemoteException ("^clw^More than 1 shopping catalog for site found! catalogAssocIds = "+ assocIds.toString()+"^clw^");
    } else if(catalogId > 0){
      caD.setAddBy(loader);
      caD.setAddDate(new Date());
      CatalogAssocDataAccess.insert(conn, caD);
    }
  }



  private void checkCreateMasterItemsByDistKeys(Connection conn, int storeNum, int storeCatalogId, String loader, String tempTable, StringBuffer errMess) throws Exception{
    log.info("checkCreateMasterItemsByDistKeys() ===> Begin.");
    populateNSCCatalogTempTable(conn, storeNum, storeCatalogId,  loader,  tempTable);
//------------------------------------------------------------------------------------------------
   String selectItems ="select distributor, dist_sku, uom, item_id_dist, item_id_manuf,"+
       " manufacturer, manuf_sku, short_desc, pack, customer_sku, cost, price, dist_id, manuf_id , " +
       " CASE " +
       "   WHEN subcat3 IS NOT NULL THEN subcat3 " +
       "   WHEN subcat2 IS NOT NULL THEN subcat2 " +
       "   WHEN subcat1 IS NOT NULL THEN subcat1 " +
       "   ELSE category_name " +
       " END category_name "+
       " from " + tempTable +
       " where  add_by = ? and add_date >= trunc(sysdate) " ;

log.info("checkCreateMasterItemsByDistKeys() => SQL : " + selectItems);

   APIAccess factory = APIAccess.getAPIAccess();
   Catalog catalogEjb = factory.getCatalogAPI();
   CatalogInformation catalogInfEjb = APIAccess.getAPIAccess().getCatalogInformationAPI();
   CatalogCategoryDataVector categDV =catalogInfEjb.getAllStoreCatalogCategories(storeCatalogId);
   HashMap categMap = new HashMap();
   for (int i = 0; categDV != null && i < categDV.size(); i++) {
      CatalogCategoryData ccD =(CatalogCategoryData)categDV.get(i);
      categMap.put(ccD.getItemData().getShortDesc(), new Integer(ccD.getItemData().getItemId()) );
   }

   PreparedStatement pstmt = conn.prepareStatement(selectItems);
   pstmt.setString(1, loader);
   ResultSet rs = pstmt.executeQuery();
   HashMap itemMap = new HashMap();
   Set undefindItems = new HashSet();
   Set errorItems = new HashSet();

   Set<ProductData> toCreateItems = new HashSet();
   Set<ProductData> toUpdateItems = new HashSet();
   Set<ProductData> toCreateDistMapping = new HashSet();

   //ProductDataVector productDV =new ProductDataVector();
   while (rs.next()) {
     String distributor = rs.getString(1);
     String distSku = rs.getString(2);
     String uom = rs.getString(3);

     Integer itemIdDist =( Utility.isSet(rs.getString(4))) ? new Integer(rs.getString(4)) : new Integer("-1") ;
     Integer itemIdManuf =( Utility.isSet(rs.getString(5))) ? new Integer(rs.getString(5)) : new Integer("-1") ;
     String manufacturer = rs.getString(6);
     String manufSku = rs.getString(7);
     String shortDesc = rs.getString(8);
     String pack = rs.getString(9);
     String custSku = rs.getString(10);
     String cost = rs.getString(11);
     String price = rs.getString(12);
     Integer distId =( Utility.isSet(rs.getString(13))) ? new Integer(rs.getString(13)) : new Integer("-1") ;
     Integer manufId =( Utility.isSet(rs.getString(14))) ? new Integer(rs.getString(14)) : new Integer("-1") ;
     String categoryName = rs.getString(15);

     String key = distributor+"/"+distSku + "/"+ uom;
     String manufKey = manufacturer+"/"+manufSku + "/"+ uom;
     log.info("checkCreateMasterItemsByDistKeys() => key : " + key);
     log.info("checkCreateMasterItemsByDistKeys() => manufKey : " + manufKey);
     log.info("checkCreateMasterItemsByDistKeys() => RECORD : " + itemIdDist + "/" + itemIdManuf + "/" + distId + "/"+ manufId);

     // fill in pruductD object for Master Item
     SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
     Date effDate = sdf.parse(sdf.format(new Date()));

     ProductData productD = new ProductData();
     // ItemData
     ItemData itemD =  ItemData.createValue();
     itemD.setItemId(0);
     itemD.setItemStatusCd(RefCodeNames.ITEM_STATUS_CD.ACTIVE);
     itemD.setItemTypeCd(RefCodeNames.ITEM_TYPE_CD.PRODUCT) ;
     itemD.setLongDesc(shortDesc);
     itemD.setShortDesc(shortDesc);
     itemD.setEffDate(effDate);

     // ItemMetaData
     ItemMetaDataVector itemMetaDV =new ItemMetaDataVector();
     ItemMetaData itemMetaD= ItemMetaData.createValue();
     itemMetaD.setNameValue("UOM");
     itemMetaD.setValue(uom);
     itemMetaDV.add(itemMetaD);
     itemMetaD= ItemMetaData.createValue();
     itemMetaD.setNameValue("PACK");
     itemMetaD.setValue(pack);
     itemMetaDV.add(itemMetaD);

     // distributor mapping
     ItemMappingDataVector distrMappingDV =  new ItemMappingDataVector();
     ItemMappingData distrMappingD = new ItemMappingData();
     distrMappingD.setItemId((itemIdDist.intValue() > 0 ) ? itemIdDist.intValue() : itemIdManuf.intValue() );
     distrMappingD.setBusEntityId(distId.intValue());
     distrMappingD.setItemMappingCd(RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR);
     distrMappingD.setItemNum(distSku);
     distrMappingD.setItemPack(pack);
     distrMappingD.setItemUom(uom);
     distrMappingD.setStatusCd("ACTIVE");
     distrMappingDV.add(distrMappingD);
     // manufacturer mapping

//     ItemMappingDataVector manufMappingDV =  new ItemMappingDataVector();
     ItemMappingData manufMappingD = new ItemMappingData();
     manufMappingD.setBusEntityId(manufId.intValue());
     manufMappingD.setItemMappingCd(RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER);
     manufMappingD.setItemNum(manufSku);
     manufMappingD.setItemPack(pack);
     manufMappingD.setItemUom(uom);
     manufMappingD.setStatusCd("ACTIVE");
 //    manufMappingDV.add(manufMappingD);

     CatalogCategoryDataVector catalogCategoryDV =  new CatalogCategoryDataVector() ;
     CatalogCategoryData catalogCategoryD = new CatalogCategoryData();
     catalogCategoryDV.add(catalogCategoryD);
     // CatalogStructureData for store catalog
     CatalogStructureData catalogStructureD = CatalogStructureData.createValue();
     catalogStructureD.setCatalogId(storeCatalogId);
     catalogStructureD.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
     catalogStructureD.setEffDate(effDate);
     catalogStructureD.setCustomerSkuNum(distSku);

     productD.setListPrice((Utility.parseBigDecimal(price)).doubleValue());
     productD.setCostPrice((Utility.parseBigDecimal(cost)).doubleValue());
     productD.setEffDate(effDate);
 //    productD.setCustomerSkuNum(custSku);
     productD.setShortDesc(shortDesc);
     productD.setLongDesc(shortDesc);
     productD.setItemData(itemD);
     productD.setDistributorMappings(distrMappingDV);
     productD.setManuMapping(manufMappingD);
     productD.setCatalogCategories(catalogCategoryDV);
     productD.setCatalogStructure(catalogStructureD);
     if (itemMetaDV != null) {
       Iterator i = itemMetaDV.iterator();
       while (i.hasNext()) {
         ItemMetaData imD = (ItemMetaData)i.next();
         productD.setItemMeta(imD, imD.getNameValue());
       }
     }

 //    productD.setCatalogStructure(catalogStructureD); // this is doing in catalogEjb.saveStoreCatalogProduct(storeId,  pForm.getStoreCatalogId(), productD, user);
 //    productD.setCatalogCategories(catalogCategoryDV);

     if (itemIdDist.intValue() <= 0 && itemIdManuf.intValue() <= 0 ){
       if (!(Utility.isSet(manufacturer) && Utility.isSet(manufSku))){
         undefindItems.add(key);
       } else {
         //                CREATING new Master Item
         //--------------- define catalog category ----------
         int categId = (categMap.get(categoryName)!=null) ? (Integer)categMap.get(categoryName) : 0;

         log.info("checkCreateMasterItemsByDistKeys() => categId = " + categId + " for categoryName = "+  categoryName);
         if (categId == 0){
//           categId = createStoreCategory(conn, catalogId, categoryName);
           errMess.append("***Can't create Master Item. Category not found in the store catalog ("+storeCatalogId+"). Category Name ='"+ categoryName+ "'");
           continue;
         }
         catalogCategoryD.setCatalogCategoryId(categId);
         //-----------------save store catalog product ---------
         productD = catalogEjb.saveStoreCatalogProduct(storeNum, storeCatalogId, productD, loader);
         log("checkCreateMasterItemsByDistKeys() ==> Create Master Item : manufKey = "+ manufKey + ", Created itemId = " + productD.getItemData().getItemId());
       }
     } else if (itemIdManuf.intValue() > 0)  {
       // update Short Desc of the Master Item if required
       int itemId = itemIdManuf.intValue();
       productD.getItemData().setItemId(itemId);
       updateMasterItem(conn, productD);
//       if (itemIdDist.intValue() > 0 ){
//         if ( itemIdManuf.intValue() == itemIdDist.intValue()){
//           itemMap.put(key, itemIdDist); // upload catalog !
//         } else if (Utility.isSet(manufSku)){
//           errorItems.add(key+"/"+itemIdDist+"/"+productD.getManufacturerName()+"/"+itemIdManuf);
//         }
//       } else {
         //toCreateDistMapping.add(productD);
       log("checkCreateMasterItemsByDistKeys() ==> Save Distributor Mapping: itemId = "+itemId + ",  key = " + key);
       saveItemMapping(conn, productD, itemId, loader, RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR, errMess);
       saveItemMapping(conn, productD, itemId, loader, RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER, errMess);
  //     productD = catalogEjb.saveDistributorMapping(productD, loader);

//       }
     } else if (itemIdDist.intValue() > 0) {
       int itemId = itemIdDist.intValue();
       log("checkCreateMasterItemsByDistKeys() ==> Save Manufacturer Mapping: itemId = "+itemId + ",  manufKey = " + manufKey);
       saveItemMapping(conn, productD, itemId, loader, RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR, errMess);
       saveItemMapping(conn, productD, itemId, loader, RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER, errMess);
       productD.getItemData().setItemId(itemId);
       updateMasterItem(conn, productD);
     }
   }

   if (undefindItems.size() > 0){
     errMess.append("***Item(s) with the following key(s)(distributor/distSku/UOM) "+undefindItems.toString() +" does not exists and no data to create.");
   }
   if (errorItems.size() > 0) {
     errMess.append("***Discrepancy of the data for key(s)(distributor/distSku/UOM) "+errorItems.toString() +" Different items are found by search with Distributor and Manufacturer key.");
   }
   log.info("checkCreateMasterItemsByDistKeys() ===> End.");

   pstmt.close();

  }

   private void saveItemMapping (Connection conn, ProductData productD, int itemId, String loader, String itemMappingCd, StringBuffer errMess) throws Exception{
     ItemMappingData imD = null;
     if (RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR.equals(itemMappingCd)){
       imD = (ItemMappingData)productD.getDistributorMappings().get(0);
     } else if (RefCodeNames.ITEM_MAPPING_CD.ITEM_MANUFACTURER.equals(itemMappingCd)){
       imD = (ItemMappingData)productD.getManuMapping();
     }
     Date curDate = new Date();
     imD.setItemId(itemId);
     imD.setAddBy(loader);
     imD.setAddDate(curDate);
     imD.setModBy(loader);
     imD.setModDate(curDate);
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(ItemMappingDataAccess.ITEM_ID, itemId);
     if (RefCodeNames.ITEM_MAPPING_CD.ITEM_DISTRIBUTOR.equals(itemMappingCd)) {
         dbc.addEqualTo(ItemMappingDataAccess.BUS_ENTITY_ID, imD.getBusEntityId());
     }
     dbc.addEqualTo(ItemMappingDataAccess.ITEM_MAPPING_CD, itemMappingCd);
     ItemMappingDataVector itemMappingDV = ItemMappingDataAccess.select(conn, dbc);
     if (itemMappingDV == null || itemMappingDV.size() == 0){
         ItemMappingDataAccess.insert(conn, imD);
     } else if (itemMappingDV.size() == 1) {
         imD.setItemMappingId(((ItemMappingData)itemMappingDV.get(0)).getItemMappingId());
         imD.setAddBy(((ItemMappingData)itemMappingDV.get(0)).getAddBy());
         imD.setAddDate(((ItemMappingData)itemMappingDV.get(0)).getAddDate());
         ItemMappingDataAccess.update(conn, imD);
     } else {
         errMess.append("***Can't create/update itemMapping. More than 1 Record found for " + itemMappingCd +". ItemId = " + itemId +"; bus entity Id = " + imD.getBusEntityId() );
     }
   }

   private void updateMasterItem (Connection conn, ItemData newItemD) throws Exception {
    ItemData itemD = ItemDataAccess.select(conn, newItemD.getItemId());
    if (!Utility.isSet(newItemD.getShortDesc())){
      return ;
    }
    String oldVal = itemD.getShortDesc();
    if (!newItemD.getShortDesc().equals(itemD.getShortDesc())){
      itemD.setShortDesc(newItemD.getShortDesc());
      int n = ItemDataAccess.update(conn, itemD);
      log("updateMasterItem() ==> Updated: itemId = "+newItemD.getItemId()+ ", (Short_desc): old = " + oldVal + ", new = " +newItemD.getShortDesc() );
    }
  }

  private void updateMasterItem (Connection conn, ProductData productD) throws Exception {
   ItemData itemD = ItemDataAccess.select(conn, productD.getItemData().getItemId());
   String oldDesc = itemD.getShortDesc();
   String newDesc = productD.getItemData().getShortDesc();
   String newPack = null;
   String newUom = null;
   if (productD.getItemMeta("UOM") != null) {
       newUom = productD.getItemMeta("UOM").getValue();
   }
   if (productD.getItemMeta("PACK") != null) {
       newPack = productD.getItemMeta("PACK").getValue();
   }
   if (Utility.isSet(newDesc) && !newDesc.equals(oldDesc)){
     itemD.setShortDesc(newDesc);
     int n = ItemDataAccess.update(conn, itemD);
     log("updateMasterItem() ==> Updated: itemId = " + productD.getItemData().getItemId()+ ", (Short_desc): old = " + oldDesc + ", new = " + newDesc );
   }

   DBCriteria itemMetaDbc = new DBCriteria();
   itemMetaDbc.addEqualTo(ItemMetaDataAccess.ITEM_ID, productD.getItemData().getItemId());
   itemMetaDbc.addEqualTo(ItemMetaDataAccess.NAME_VALUE, "UOM");
   ItemMetaDataVector itemMetaDataVector = ItemMetaDataAccess.select(conn, itemMetaDbc);
   if (itemMetaDataVector != null && !itemMetaDataVector.isEmpty()) {
       ItemMetaData itemMetaD = (ItemMetaData)itemMetaDataVector.get(0);
       String oldUom = null;
       if (itemMetaD != null) {
           oldUom = itemMetaD.getValue();
       }
       if (Utility.isSet(newUom) && !newPack.equals(oldUom)){
           itemMetaD.setValue(newUom);
           int n = ItemMetaDataAccess.update(conn, itemMetaD);
           log("updateMasterItem() ==> Updated: itemId = " + productD.getItemData().getItemId()+ ", (UOM): old = " + oldUom + ", new = " + newUom );
       }
   }
   itemMetaDbc = new DBCriteria();
   itemMetaDbc.addEqualTo(ItemMetaDataAccess.ITEM_ID, productD.getItemData().getItemId());
   itemMetaDbc.addEqualTo(ItemMetaDataAccess.NAME_VALUE, "PACK");
   itemMetaDataVector = ItemMetaDataAccess.select(conn, itemMetaDbc);
   if (itemMetaDataVector != null && !itemMetaDataVector.isEmpty()) {
       ItemMetaData itemMetaD = (ItemMetaData)itemMetaDataVector.get(0);
       String oldPack = null;
       if (itemMetaD != null) {
           oldPack = itemMetaD.getValue();
       }
       if (Utility.isSet(newPack) && !newPack.equals(oldPack)){
           itemMetaD.setValue(newPack);
           int n = ItemMetaDataAccess.update(conn, itemMetaD);
           log("updateMasterItem() ==> Updated: itemId = " + productD.getItemData().getItemId()+ ", (PACK): old = " + oldPack + ", new = " + newPack );
       }
   }

 }


  private void populateNSCCatalogTempTable (Connection conn, int storeNum, int storeCatalogId, String loader, String tempTable )
  throws Exception {
    log ("populateNSCCatalogTempTable(): ===> BEGIN") ;
    long startTime =System.currentTimeMillis();
	LinkedList errors = new LinkedList();
    String updateSql =
        "update  " + tempTable +" t set t.item_id_dist = ( " +
              " select i.item_id " +
              " from clw_item i, clw_item_mapping im, clw_bus_entity be, clw_bus_entity_assoc bea " +
              "  where i.item_id = im.item_id " +
              "  and i.item_status_cd =  '"+RefCodeNames.ITEM_STATUS_CD.ACTIVE+"' " +
              "  and item_num = t.dist_sku " +
              "  and UPPER(item_uom) = UPPER(t.uom)  " +
              "  and UPPER(be.SHORT_DESC) = UPPER(t.distributor) " +
              "  and im.bus_entity_id = be.bus_entity_id " +
              "  and be.bus_entity_id= bea.bus_entity1_id " +
              "  and bea.bus_entity_assoc_cd = '"+RefCodeNames.BUS_ENTITY_ASSOC_CD.DISTRIBUTOR_STORE+"' " +
              "  and be.bus_entity_type_cd = '"+RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR+"' " +
              "  and BE.bus_entity_status_cd = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"' " +
              "  and bea.bus_entity2_id = ?" +
              "  and  item_num is not null and item_uom is not null" +
         " )  ";

//     log("updateSql (item_id_dist) =" + updateSql);

     PreparedStatement pstmt = conn.prepareStatement(updateSql);
     pstmt.setInt(1, storeNum);
     int n = pstmt.executeUpdate();
     log("updateSql (item_id_dist) RecordsUpdated =" + n);
     pstmt.close();

     updateSql =
         "update  " + tempTable +" t set t.item_id_manuf = ( " +
              " select i.item_id " +
              " from clw_item i, clw_catalog_structure cs "+
              "  where 1=1 " +
              "  and i.item_status_cd =  '"+RefCodeNames.ITEM_STATUS_CD.ACTIVE+"' " +
			  "  and i.item_id = cs.item_id "+
			  "  and cs.catalog_id = " + storeCatalogId +
			  "  and cs.CATALOG_STRUCTURE_CD = 'CATALOG_PRODUCT' "+
			  "  and t.dist_sku = cs.CUSTOMER_SKU_NUM " +
         " )  ";

     log.info("updateSql (item_id_manuf) =" + updateSql);

     pstmt = conn.prepareStatement(updateSql);

     n = pstmt.executeUpdate();
     log("updateSql (item_id_manuf) RecordsUpdated =" + n);
     pstmt.close();


 // verify manuf sku
     String verifManufSkuSQL =
              " SELECT t.distributor, t.DIST_SKU, t.uom, t.manuf_sku, im.item_num "+
              " FROM "+ tempTable +" t, clw_item_mapping im "+
              " WHERE t.ITEM_ID_MANUF = im.item_id "+
              " AND im.item_mapping_cd = 'ITEM_MANUFACTURER' "+
              " AND im.item_num != Upper(t.manuf_sku) ";

     log.info("verifManufSkuSQL  =" + verifManufSkuSQL);
     pstmt = conn.prepareStatement(verifManufSkuSQL);
	 ResultSet rs1 = pstmt.executeQuery();
	 while (rs1.next()) {
	    String distr = rs1.getString("distributor");
		String distSku = rs1.getString("dist_sku");
		String uom = rs1.getString("uom");
		String fileManufSku = rs1.getString("manuf_sku");
		String dbManufSku = rs1.getString("item_num");
		String error = "File - DB inconsistency found. Distr: "+distr+
		   " Dist sku: "+distSku+" UOM: "+uom+
		   " File manuf sku: "+ fileManufSku+" DB manuf sku: "+dbManufSku;
		 errors.add(error);

	 }
	 rs1.close();
     pstmt.close();



// verify manufacturer
     String verifManufacturerSQL =
              " SELECT t.distributor, t.DIST_SKU, t.uom, t.manufacturer, be.short_desc "+
              " FROM  " + tempTable +" t, clw_item_mapping im, clw_bus_entity be "+
              " WHERE t.ITEM_ID_MANUF = im.item_id "+
              " AND im.item_mapping_cd = 'ITEM_MANUFACTURER' "+
              " AND be.bus_entity_id = im.bus_entity_id "+
              " AND Upper(t.manufacturer) != Upper(be.short_desc) ";

     log.info("verifManufacturerSQL = " + verifManufacturerSQL);
     pstmt = conn.prepareStatement(verifManufacturerSQL);
	 rs1 = pstmt.executeQuery();
	 while (rs1.next()) {
	    String distr = rs1.getString("distributor");
		String distSku = rs1.getString("dist_sku");
		String uom = rs1.getString("uom");
		String fileManuf = rs1.getString("manufacturer");
		String dbManuf = rs1.getString("short_desc");
		String error = "File - DB inconsistency found. Distr: "+distr+
		   " Dist sku: "+distSku+" UOM: "+uom+
		   " File manufacturer: "+ fileManuf+" DB manufacturer: "+dbManuf;
		log.info("IntegrationServicesBean.java IIIIIIIIII: "+ error);

	 }
	 rs1.close();
     pstmt.close();
 /*
	if(errors.size()>0) {
	   String errorStr = "^clw^";
	   for(int ii=0; ii<errors.size(); ii++) {
	      errorStr += "\n\r";
		  errorStr += errors.get(ii);
	   }
	   errorStr += "^clw^";
	   throw new Exception(errorStr);
	}
 */

     // updateSql to fill in disctributor Id
     updateSql =
         "update  " + tempTable +" t set t.dist_id = " +
                 " ( " +
                 " select bus_entity_id from clw_bus_entity be, clw_bus_entity_assoc bea " +
                 " where UPPER(be.short_desc) =UPPER(t.distributor)  " +
                 "   and be.bus_entity_id = bea.bus_entity1_id " +
                 "   and be.bus_entity_type_cd ='"+RefCodeNames.BUS_ENTITY_TYPE_CD.DISTRIBUTOR+"' " +
                 "   and be.bus_entity_status_cd = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"'" +
                 "   and bea.bus_entity_assoc_cd = '"+RefCodeNames.BUS_ENTITY_ASSOC_CD.DISTRIBUTOR_STORE+"' " +
                 "   and bea.bus_entity2_id = ? " +
                 "  ) " ;
//    log("updateSql (Dist_id) =" + updateSql);

    pstmt = conn.prepareStatement(updateSql);
    pstmt.setInt(1, storeNum);
    n = pstmt.executeUpdate();
    log("updateSql (Dist_id) RecordsUpdated =" + n);
    pstmt.close();

    // insert manufacturer and manuf assoc if item can't be found by DistSku
    checkCreateManufacturer1 (conn, storeNum, tempTable, loader);

    // updateSql to fill in manufacturer Id for items where manufacturer is not null
    updateSql =
        "update  " + tempTable +" t set t.manuf_id = " +
                " ( " +
                " select bus_entity_id from clw_bus_entity be, clw_bus_entity_assoc bea " +
                " where UPPER(be.short_desc) =UPPER(t.manufacturer)  " +
                "   and be.bus_entity_id = bea.bus_entity1_id " +
                "   and be.bus_entity_type_cd ='"+RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER+"' " +
                "   and be.bus_entity_status_cd = '"+RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE+"'" +
                "   and bea.bus_entity_assoc_cd = '"+RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE+"' " +
                "   and bea.bus_entity2_id = ? " +
                "  ) " +
         "where  t.manufacturer is not null ";


    log("updateSql (manuf_id) =" + updateSql);

     pstmt = conn.prepareStatement(updateSql);
     pstmt.setInt(1, storeNum);
     n = pstmt.executeUpdate();
    log("updateSql (manuf_id) RecordsUpdated =" + n);

    pstmt.close();
    log("populateNSCCatalogTempTable()===> populate category ids");

   long finishTime =System.currentTimeMillis();
   log ("populateNSCCatalogTempTable()===> END." + "Process time at : " + (finishTime - startTime) + " ms") ;
   }

   private void checkCreateManufacturer (Connection conn, int storeNum, String tempTable, String loader) throws Exception {
     log.info("checkCreateManufacturer() ===> BEGIN.");
     String manufSql = "select distinct manufacturer, locale from " + tempTable +" where (1=1) "+//add_by = ? and add_date >= trunc(sysdate) " +
                        " and manufacturer is not null ";
     PreparedStatement pstmt = conn.prepareStatement(manufSql);
//     pstmt.setString(1, loader);
     ResultSet rs = pstmt.executeQuery();
     Set manufNames = new HashSet();
     Set manufNamesAssoc = new HashSet();
     Map manufNameLocaleMap = new HashMap();

     Set existManufNames = new HashSet();
     Set existManufNamesAssoc = new HashSet();
     Map existManufMap = new HashMap();
     while (rs.next()) {
       manufNames.add(rs.getString(1));
       manufNamesAssoc.add(rs.getString(1));
       manufNameLocaleMap.put(rs.getString(1), rs.getString(2));
     }
     if (manufNames.size() == 0 ){
       return;
     }
     log.info("checkCreateManufacturer() ===> manufNames = " + manufNames.toString());
    //----------------Get All Manufacturers-----------
     DBCriteria dbc = new  DBCriteria();
     dbc.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
     BusEntityDataVector beDV = BusEntityDataAccess.select(conn, dbc)   ;
     for (int i = 0; beDV!= null && i < beDV.size(); i++) {
       BusEntityData beD =(BusEntityData)beDV.get(i);
       existManufNames.add(beD.getShortDesc());
       existManufMap.put(beD.getShortDesc(), new Integer(beD.getBusEntityId()));
     }
     //---------------Get All Manufacturer's Associaions with store-------
     dbc = new  DBCriteria();
     dbc.addEqualTo(BusEntityDataAccess.BUS_ENTITY_TYPE_CD, RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
     dbc.addJoinTable(BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC);
     dbc.addJoinCondition(BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC, BusEntityAssocDataAccess.BUS_ENTITY1_ID, BusEntityDataAccess.CLW_BUS_ENTITY,  BusEntityDataAccess.BUS_ENTITY_ID);
     dbc.addJoinTableEqualTo(BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC, BusEntityAssocDataAccess.BUS_ENTITY2_ID, storeNum);
     dbc.addJoinTableEqualTo(BusEntityAssocDataAccess.CLW_BUS_ENTITY_ASSOC, BusEntityAssocDataAccess.BUS_ENTITY_ASSOC_CD, RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE);
     BusEntityDataVector beDVAssoc = BusEntityDataAccess.select(conn, dbc)   ;
     for (int i = 0; beDVAssoc!= null && i < beDVAssoc.size(); i++) {
       BusEntityData beDAssoc =(BusEntityData)beDVAssoc.get(i);
       existManufNamesAssoc.add(beDAssoc.getShortDesc());
     }
     //----------------------------------------------------------------
     boolean toAddManuf = manufNames.removeAll(existManufNames);
     log.info("checkCreateManufacturer() ===> NEW manufNames = " + manufNames.toString());
     //----------------------------------------------------------------
     boolean toAddManufAssoc = manufNamesAssoc.removeAll(existManufNamesAssoc);
     manufNamesAssoc.removeAll(manufNames);
     log.info("checkCreateManufacturer() ===> NEW manufNamesAssoc = " + manufNamesAssoc.toString());

     for (Iterator iter = manufNames.iterator(); iter.hasNext(); ) {
       String name = (String) iter.next();
       BusEntityData manufD = BusEntityData.createValue();
       manufD.setBusEntityTypeCd(RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
       manufD.setBusEntityStatusCd(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
       manufD.setShortDesc(name);
       manufD.setLongDesc(name);
       manufD.setLocaleCd((String)manufNameLocaleMap.get(name));
       manufD.setWorkflowRoleCd("UNKNOWN");
       manufD = BusEntityDataAccess.insert(conn, manufD);
       BusEntityServicesAPI.saveBusEntAssociation(true,manufD.getBusEntityId(),storeNum,RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE,conn);
     }
     for (Iterator iter = manufNamesAssoc.iterator(); iter.hasNext(); ) {
       String name = (String) iter.next();
       Integer idObj = (Integer)existManufMap.get(name);
       if (idObj != null){
         int manufId = idObj.intValue();
         BusEntityServicesAPI.saveBusEntAssociation(true, manufId, storeNum, RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE, conn);
       }
     }
     log.info("checkCreateManufacturer() ===> END.");

   }

   private void checkCreateManufacturer1 (Connection conn, int storeNum, String tempTable, String loader) throws Exception {
     log.info("checkCreateManufacturer1() ===> BEGIN.");
     String manufSql =
       "SELECT t.manufacturer, t.locale, aa.bus_entity_id FROM  " + tempTable +" t,  "+
       " (SELECT * FROM clw_bus_entity be, clw_bus_entity_assoc bea "+
       " WHERE  bea.bus_entity1_id = be.bus_entity_id "+
       " AND bea.bus_entity2_id = "+ storeNum +
       " AND bea.bus_entity_assoc_cd = 'MANUFACTURER OF STORE' "+
       " ) aa "+
       " WHERE t.manufacturer is not NULL "+
       " AND Upper(t.manufacturer) = Upper(aa.short_desc(+)) ";

	 /*
	 "select distinct manufacturer, locale from " + tempTable +" where (1=1) "+//add_by = ? and add_date >= trunc(sysdate) " +
                        " and manufacturer is not null ";
	*/
     PreparedStatement pstmt = conn.prepareStatement(manufSql);
//     pstmt.setString(1, loader);
     ResultSet rs = pstmt.executeQuery();
     Set manufNames = new HashSet();
     Map manufNameLocaleMap = new HashMap();

     Set existManufNames = new HashSet();
     Set existManufNamesAssoc = new HashSet();
     Map existManufMap = new HashMap();
     while (rs.next()) {
	    if(rs.getInt(3) == 0) { //No manufacturer
			String mName = rs.getString(1);
			manufNames.add(mName);
			manufNameLocaleMap.put(mName, rs.getString(2));
		}
     }
     if (manufNames.size() == 0 ){
       return;
     }
     log.info("checkCreateManufacturer1() ===> manufNames to create = " + manufNames.toString());
     //----------------------------------------------------------------

     for (Iterator iter = manufNames.iterator(); iter.hasNext(); ) {
       String name = (String) iter.next();
       BusEntityData manufD = BusEntityData.createValue();
       manufD.setBusEntityTypeCd(RefCodeNames.BUS_ENTITY_TYPE_CD.MANUFACTURER);
       manufD.setBusEntityStatusCd(RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
       manufD.setShortDesc(name);
       manufD.setLongDesc(name);
       manufD.setLocaleCd((String)manufNameLocaleMap.get(name));
       manufD.setWorkflowRoleCd("UNKNOWN");
       manufD = BusEntityDataAccess.insert(conn, manufD);
       BusEntityServicesAPI.saveBusEntAssociation(true,manufD.getBusEntityId(),storeNum,RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE,conn);
     }
	 /*
     for (Iterator iter = manufNamesAssoc.iterator(); iter.hasNext(); ) {
       String name = (String) iter.next();
       Integer idObj = (Integer)existManufMap.get(name);
       if (idObj != null){
         int manufId = idObj.intValue();
         BusEntityServicesAPI.saveBusEntAssociation(true, manufId, storeNum, RefCodeNames.BUS_ENTITY_ASSOC_CD.MANUFACTURER_STORE, conn);
       }
     }
	 */
     log.info("checkCreateManufacturer1() ===> END.");

   }

   private void createBuyListShoppingCatalog(Connection conn, HashMap newListNamesMap, int storeId, int distributorId, int storeCatalogId, String loader, ArrayList errors) throws Exception{
     log.info("createBuyListShoppingCatalog() ====> BEGIN.");
     Date date = new Date(System.currentTimeMillis());
     Set listNames = newListNamesMap.keySet();
     for (Iterator iter = listNames.iterator(); iter.hasNext(); ) {
       String listName = (String) iter.next();
       BuyListViewVector blVV = (BuyListViewVector)newListNamesMap.get(listName);
       log.info("createBuyListShoppingCatalog() ====> create CLW_CATALOG record for listName ="+ listName);
       // create record in CLW_CATALOG
       CatalogData pCatalog = CatalogData.createValue();
       pCatalog.setCatalogStatusCd(RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
       pCatalog.setCatalogTypeCd(RefCodeNames.CATALOG_TYPE_CD.SHOPPING);
       pCatalog.setShortDesc(listName);
       pCatalog.setLoaderField(listName);
       pCatalog.setAddBy(loader);
       pCatalog.setModBy(loader);
       pCatalog.setAddDate(date);
       pCatalog.setModDate(date);
       pCatalog = CatalogDataAccess.insert(conn, pCatalog);
       int catalogId = pCatalog.getCatalogId();
       // create record in CLW_CONTRACT
       log.info("createBuyListShoppingCatalog() ====> create CLW_CONTRACT record for listName ="+ listName + ", catalogId =" + catalogId);
       ContractData pContract = ContractData.createValue();
       pContract.setCatalogId(catalogId);
       pContract.setShortDesc(listName);
       pContract.setContractStatusCd(RefCodeNames.CONTRACT_STATUS_CD.ACTIVE);
       pContract.setContractTypeCd("UNKNOWN");
       pContract.setRefContractNum("0");
       pContract.setLocaleCd(RefCodeNames.LOCALE_CD.EN_XXPO);
       pContract.setEffDate(date);
       pContract.setAddBy(loader);
       pContract.setModBy(loader);
       pContract.setAddDate(date);
       pContract.setModDate(date);
       pContract = ContractDataAccess.insert(conn, pContract);
       // create record in CLW_ORDER_GUIDE
/*  Bug 4302.Commented according to conversation with YK: OG should not be created in the Buy List Loader.
       log.info("createBuyListShoppingCatalog() ====> create CLW_ORDER_GUIDE record for listName ="+ listName + ", catalogId =" + catalogId);
       OrderGuideData orderGuideD = OrderGuideData.createValue();
       orderGuideD.setShortDesc(listName);
       orderGuideD.setOrderGuideTypeCd(RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE);
       orderGuideD.setCatalogId(catalogId);
       orderGuideD.setAddBy(loader);
       orderGuideD.setModBy(loader);
       orderGuideD.setAddDate(date);
       orderGuideD.setModDate(date);
       orderGuideD = OrderGuideDataAccess.insert(conn, orderGuideD);
*/
       // create assoc with STORE
       log.info("createBuyListShoppingCatalog() ====> create assoc with STORE for catalogId ="+ catalogId);
       CatalogAssocData caD = CatalogAssocData.createValue();
       caD.setBusEntityId(storeId);
       caD.setCatalogId(catalogId);
       caD.setCatalogAssocCd(RefCodeNames.CATALOG_ASSOC_CD.CATALOG_STORE);
       caD.setAddBy(loader);
       caD.setModBy(loader);
       caD.setAddDate(date);
       caD.setModDate(date);
       caD = CatalogAssocDataAccess.insert(conn, caD);
       // add Contract items
       addContractItemRecords ( conn ,  blVV,  catalogId, pContract.getContractId(),  loader);

       // create records in CLW_CATALOG_STRUCTURE, CLW_ITEM_ASSOC
       storeDistributor = distributorId ;
       createCatalogStructureByStoreCatalog(conn, storeCatalogId, catalogId, blVV, loader);
       log.info("createShoppingCatalog() ====> END.");
     }

   }

   private void updateBuyListShoppingCatalog(Connection conn, Map existCatalogsMap, int storeId, int distributorId, int storeCatalogId, String loader, ArrayList errors) throws Exception{
     log.info("updateBuyListShoppingCatalog() ====> BEGIN."  );
     Date date = new Date(System.currentTimeMillis());
     Set catalogs = existCatalogsMap.keySet();
     for (Iterator iter = catalogs.iterator(); iter.hasNext(); ) {
       Integer catalogIdI = (Integer) iter.next();
       BuyListViewVector blVV = (BuyListViewVector)existCatalogsMap.get(catalogIdI);
       int catalogId = catalogIdI.intValue();
       log.info("updateBuyListShoppingCatalog() ====> process for catalogId =" + catalogId );

       DBCriteria dbc = new DBCriteria();
       dbc.addEqualTo(ContractDataAccess.CATALOG_ID, catalogId);
       IdVector contractIdV = ContractDataAccess.selectIdOnly(conn, dbc);
       if (contractIdV ==null || contractIdV.size() == 0){
 //      createContract(catalogId, blVV);
         throw new Exception("updateBuyListShoppingCatalog() => There is not contract for catalogId =" + catalogId );
       }
       int contractId = ((Integer)contractIdV.get(0)).intValue();

      dbc = new DBCriteria();
       dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, catalogId);
       dbc.addEqualTo(ItemAssocDataAccess.ITEM_ASSOC_CD, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
       ItemAssocDataVector iaDV = ItemAssocDataAccess.select(conn, dbc) ;
       if (iaDV ==null ){
         iaDV = new ItemAssocDataVector();
       }

       HashMap inboundItemsMap = new HashMap();
       HashMap toAddItemsMap = new HashMap();
       for (int i = 0; i < blVV.size(); i++) {
         BuyListView blV = (BuyListView)blVV.get(i);
         int itemId =blV.getItemId();
         inboundItemsMap.put(new Integer(itemId), blV);
         toAddItemsMap.put(new Integer(itemId), blV);
       }

       HashSet existItems = new HashSet();
       HashSet toDeleteItems = new HashSet();
       for (int i = 0; i < iaDV.size(); i++) {
         ItemAssocData iaD = (ItemAssocData)iaDV.get(i);
         int itemId =iaD.getItem1Id();
         existItems.add(new Integer(itemId));
         toDeleteItems.add(new Integer(itemId));
       }
       Set toAddItems = toAddItemsMap.keySet();
//       log.info("updateBuyListShoppingCatalog() ====> INIT toDeleteItems = " + toDeleteItems.toString()  );
//       log.info("updateBuyListShoppingCatalog() ====> INIT toAddItems = " + toAddItems.toString()  );
//       log.info("updateBuyListShoppingCatalog() ====> existItems = " + existItems.toString()  );
//       log.info("updateBuyListShoppingCatalog() ====> inboundItemsMap.keySet() = " + inboundItemsMap.keySet() );

       boolean toAddFl = toAddItems.removeAll(existItems);
       boolean toDelFl = toDeleteItems.removeAll(inboundItemsMap.keySet());

       log.info("updateBuyListShoppingCatalog() ====> process DELETE ITEMS. toDeleteItems = " + toDeleteItems.toString()  );
       if (toDeleteItems.size() > 0 ){
         IdVector delItemsV= new IdVector();
         delItemsV.addAll(toDeleteItems);
         //--- remove items from CLW_CONTRACT_ITEM , CLW_ITEM_ASSOC, CLW_CATALOG_STRUCTURE
         deleteItemsFromShoppingCatalog(conn, delItemsV, storeCatalogId, catalogId);
         //note : we must not delete items from account catalogs!
       }
       log.info("updateBuyListShoppingCatalog() ====> process ADD ITEMS. toAddItems = " + toAddItems.toString()  );
       if (toAddItems.size() > 0) {
         IdVector addItemsV= new IdVector();
         BuyListViewVector addBuyListVV = new BuyListViewVector();
         addItemsV.addAll(toAddItems);

 //        addBuyListVV.addAll(toAddItemsMap.values());

         for (Iterator it = toAddItems.iterator(); it.hasNext(); ) {
           Integer item = (Integer) it.next();
           BuyListView blV = (BuyListView) toAddItemsMap.get(item);
           addBuyListVV.add(blV);
         }
         //--- add items into CLW_CONTRACT_ITEM , CLW_ITEM_ASSOC, CLW_CATALOG_STRUCTURE ( if new catalog or it doesn't have item )
         HashMap itemChainByProductMap = getItemChainByProduct ( conn,  addItemsV,  storeCatalogId);

         addContractItemRecords ( conn , addBuyListVV,  catalogId, contractId,  loader);
         storeDistributor = distributorId ;
         addItemsToShoppingCatalog(conn, addItemsV, itemChainByProductMap,  storeCatalogId, catalogId, loader);
         storeDistributor = 0;
         addItemsToAccountCatalogs(conn, addItemsV, itemChainByProductMap,  storeCatalogId, catalogId, loader);
       }

       // --- updateShoppingCatalog(conn, blV, storeId, distributorId, storeCatalogId, catalogId, loader, errors);
       dbc = new DBCriteria();
       dbc.addEqualTo(ContractItemDataAccess.CONTRACT_ID, contractId);
       ContractItemDataVector ciDV = ContractItemDataAccess.select(conn, dbc) ;
       if (ciDV ==null || ciDV.size() == 0){
         throw new Exception("updateBuyListShoppingCatalog() => There is not contract items for contractId =" + contractId);
       }
       ContractItemDataVector toUpdatePricingV =  new ContractItemDataVector();
       for (int i = 0; i < ciDV.size(); i++) {
         ContractItemData ciD = (ContractItemData)ciDV.get(i);
         BuyListView inboundD = (BuyListView)inboundItemsMap.get(new Integer(ciD.getItemId()));
         log.info("updateBuyListShoppingCatalog() ====> process UPDATE PRICING. ciD.getItemId() = "+ ciD.getItemId());
         if ( inboundD != null && ciD != null ){
           if (ciD.getAmount().doubleValue() != inboundD.getListPrice().doubleValue() ||
               ciD.getDistCost().doubleValue() != inboundD.getListPrice().doubleValue()) {
             ciD.setAmount(inboundD.getListPrice());
             ciD.setDistCost(inboundD.getListPrice());
             ciD.setModBy(loader);
             ciD.setModDate(date);
             toUpdatePricingV.add(ciD);
           }
         }
       }
       log.info("updateBuyListShoppingCatalog() ====> process UPDATE PRICING. toUpdatePricingV = " + toUpdatePricingV.toString()  );
       if (toUpdatePricingV.size() >0){
         for (int i = 0; i < toUpdatePricingV.size(); i++) {
           ContractItemData contractItem = (ContractItemData)toUpdatePricingV.get(i);
           ContractItemDataAccess.update(conn, contractItem);
         }
       }
     }
     log.info("updateBuyListShoppingCatalog() ====> END."  );

   }

   private void deleteItemsFromShoppingCatalog(Connection conn, IdVector delItemsV, int storeCatalogId, int catalogId) throws Exception {
     log.info("deleteItemsToShoppingCatalog() ====> BEGIN."  );
     IdVector toDelV = delItemsV;
       // delete Items from Contract_Item
       DBCriteria dbc = new DBCriteria();
       dbc.addEqualTo(ContractDataAccess.CATALOG_ID, catalogId);
       String sql = ContractDataAccess.getSqlSelectIdOnly(ContractDataAccess.CONTRACT_ID, dbc);
       dbc = new DBCriteria();
       dbc.addOneOf(ContractItemDataAccess.CONTRACT_ID, sql);
       dbc.addOneOf(ContractItemDataAccess.ITEM_ID, delItemsV);
       int n = ContractItemDataAccess.remove(conn, dbc);
       log.info("deleteItemsFromShoppingCatalog() ====> removed from CLW_CONTRACT_ITEM. #records =" + n  );

       // delete items from Item_Assoc
       dbc = new DBCriteria();
       dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, catalogId);
       dbc.addEqualTo(ItemAssocDataAccess.ITEM_ASSOC_CD, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
       dbc.addOneOf(ItemAssocDataAccess.ITEM1_ID, delItemsV);
       ItemAssocDataVector iaDV = ItemAssocDataAccess.select(conn, dbc);
       HashSet categorySet = new HashSet();
       for (int i = 0; i < iaDV.size(); i++) {
         ItemAssocData iaD = (ItemAssocData)iaDV.get(i);
         categorySet.add(new Integer(iaD.getItem2Id()));
       }
       n = ItemAssocDataAccess.remove(conn, dbc) ;
       log.info("deleteItemsFromShoppingCatalog() ====> removed from CLW_ITEM_ASSOC. #records =" + n  );

       //try to delete cetegories if there are no items defined for them
       IdVector delCategsV = new IdVector();
       delCategsV.addAll(categorySet);

       log.info("deleteItemsFromShoppingCatalog() ====>Need to remove Items: delItemsV =" + delItemsV.toString()  );
       log.info("deleteItemsFromShoppingCatalog() ====>Need to remove Categories: delCategsV =" + delCategsV.toString()  );
       deleteCatalogStructureRecords(conn, storeCatalogId, catalogId,  delItemsV,  delCategsV );

       log.info("deleteItemsToShoppingCatalog() ====> END."  );
   }

   private void deleteCatalogStructureRecords(Connection conn, int storeCatalogId, int catalogId, IdVector delItemsV, IdVector delCategsV ) throws Exception {
     String sql =" select distinct level LEV, ITEM2_ID PARENT,ITEM1_ID CHILD  \n" +
               "   from CLW_ITEM_ASSOC \n" +
               "  where CATALOG_ID = " + storeCatalogId + "   \n" +
               "    and ITEM_ASSOC_CD in ('" + RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY+ "') \n"+
               "  connect by PRIOR ITEM2_ID = ITEM1_ID  \n" +
               "  start with ITEM_ASSOC_CD ='" + RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY + "'  \n" +
               "        and  ITEM1_ID in (" + IdVector.toCommaString(delCategsV)+ ")";
     log.info("deleteCatalogStructureRecords() ===> sql =" + sql);
     PreparedStatement pstmt = conn.prepareStatement(sql);
     ResultSet rs = pstmt.executeQuery();
     HashSet toDelCategHierarchySet = new HashSet();
     while (rs.next()) {
        toDelCategHierarchySet.add(new Integer(rs.getInt(2)));
        toDelCategHierarchySet.add(new Integer(rs.getInt(3)));
     }
     log.info("deleteCatalogStructureRecords() ====>Need to remove Categories: delCategsV =" + delCategsV.toString()  );

     delCategsV.addAll(toDelCategHierarchySet); //now we have all  list of categories that might be removed

     log.info("deleteCatalogStructureRecords() ====>ALL list of categories that might be removed: delCategsV =" + delCategsV.toString()  );

     // check if there are items defined for some  of them
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, catalogId);
     dbc.addOneOf(ItemAssocDataAccess.ITEM2_ID, delCategsV);
     IdVector categIdWithItemsV = ItemAssocDataAccess.selectIdOnly(conn, ItemAssocDataAccess.ITEM2_ID, dbc);

     boolean toDelCategFl = delCategsV.removeAll(categIdWithItemsV);
     log.info("deleteCatalogStructureRecords() ===Categories WITHOUT Items :delCategsV =" + delCategsV.toString()  );

     delItemsV.addAll(delCategsV) ;
     log.info("deleteCatalogStructureRecords() ===TO DELETE Items :delItemsV =" + delItemsV.toString()  );

     if (delItemsV.size() > 0) {
       //delete items from Catalog_Structure
       dbc = new DBCriteria();
       dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_ID, catalogId);
       dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_STRUCTURE_CD, RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
       dbc.addOneOf(CatalogStructureDataAccess.ITEM_ID, delItemsV);
       int n = CatalogStructureDataAccess.remove(conn, dbc) ;
       log.info("deleteCatalogStructureRecords() ====> removed from CLW_CATALOG_STRUCTURE. #records =" + n  );
     }

   }

   private HashMap getItemChainByProduct (Connection conn, IdVector addItemsV, int storeCatalogId) throws Exception {
     HashMap itemChainByProductMap =  new  HashMap();
     String sql =" select distinct level LEV, ITEM2_ID PARENT,ITEM1_ID CHILD , ITEM_ASSOC_CD \n" +
               "   from CLW_ITEM_ASSOC \n" +
               "  where CATALOG_ID = " + storeCatalogId + "   \n" +
               "  connect by PRIOR ITEM2_ID = ITEM1_ID  \n" +
               "  start with ITEM_ASSOC_CD ='" + RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY + "'  \n" +
               "        and  ITEM1_ID = ? and CATALOG_ID = " + storeCatalogId;
    log.info("addItemsToShoppingCatalog() ===> sql =" + sql);
    for (int i = 0; i < addItemsV.size(); i++) {
       Integer productIdI = (Integer)addItemsV.get(i) ;
       int productId = productIdI.intValue();
       PreparedStatement pstmt2 = conn.prepareStatement(sql);
       pstmt2.setInt(1, productId);
       ResultSet rs2 = pstmt2.executeQuery();
 //      IdVector itemV = new IdVector();
       ItemAssocDataVector itemChainDV = new ItemAssocDataVector();
       while (rs2.next()) {
         ItemAssocData itemChainD = ItemAssocData.createValue();
         itemChainD.setItem1Id(rs2.getInt(3));  //child
         itemChainD.setItem2Id(rs2.getInt(2));  // parent
         itemChainD.setItemAssocCd(rs2.getString(4));
         itemChainDV.add(itemChainD);
       }
       rs2.close();
       pstmt2.close();
       itemChainByProductMap.put(productIdI, itemChainDV);
    }
    return itemChainByProductMap;
   }

   private void addItemsToCatalog(Connection conn, IdVector addItemsV, HashMap itemChainByProductMap, int storeCatalogId, int catalogId, String loader) throws Exception {
     log.info("addItemsToCatalog() ====> BEGIN: addItemsV.size() =" + addItemsV.size() );
//     HashMap itemChainByProductMap = getItemsChainByProduct ( conn,  addItemsV,  storeCatalogId);
     HashSet existItemSet =  getCatalogStructureRecords(conn, catalogId);
     for (int i = 0; i < addItemsV.size(); i++) {
       Integer productIdI = (Integer) addItemsV.get(i);
       int productId = productIdI.intValue();
       ItemAssocDataVector itemChainDV = (ItemAssocDataVector)itemChainByProductMap.get(productIdI);
       IdVector toAddItemV = new IdVector();
//       log.info("addItemsToCatalog() ====> itemChainDV =" + itemChainDV.toString());
       for (int j = 0; j < itemChainDV.size(); j++) {
         ItemAssocData iaD = (ItemAssocData)itemChainDV.get(j);
         String assocType = iaD.getItemAssocCd();
         Integer item1Id = new Integer(iaD.getItem1Id());
         Integer item2Id = new Integer(iaD.getItem2Id());
         // create ItemAssoc record
//         log.info("addItemsToCatalog() ====> create CLW_ITEM_ASSOC records for catalogId =" + catalogId);
//         log.info("addItemsToCatalog() ====> assocType =" + assocType);
         if (assocType.equals(RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY)) {
        	 DBCriteria dbc = new DBCriteria();
        	 dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, catalogId);
        	 dbc.addEqualTo(ItemAssocDataAccess.ITEM1_ID, iaD.getItem1Id());
        	 dbc.addEqualTo(ItemAssocDataAccess.ITEM2_ID, iaD.getItem2Id());
        	 dbc.addEqualTo(ItemAssocDataAccess.ITEM_ASSOC_CD, RefCodeNames.ITEM_ASSOC_CD.PRODUCT_PARENT_CATEGORY);
        	 ItemAssocDataVector iaDV = ItemAssocDataAccess.select(conn, dbc);
        	 if (iaDV.size()==0){
	           iaD.setCatalogId(catalogId);
	           iaD.setAddBy(loader);
	           iaD.setModBy(loader);
	           iaD.setAddDate(new Date());
	           iaD.setModDate(new Date());
	           iaD = ItemAssocDataAccess.insert(conn, iaD);
        	 }
         }
          if (!existItemSet.contains(item2Id)){
            toAddItemV.add(item2Id);
            existItemSet.add(item2Id);
          }
          if (!existItemSet.contains(item1Id)) {
            toAddItemV.add(item1Id);
            existItemSet.add(item1Id);
          }
        }
       // create Catalog Structure records
       if (!existItemSet.contains(productIdI)) {
         toAddItemV.add(productIdI);
       }
       addCatalogStructureRecords(conn, storeCatalogId, catalogId, toAddItemV, loader);
     }
     log.info("addItemsToCatalog() ====> END."  );

   }

   // adds items to Account catalogs connected to shopping catalogId
   private void addItemsToAccountCatalogs(Connection conn, IdVector addItemsV, HashMap itemChainByProductMap,int storeCatalogId, int catalogId, String loader) throws Exception {
     log.info("addItemsToAccountCatalog() ====> BEGIN."  );
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ASSOC_CD, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT);
     dbc.addEqualTo(CatalogAssocDataAccess.CATALOG_ID, catalogId);
     String accIdsSql = CatalogAssocDataAccess.getSqlSelectIdOnly(CatalogAssocDataAccess.BUS_ENTITY_ID, dbc);
     dbc = new DBCriteria();
     dbc.addJoinTable(CatalogDataAccess.CLW_CATALOG);
     dbc.addJoinCondition(CatalogDataAccess.CLW_CATALOG,CatalogDataAccess.CATALOG_ID, CatalogAssocDataAccess.CLW_CATALOG_ASSOC, CatalogAssocDataAccess.CATALOG_ID );
     dbc.addJoinTableEqualTo(CatalogDataAccess.CLW_CATALOG, CatalogDataAccess.CATALOG_TYPE_CD, RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
     dbc.addOneOf(CatalogAssocDataAccess.BUS_ENTITY_ID, accIdsSql);
     CatalogAssocDataVector caDV = CatalogAssocDataAccess.select(conn, dbc);

     for (int i = 0; caDV != null && i < caDV.size(); i++) {
       CatalogAssocData caD = ( CatalogAssocData)caDV.get(i);
       int accountCatalogId = caD.getCatalogId();
       addItemsToCatalog(conn, addItemsV, itemChainByProductMap, storeCatalogId, accountCatalogId, loader);
     }
     log.info("addItemsToAccountCatalog() ====> END."  );

   }

   private void addItemsToShoppingCatalog(Connection conn, IdVector addItemsV, HashMap itemChainByProductMap, int storeCatalogId, int catalogId, String loader) throws Exception {
     log.info("addItemsToShoppingCatalog() ====> BEGIN."  );
     addItemsToCatalog(conn, addItemsV, itemChainByProductMap, storeCatalogId, catalogId, loader);
     log.info("addItemsToShoppingCatalog() ====> END."  );

   }

   private void createCatalogStructureByStoreCatalog (Connection conn, int storeCatalogId, int catalogId, BuyListViewVector blVV, String loader) throws Exception {

     log.info("createCatalogStructureByStoreCatalog() ====> BEGIN."  );
     HashSet toAddItems =  new  HashSet();
     for (int i = 0; i < blVV.size(); i++) {
       BuyListView blV = (BuyListView) blVV.get(i);
       int itemId = blV.getItemId();
       toAddItems.add(new Integer(itemId));
     }
     IdVector toAddItemsV = new IdVector();
     toAddItemsV.addAll(toAddItems);
     HashMap itemChainByProductMap = getItemChainByProduct(conn,  toAddItemsV,  storeCatalogId);
     addItemsToShoppingCatalog(conn, toAddItemsV, itemChainByProductMap,  storeCatalogId, catalogId, loader);
     // note : Catalog Structure for ACCOUNT catalog will be created during Catalog Assoc Loader process
     //        because there is no assotiations with account here.
     log.info("createCatalogStructureByStoreCatalog() ====> END."  );
   }

   private void addContractItemRecords (Connection conn , BuyListViewVector blVV, int catalogId, int contractId, String loader) throws Exception {
     Date date = new Date();
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(ContractItemDataAccess.CONTRACT_ID, contractId);
     IdVector existContractItemV =ContractItemDataAccess.selectIdOnly(conn, ContractItemDataAccess.ITEM_ID, dbc);
     log.info("addContractItemRecords() ====> contractId =" + contractId + "; existContractItemV.size()= " + existContractItemV.size());
     for (int i = 0; i < blVV.size(); i++) {
       BuyListView blV = (BuyListView)blVV.get(i);
       // create records in CLW_CONTRACT_ITEM
       int itemId = blV.getItemId();
       if (!existContractItemV.contains(new Integer(itemId))){
//         log.info("addContractItemRecords() ====> create CLW_CONTRACT_ITEM records for catalogId =" + catalogId + ", itemId=" + itemId);
         ContractItemData contItemD = ContractItemData.createValue();
         contItemD.setContractId(contractId);
         contItemD.setItemId(itemId);
         contItemD.setAmount(blV.getListPrice());
         contItemD.setDistCost(blV.getListPrice());
         contItemD.setAddBy(loader);
         contItemD.setModBy(loader);
         contItemD.setAddDate(date);
         contItemD.setModDate(date);
//         contItemD.setCurrencyCd("USD");
         contItemD = ContractItemDataAccess.insert(conn, contItemD);
//         blV.setContractItem(contItemD);
       }
     }

   }
   private void addCatalogStructureRecords(Connection conn, int storeCatalogId, int catalogId, IdVector itemV, String loader) throws Exception {
     log.info("addCatalogStructureRecords() ====> create CLW_CATALOG_STRUCTURE records for catalogId ="+ catalogId + ", itemV =" + itemV.toString() );
     if (itemV == null || itemV.size() == 0){
       log.info("addCatalogStructureRecords() ====> no items to add into catalog");
       return;  // do nothing if no items to add
     }
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_ID, storeCatalogId);
     dbc.addOneOf(CatalogStructureDataAccess.ITEM_ID, itemV);
     ArrayList cds = new ArrayList();
     cds.add(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
     cds.add(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
     dbc.addOneOf(CatalogStructureDataAccess.CATALOG_STRUCTURE_CD, cds);
     CatalogStructureDataVector csDV = CatalogStructureDataAccess.select(conn, dbc);
     if (csDV == null || csDV.size()==0){
       throw new Exception ("addCatalogStructureRecords() : Empty catalog structure.  storeCatalogId =" + storeCatalogId+ ", itemV =" + itemV.toString());
     }
     for (int i = 0; i < csDV.size(); i++) {
       CatalogStructureData csD = (CatalogStructureData)csDV.get(i);
       csD.setCatalogId(catalogId);
       csD.setCustomerSkuNum("");
       if (storeDistributor != 0 && RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT.equals(csD.getCatalogStructureCd())){
         csD.setBusEntityId(storeDistributor);
       }
       csD.setAddBy(loader);
       csD.setModBy(loader);
       csD.setAddDate(new Date());
       csD.setModDate(new Date());
       CatalogStructureDataAccess.insert(conn, csD);
     }
   }

   private HashSet getCatalogStructureRecords(Connection conn,  int catalogId) throws Exception {
     log.info("getCatalogStructureRecords() ====> for catalogId ="+ catalogId  );
     HashSet set = new HashSet();
     DBCriteria dbc = new DBCriteria();
     dbc.addEqualTo(CatalogStructureDataAccess.CATALOG_ID, catalogId);
     ArrayList cds = new ArrayList();
     cds.add(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_PRODUCT);
     cds.add(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
     dbc.addOneOf(CatalogStructureDataAccess.CATALOG_STRUCTURE_CD, cds);
     CatalogStructureDataVector csDV = CatalogStructureDataAccess.select(conn, dbc);
     if (csDV != null && csDV.size()>0){
       for (int i = 0; i < csDV.size(); i++) {
         CatalogStructureData csD = (CatalogStructureData)csDV.get(i);
         set.add(new Integer(csD.getItemId()));
       }
     }
     return set;
   }
   private void createPricingList(Connection conn, HashMap newListNamesMap, int storeId,   String listType, String loader, ArrayList errors) throws Exception {
     log.info("createPricingList() ====> BEGIN.");
      Date date = new Date(System.currentTimeMillis());
      Set listNames = newListNamesMap.keySet();
      for (Iterator iter = listNames.iterator(); iter.hasNext(); ) {
        String listName = (String) iter.next();
        PricingListViewVector plVV = (PricingListViewVector)newListNamesMap.get(listName);
        log.info("createPricingList() ====> create CLW_PRICE_LIST record for listName ="+ listName);
        int rank= ((PricingListView)plVV.get(0)).getRank();
        PriceListData plD = PriceListData.createValue();
        plD.setShortDesc(listName);
        String storeAssocCd = RefCodeNames.PRICE_LIST_ASSOC_CD.PROPRIETARY_LIST_STORE;
        if (listType.equals(RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST)){
          plD.setRank(rank);
          storeAssocCd = RefCodeNames.PRICE_LIST_ASSOC_CD.PRICE_LIST_STORE;
        }
        plD.setPriceListStatusCd(RefCodeNames.PRICE_LIST_STATUS_CD.ACTIVE);
        plD.setPriceListTypeCd(listType);
        plD.setAddBy(loader);
        plD.setModBy(loader);
        plD.setAddDate(date);
        plD.setModDate(date);
        log.info("createPricingList() ====> priceListData :" + plD.toString());
        plD = PriceListDataAccess.insert(conn, plD);
        int priceListId = plD.getPriceListId();
        log.info("createPricingList() ====> create CLW_PRICE_LIST_ASSOC with storeId =" +storeId+ " for listName ="+ listName);
        PriceListAssocData assocD = PriceListAssocData.createValue();
        assocD.setBusEntityId(storeId);
        assocD.setPriceListAssocCd(storeAssocCd);
        assocD.setPriceListId(priceListId);
        assocD.setAddBy(loader);
        assocD.setModBy(loader);
        assocD.setAddDate(date);
        assocD.setModDate(date);
        assocD = PriceListAssocDataAccess.insert(conn, assocD);
        log.info("createPricingList() ====> create CLW_PRICE_LIST_DETAIL records for listName ="+ listName + ", nRecords=" + plVV.size());
        HashSet toAddItemsData =new HashSet();
        toAddItemsData.addAll(plVV);
        addPriceListItems(conn, toAddItemsData, priceListId, loader);
      }
      log.info("createPricingList() ====> END.");
   }
   private void updatePricingList(Connection conn, HashMap existListNamesMap, int storeId,  String listType, String loader, ArrayList errors) throws Exception{

     log.info("updatePricingList() ====> BEGIN."  );
     Date date = new Date(System.currentTimeMillis());
     int n= 0;
     Set listNames = existListNamesMap.keySet();
     for (Iterator iter = listNames.iterator(); iter.hasNext(); ) {
       Integer listNameIdI = (Integer) iter.next();
       PricingListViewVector plVV = (PricingListViewVector)existListNamesMap.get(listNameIdI);
       int listNameId = listNameIdI.intValue();

       log.info("updatePricingList() ====> Inbound price list: listNameId =" + listNameId );
       log.info("updatePricingList() ====> Inbound items: plVV =" +plVV.toString());

       DBCriteria dbc = new DBCriteria();
       dbc.addEqualTo(PriceListDataAccess.PRICE_LIST_ID, listNameId);
       PriceListDataVector plDV = PriceListDataAccess.select(conn, dbc);
       //================update CLW_PRICE_LIST =========//
       if (listType.equals(RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST)){
         int rank= ((PricingListView)plVV.get(0)).getRank();
         if (plDV != null && plDV.size() == 1){
           PriceListData plD = (PriceListData)plDV.get(0);
           if (plD.getRank() != rank) {
             plD.setRank(rank);
             plD.setModBy(loader);
             plD.setModDate(date);
             n += PriceListDataAccess.update(conn, plD);
             log.info("updatePricingList() ====> UPDATED: old Rank=" + plD.getRank() +" => new Rank="+rank );
           }
         } else {
           throw new Exception("updatePricingList() ==> ERROR. Select from clw_price_list returns incorrect rows for price_list_Id ="+ listNameId);
         }
       }
       //==============================================//
       dbc = new DBCriteria();
       dbc.addEqualTo(PriceListDetailDataAccess.PRICE_LIST_ID, listNameId);
       PriceListDetailDataVector pldDV = PriceListDetailDataAccess.select(conn, dbc);
       log.info("updatePricingList() ====> Found items: pldDV =" +plVV.toString());

       // Inbound items
       HashMap inboundItemsMap = new HashMap();
       HashMap toAddItemsMap = new HashMap();
       for (int i = 0; plVV!= null && i < plVV.size(); i++) {
         PricingListView plV = (PricingListView)plVV.get(i);
         Integer itemIdI = new Integer(plV.getItemId());
         inboundItemsMap.put(itemIdI, plV);
         toAddItemsMap.put(itemIdI, plV);
       }
       // Existing items
       HashSet existItems = new HashSet();
       HashSet toDeleteItems = new HashSet();
       for (int i = 0; pldDV!= null && i < pldDV.size(); i++) {
         PriceListDetailData pldD = (PriceListDetailData)pldDV.get(i);
         Integer itemIdI = new Integer(pldD.getItemId());
         existItems.add(itemIdI);
         toDeleteItems.add(itemIdI);
       }
       Set toAddItems = toAddItemsMap.keySet();
       log.info("updatePricingList() ====> INIT toDeleteItems = " + toDeleteItems.toString()  );
       log.info("updatePricingList() ====> INIT toAddItems = " + toAddItems.toString()  );
       log.info("updatePricingList() ====> existItems = " + existItems.toString()  );
       log.info("updatePricingList() ====> inboundItemsMap.keySet() = " + inboundItemsMap.keySet() );

       boolean toAddFl = toAddItems.removeAll(existItems);
       boolean toDelFl = toDeleteItems.removeAll(inboundItemsMap.keySet());

       log.info("updatePricingList() ====> process DELETE ITEMS. toDeleteItems = " + toDeleteItems.toString()  );
       if (toDeleteItems.size() > 0 ){
         //--- remove items from CLW_PRICE_LIST_DETAIL
         deletePriceListItems(conn, toDeleteItems, listNameId);
       }
       log.info("updatePricingList() ====> process ADD ITEMS. toAddItems = " + toAddItems.toString()  );
       if (toAddItems.size() > 0) {
         HashSet toAddItemsData =new HashSet();
         for (Iterator it = toAddItems.iterator(); it.hasNext(); ) {
            Integer item = (Integer) it.next();
            PricingListView blV = (PricingListView) toAddItemsMap.get(item);
            toAddItemsData.add(blV);
         }
         //--- add items into CLW_PRICE_LIST_DETAIL
         addPriceListItems(conn, toAddItemsData, listNameId, loader);
 //        addBuyListVV.addAll(toAddItemsMap.values());
        }

        log.info("updatePricingList() ====> process UPDATE ITEMS. toAddItems = " + toAddItems.toString()  );

        if (listType.equals(RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST)){
          PriceListDetailDataVector toUpdateItemsV =  new PriceListDetailDataVector();
          for (int i = 0; i < pldDV.size(); i++) {
            PriceListDetailData pldD = (PriceListDetailData)pldDV.get(i);
            PricingListView inboundD = (PricingListView)inboundItemsMap.get(new Integer(pldD.getItemId()));
            log.info("updatePricingList() ====> process UPDATE for Item : pldD.getItemId() = "+ pldD.getItemId());
            if ( inboundD != null && pldD != null ){
              if ((pldD.getPrice().doubleValue() != inboundD.getPrice().doubleValue()) ||
                !( Utility.isEqual(pldD.getCustomerSkuNum(),inboundD.getCustSku())) ) {
                log.info("updatePricingList() ====> old Price = "+ pldD.getPrice().doubleValue() + " => new Price="+inboundD.getPrice().doubleValue());
                log.info("updatePricingList() ====> old Cust Sku = "+ pldD.getCustomerSkuNum() + " => new Cust Sku="+inboundD.getCustSku());
                pldD.setPrice(inboundD.getPrice());
                pldD.setCustomerSkuNum(inboundD.getCustSku());
                pldD.setModBy(loader);
                pldD.setModDate(date);
                toUpdateItemsV.add(pldD);
              }
            }
          }
          log.info("updatePricingList() ====> process UPDATE ITEMS. toUpdateItemsV = " + toUpdateItemsV.toString()  );
          if (toUpdateItemsV.size() >0){
            for (int i = 0; i < toUpdateItemsV.size(); i++) {
              PriceListDetailData pldD = (PriceListDetailData)toUpdateItemsV.get(i);
              PriceListDetailDataAccess.update(conn, pldD);
            }
          }
        }
      }
      log.info("updatePricingList() ====> CLW_PRICE_LIST: Records updated n =" + n );
      log.info("updatePricingList() ====> END." );

     }

//   }

   private void addPriceListItems(Connection conn, Set toAddItems, int priceListId, String loader) throws Exception{
     log.info("addPriceListItems() ====> BEGIN for priceListId =" + priceListId );
     Date date = new Date(System.currentTimeMillis());

     for (Iterator iter = toAddItems.iterator(); iter.hasNext(); ) {
       PricingListView plV= (PricingListView) iter.next();
//     for (int i = 0; i < plVV.size(); i++) {
//        PricingListView plV = (PricingListView)plVV.get(i);
        PriceListDetailData pldD = PriceListDetailData.createValue();
        pldD.setPriceListId(priceListId);
        pldD.setPrice(plV.getPrice());
        pldD.setItemId(plV.getItemId());
        pldD.setCustomerSkuNum(plV.getCustSku());
        pldD.setAddBy(loader);
        pldD.setModBy(loader);
        pldD.setAddDate(date);
        pldD.setModDate(date);
        pldD = PriceListDetailDataAccess.insert(conn, pldD);

     }
     log.info("addPriceListItems() ====> ADDED n =" + toAddItems.size() );

   }

   private void deletePriceListItems(Connection conn, Set toDeleteItems, int priceListId) throws Exception{
     log.info("deletePriceListItems() ====> BEGIN for priceListId =" + priceListId );

       IdVector toDeleteV = new IdVector();
       toDeleteV.addAll(toDeleteItems);
       DBCriteria dbc = new DBCriteria();
       dbc.addEqualTo(PriceListDetailDataAccess.PRICE_LIST_ID, priceListId);
       dbc.addOneOf(PriceListDetailDataAccess.ITEM_ID, toDeleteV);
       int n = PriceListDetailDataAccess.remove(conn, dbc);
       log.info("deletePriceListItems() ====> DELETED n =" + n );

   }
   private HashMap checkAllAccountRefNumFound(Connection conn, int storeId, String tempTableName, StringBuffer errMess) throws Exception {
     String sql = "SELECT clw_value, p.bus_entity_id "+
         "FROM clw_property p, "+
         "  clw_bus_entity be, "+
         "  clw_bus_entity_assoc bea "+
         "WHERE clw_value IS NOT NULL "+
         "  AND p.bus_entity_id = be.bus_entity_id "+
         "  AND p.bus_entity_id = bea.bus_entity1_id "+
         "  AND p.short_desc = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM + "' "+
         "  AND be.bus_entity_id = bea.bus_entity1_id "+
         "  AND be.bus_entity_type_cd = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT +"' "+
         "  AND bea.bus_entity2_id = " + storeId +
         "  AND bea.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE +"' "+
         "  AND clw_value IN ";

     log.info("checkAllAccountRefNumFound(): ===> Begin. SQL =" + sql);
     HashSet undefinedSet = new HashSet();
     HashSet multipleSet = new HashSet();

      HashMap foundAccountsMap = verifyExistsAndUniq(conn, sql, "account_ref_num", tempTableName, multipleSet, undefinedSet);

     if (undefinedSet.size() > 0){
       errMess.append("***Account(s) with Account Ref Num(s) "+undefinedSet.toString() +" are not found in the store.");
     }
     if (multipleSet.size() > 0){
      errMess.append("***Multiple Account(s) with Account Ref Num(s) "+multipleSet.toString() +" found in the store.");
    }
    log.info("checkAllAccountRefNumFound(): ===> End.");


     return foundAccountsMap;
  }
  private HashMap checkCompatibilitySiteToAccount(Connection conn,  String tempTableName, StringBuffer errMess) throws Exception {
    log.info("checkCompatibilitySiteToAccount(): ===> Begin."  );

     String sql = "select distinct * from "+
        "( "+
        "SELECT TMP.store_id , tmp.site_ref_num, tmp.account_ref_num,  s.site_id,  s.account_id "+
        " FROM  " + tempTableName+" tmp "+
        " left outer join (" +
        " SELECT pr.clw_value site_ref, pr.bus_entity_id site_id, pr1.clw_value account_ref, pr1.bus_entity_id account_id, acct.bus_entity2_id store_id "+
        " FROM clw_property pr, clw_bus_entity_assoc site, clw_property pr1, clw_bus_entity_assoc acct "+
        " WHERE pr.SHORT_DESC = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER+ "' "+
        " AND pr1.SHORT_DESC = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM + "' "+
        " AND pr.bus_entity_id = site.bus_entity1_id "+
        " AND pr1.bus_entity_id = site.bus_entity2_id "+
        " AND site.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT +"' "+
        " AND acct.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE +"' "+
        " AND acct.BUS_ENTITY1_ID = site.BUS_ENTITY2_ID  "+
        " ) s on  TMP.site_ref_num = s.site_ref and TMP.account_ref_num = s.account_ref and TMP.store_id = s.store_id "+
//        " left outer join clw_property s on TMP.site_ref_num = s.CLW_VALUE and s.short_desc = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER+ "' "+
//        " left outer join clw_property a on TMP.account_ref_num = a.CLW_VALUE and a.short_desc = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_ACCT_REF_NUM + "' "+
        ") xfile ";
/*        "left outer join ( "+
        "select SITE.BUS_ENTITY1_ID siteid, SITE.BUS_ENTITY2_ID accid, acc.BUS_ENTITY2_ID storeid "+
        " from clw_bus_entity_assoc site "+
        " inner join clw_bus_entity_assoc acc on site.BUS_ENTITY2_ID = acc.BUS_ENTITY1_ID "+
        " where site.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT +"' " +
        " and acc.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE +"' "+
        ") xdb on xfile.site= xdb.siteid and  xfile.acc=xdb.accid and xfile.store_id=xdb.storeid ";
*/
     log.info("checkCompatibilitySiteToAccount(): ===> SQL=" + sql );
     HashSet undefinedSet = new HashSet();
     HashMap multipleMap = new HashMap();
     HashMap uniqMap = new HashMap();

     HashMap foundSitesMap = new HashMap();

     PreparedStatement pstmt = conn.prepareStatement(sql);
     ResultSet rs = pstmt.executeQuery();
     while (rs.next()){
       String siteRefNum =rs.getString(2);
       String accRefNum =rs.getString(3);
//       int tmpSiteId = (rs.getString(4)!=null) ? rs.getInt(4) : 0;
//       int tmpAccId = (rs.getString(5)!=null) ? rs.getInt(5) : 0;
       int siteId = (rs.getString(4)!=null) ? rs.getInt(4) : 0;
       int accountId = (rs.getString(5)!=null) ? rs.getInt(5) : 0;

       String refKey =siteRefNum + "-" + accRefNum  ;
       if (siteId != 0 && accountId != 0){
         String idKey =  siteId + "/" + accountId;

         String val = (String)uniqMap.get(refKey);
         if (val != null) {
           HashSet idKeys = (HashSet)multipleMap.get(refKey);
           if (idKeys == null) {
             idKeys = new HashSet();
             idKeys.add(val);
             multipleMap.put(refKey,  idKeys);
           }
           idKeys.add(idKey);
         } else {
           uniqMap.put(refKey, idKey);
           foundSitesMap.put(refKey, new Integer(siteId));
         }

/*         if (val != null && !val.equals(refKey)) {
           HashSet list = (HashSet)multipleMap.get(siteId+"");
           if (list == null){
             list = new HashSet();
             list.add(val);
             multipleMap.put(siteId+"", list);
           }
           list.add(refKey);
         } else {
           uniqMap.put(refKey, idKey);
           foundSitesMap.put(refKey, new Integer(siteId));
         }
 */
       } else {
          undefinedSet.add(refKey);
       }

     }
     if (multipleMap.size() > 0){
       String err = "***Multiple site(s) are found in the account.";
       Set siteKeys = multipleMap.keySet();
       for (Iterator iter = siteKeys.iterator(); iter.hasNext(); ) {
         String siteKey = (String) iter.next();
         err += " Site/Account Ref Num:" + siteKey + "=> Site/Account Id pairs: " + ((HashSet)multipleMap.get(siteKey)).toString() +";";
       }
       errMess.append(err);
     }
     if (undefinedSet.size() > 0){
        errMess.append("***Site(s) are not found in the account. Site/Account Ref Num pairs: "+undefinedSet.toString()+".");
 //      errMess.append("***Incompatible Site and Account Ref Num(s) "+undefinedSiteAccMap.toString() );
     }
     log.info("checkCompatibilitySiteToAccount(): ===> End. Errors #: "+ errMess.length()  );
     return foundSitesMap;
   }
  private HashMap checkAllSiteRefNumFound(Connection conn, int storeId, String tempTableName, StringBuffer errMess) throws Exception {
     String sql ="SELECT clw_value, p.bus_entity_id "+
         "FROM clw_property p, "+
         "  clw_bus_entity acc,  "+
         "  clw_bus_entity_assoc acc_assoc, "+
         "  clw_bus_entity site, "+
         "  clw_bus_entity_assoc site_assoc "+
         "WHERE     clw_value IS NOT NULL "+
         "  AND p.BUS_ENTITY_ID = site.BUS_ENTITY_ID "+
         "  AND p.BUS_ENTITY_ID = site_assoc.BUS_ENTITY1_ID "+
         "  AND p.SHORT_DESC = '" + RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER+ "' "+
         "  AND site.BUS_ENTITY_TYPE_CD = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.SITE+ "' "+
         "  AND site.BUS_ENTITY_ID = site_assoc.BUS_ENTITY1_ID " +
         "  AND site_assoc.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.SITE_ACCOUNT +"' "+
         "  AND site_assoc.BUS_ENTITY2_ID = acc_assoc.BUS_ENTITY1_ID "+
         "  AND acc.BUS_ENTITY_TYPE_CD = '" +RefCodeNames.BUS_ENTITY_TYPE_CD.ACCOUNT +"' "+
         "  AND acc.BUS_ENTITY_ID = acc_assoc.BUS_ENTITY1_ID "+
         "  AND acc_assoc.BUS_ENTITY_ASSOC_CD = '" +RefCodeNames.BUS_ENTITY_ASSOC_CD.ACCOUNT_STORE +"' "+
         "  AND acc_assoc.BUS_ENTITY2_ID = " + storeId +
         "  AND clw_value IN ";

     log.info("checkAllSiteRefNumFound(): ===> Begin. " );
     HashSet undefinedSet = new HashSet();
     HashSet multipleSet = new HashSet();

      HashMap foundSitesMap = verifyExistsAndUniq(conn, sql, "site_ref_num", tempTableName, multipleSet, undefinedSet);

     if (undefinedSet.size() > 0){
       errMess.append("***Site(s) with Site Ref Num(s) "+undefinedSet.toString() +" are not found in the account.");
     }
     if (multipleSet.size() > 0){
      errMess.append("***Multiple Site(s) with Site Ref Num(s) "+multipleSet.toString() +" found in the account.");
    }
    log.info("checkAllSiteRefNumFound(): ===> End.");
    return foundSitesMap;
   }

   private HashMap checkAllShoppingCatalogFound(Connection conn, int storeId, String attrName, String tempTableName, StringBuffer errMess) throws Exception {
     log.info("checkAllShoppingCatalogFound(): ===> Begin. " );
     String sql = "select loader_field, c.catalog_id "+
         "from clw_catalog c, clw_catalog_assoc ca  "+
         " where  c.catalog_id = CA.CATALOG_ID  "+
         "   and CA.CATALOG_ASSOC_CD=  '" +RefCodeNames.CATALOG_ASSOC_CD.CATALOG_STORE +"' "+
         "   and C.CATALOG_TYPE_CD= '"+RefCodeNames.CATALOG_TYPE_CD.SHOPPING+"' "+
         "   and loader_field is not null "+
         "  and bus_entity_id =  " + storeId +
         "  and loader_field IN   ";

     // Search and check Catalogs by Catalog Keys
     log.info("checkAllShoppingCatalogFound(): ===> Search and check Catalogs by " + attrName +".");
     HashSet undefinedSet = new HashSet();
     HashSet multipleSet = new HashSet();
     HashMap foundCatalogSiteMap = verifyExistsAndUniq(conn, sql, attrName, tempTableName, multipleSet, undefinedSet);
/*     // Search and check Catalogs by Buy List Names
     log.info("checkAllShoppingCatalogFound(): ===> Search and check Catalogs by BUY_LIST.");
     HashSet undefinedSet1 = new HashSet();
     HashSet multipleSet1 = new HashSet();
     HashMap foundBuyListSiteMap = verifyExistsAndUniq(conn, sql, "buy_list", tempTableName, multipleSet1, undefinedSet1);
*/

     if (undefinedSet.size() > 0){
       errMess.append("***Catalog(s) with "+attrName+" "+undefinedSet.toString() +" are not found in the store.");
     }
     if (multipleSet.size() > 0){
       errMess.append("***Multiple Catalog(s) with "+ attrName+" "+multipleSet.toString() +" found in the store.") ;
     }
 /*    if (undefinedSet1.size() > 0){
       errMess.append("***Catalog(s) with Buy List(s) "+undefinedSet1.toString() +" are not found in the store.");
     }
     if (multipleSet1.size() > 0){
       errMess.append("***Multiple Catalog(s) with Buy List(s) "+multipleSet1.toString() +" found in the store.");
     }
*/
/*    log.info("checkAllShoppingCatalogFound(): ===> Check if Site have association with both Catalog and Buy List");
    Set incorrectAssocSet = new HashSet();
    Set buyListKeys = foundBuyListSiteMap.keySet();
    for (Iterator iter = buyListKeys.iterator(); iter.hasNext(); ) {
      String buyListKey = (String) iter.next();
      Integer buyListSite = (Integer)foundBuyListSiteMap.get(buyListKey);
      if (foundCatalogSiteMap.containsValue(buyListSite)){
        errMess.append("***Site have association with both Catalog and Buy List. Site(s) "+incorrectAssocSet.toString());
      }
    }
    foundCatalogSiteMap.putAll(foundPriceListSiteMap);
*/
    log.info("checkAllShoppingCatalogFound(): ===> End.");

    return foundCatalogSiteMap;

   }
   private HashMap checkAllPriceListFound(Connection conn, int storeId, String priceListTypeCd, int level, String tempTableName, StringBuffer errMess) throws Exception {
     log.info("checkAllPriceListFound(): ===> Begin. " );
     String priceListAssocCd = (RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST.equals(priceListTypeCd)) ?
                                RefCodeNames.PRICE_LIST_ASSOC_CD.PRICE_LIST_STORE :
                                RefCodeNames.PRICE_LIST_ASSOC_CD.PROPRIETARY_LIST_STORE;
     String sql = "select  short_desc, pl.price_list_id  "+
         "from clw_price_list pl, clw_price_list_assoc pla "+
         "where   pl.price_list_id = pla.price_list_id "+
         " and pl.price_list_type_cd = '"+priceListTypeCd+"' "+
         " and pla.price_list_assoc_cd = '"+priceListAssocCd+"' "+
         ((level > 0) ?" and pl.rank = " +level : "" ) +
         " and   bus_entity_id =  " + storeId +
         " and short_desc in  ";

     String attrName = (level>0) ? priceListTypeCd +"_" + level : priceListTypeCd;
     String messText = (level>0) ? "Price List(Level " +level+")" : "Proprietary List";
     HashSet undefinedSet = new HashSet();
     HashSet multipleSet = new HashSet();
     HashMap foundSitesMap = verifyExistsAndUniq(conn, sql, attrName, tempTableName, multipleSet, undefinedSet);

      if (undefinedSet.size() > 0){
        errMess.append("***" + messText+ " with name(s) "+undefinedSet.toString() +" are not found in the store.");
      }
      if (multipleSet.size() > 0){
        errMess.append("***Multiple " + messText+" with name(s) " + multipleSet.toString() +" found in the store.");
      }

      log.info("checkAllPriceListFound(): ===> End.");
    return foundSitesMap;

   }

   private HashMap verifyExistsAndUniq(Connection conn, String sql, String loaderTempTableFldName, String loaderTempTableName, HashSet multipleSet, HashSet undefinedSet) throws Exception{
     log.info("verifyExistsAndUniq() ===> Begin.");

     String tempSql = "SELECT DISTINCT "+loaderTempTableFldName+" FROM "+loaderTempTableName + " WHERE " + loaderTempTableFldName+" is not null";
     log.info("verifyExistsAndUniq() ===> SQL param :" + tempSql);
     String sqlS = sql + "(" +tempSql+")";
     log.info("verifyExistsAndUniq() ===> SQL =" + sqlS);

     HashMap<String, Integer> foundMap = new  HashMap<String, Integer>();

     PreparedStatement pstmt = conn.prepareStatement(sqlS);
 //    pstmt.setString(1,tempSql);
     ResultSet rs = pstmt.executeQuery();
     while (rs.next()) {
       String key = rs.getString(1);
       Integer val = new Integer(rs.getInt(2));
       log.info("verifyExistsAndUniq() ===> key=" + key + ", val="+val);
       if (!foundMap.containsKey(key)) {
         foundMap.put(key, val);
       } else {
         multipleSet.add(key);
       }
     }
     pstmt.close();

     pstmt = conn.prepareStatement(tempSql);
     rs = pstmt.executeQuery();
     int numRec = 0;
     while (rs.next()) {
       numRec++ ;
       String key = rs.getString(1);
       if (!foundMap.containsKey(key)) {
         undefinedSet.add(key);
       }
     }
     pstmt.close();
     log.info("verifyExistsAndUniq(): ===>numRec="+numRec+", foundMap =" + foundMap.toString());

     return foundMap ;
   }

   private void createAccountCatalogFromShopping(Connection conn, int storeId, int accountId, int siteId, int shoppingCatalogId, String loader) throws Exception{
      log.info("createAccountCatalogFromShopping() ====> BEGIN.");
      Date date = new Date(System.currentTimeMillis());
      String catalogName = "Account Catalog "+ accountId;
       log.info( "createAccountCatalogFromShopping() ====> create CLW_CATALOG record for catalog Name =" + catalogName);
       // create record in CLW_CATALOG
       CatalogData pCatalog = CatalogData.createValue();
       pCatalog.setCatalogStatusCd(RefCodeNames.CATALOG_STATUS_CD.ACTIVE);
       pCatalog.setCatalogTypeCd(RefCodeNames.CATALOG_TYPE_CD.ACCOUNT);
       pCatalog.setShortDesc(catalogName);
       pCatalog.setLoaderField(catalogName);
       pCatalog.setAddBy(loader);
       pCatalog.setModBy(loader);
       pCatalog.setAddDate(date);
       pCatalog.setModDate(date);
       pCatalog = CatalogDataAccess.insert(conn, pCatalog);
       int accCatalogId = pCatalog.getCatalogId();

       // we don't need to create record in CLW_CONTRACT for ACCOUNT catalog
       // we don't need to create record in CLW_ORDER_GUIDE for ACCOUNT catalog
       // we don't need to add Contract items for ACCOUNT catalog

       // create assoc with STORE and ACCOUNT
       log.info("createAccountCatalogFromShopping() ====> create assoc with STORE for accCatalogId =" + accCatalogId);
       CatalogAssocData caD = addNewCatalogAssoc( conn, storeId, accCatalogId, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_STORE, loader);
       caD = addNewCatalogAssoc( conn, accountId, accCatalogId, RefCodeNames.CATALOG_ASSOC_CD.CATALOG_ACCOUNT, loader);


       // create records in CLW_CATALOG_STRUCTURE, CLW_ITEM_ASSOC
       CatalogStructureDataAccess csda = new CatalogStructureDataAccess();
       String allColNames =csda.getSelectColumns();
       String subColNames = allColNames.replaceAll("CLW_CATALOG_STRUCTURE.CATALOG_STRUCTURE_ID", "CLW_CATALOG_STRUCTURE_SEQ.NEXTVAL");
       subColNames = subColNames.replaceAll("CLW_CATALOG_STRUCTURE.CATALOG_ID", "" +accCatalogId);
       subColNames = subColNames.replaceAll("CLW_CATALOG_STRUCTURE.ADD_DATE", "sysdate");
       subColNames = subColNames.replaceAll("CLW_CATALOG_STRUCTURE.MOD_DATE", "sysdate");
       subColNames = subColNames.replaceAll("CLW_CATALOG_STRUCTURE.ADD_DATE", loader);
       subColNames = subColNames.replaceAll("CLW_CATALOG_STRUCTURE.MOD_DATE", loader);
       log.info("createAccountCatalogFromShopping() ====> subColNames = " + subColNames);
       String sql = "insert into "+CatalogStructureDataAccess.CLW_CATALOG_STRUCTURE +" (" + allColNames+ ")" +
           " select "+ subColNames +
           " from "+CatalogStructureDataAccess.CLW_CATALOG_STRUCTURE +" where catalog_id =" + shoppingCatalogId;
       log.info("createAccountCatalogFromShopping() ====> COPY records ==CLW_CATALOG_STRUCTURE=====> SQL:" + sql);
       PreparedStatement pstmt = conn.prepareStatement(sql);
       ResultSet rs = pstmt.executeQuery();
       pstmt.close();
       //-------------------------------------------------------//
       ItemAssocDataAccess iada = new ItemAssocDataAccess();
       allColNames =iada.getSelectColumns();
       subColNames = allColNames.replaceAll("CLW_ITEM_ASSOC.ITEM_ASSOC_ID", "CLW_ITEM_ASSOC_SEQ.NEXTVAL");
       subColNames = subColNames.replaceAll("CLW_ITEM_ASSOC.CATALOG_ID", "" +accCatalogId);
       subColNames = subColNames.replaceAll("CLW_ITEM_ASSOC.ADD_DATE", "sysdate");
       subColNames = subColNames.replaceAll("CLW_ITEM_ASSOC.MOD_DATE", "sysdate");
       subColNames = subColNames.replaceAll("CLW_ITEM_ASSOC.ADD_DATE", loader);
       subColNames = subColNames.replaceAll("CLW_ITEM_ASSOC.MOD_DATE", loader);
       log.info("createAccountCatalogFromShopping() ====> subColNames = " + subColNames);
       sql = "insert into "+ItemAssocDataAccess.CLW_ITEM_ASSOC +" (" + allColNames+ ")" +
           " select "+ subColNames +
           " from "+ItemAssocDataAccess.CLW_ITEM_ASSOC +" where catalog_id =" + shoppingCatalogId;
       log.info("createAccountCatalogFromShopping() ====> COPY records===== CLW_ITEM_ASSOC ==> SQL:" + sql);
        pstmt = conn.prepareStatement(sql);
        rs = pstmt.executeQuery();
       pstmt.close();

       //-------------------------------------------------//

      log.info("createAccountCatalogFromShopping() ====> END.");

}

private void updateAccountCatalogFromShopping(Connection conn, int accCatalogId, int accountId, int siteId, int shoppingCatalogId, String loader) throws Exception{
  log.info("updateAccountCatalogFromShopping() ====> BEGIN."  );
  Date date = new Date(System.currentTimeMillis());
    log.info("updateAccountCatalogFromShopping() ====> process for accCatalogId =" + accCatalogId );
    ItemAssocDataAccess iada = new ItemAssocDataAccess();
    //String allColNames =iada.getSelectColumns();
    String colNames = ItemAssocDataAccess.ITEM1_ID +",";
    colNames += ItemAssocDataAccess.ITEM2_ID+",";
    colNames += ItemAssocDataAccess.ITEM_ASSOC_CD;
    String sql = "select " + colNames +
                    " from CLW_ITEM_ASSOC where catalog_id =" + shoppingCatalogId +
                    " minus " +
                    " select " + colNames +
                    " from CLW_ITEM_ASSOC where catalog_id =" + accCatalogId ;
    log.info("updateAccountCatalogFromShopping() ====>SQL 1 :"  + sql);

    PreparedStatement pstmt = conn.prepareStatement(sql);
    ResultSet rs = pstmt.executeQuery();
    int m = 0;
    while (rs.next()){
      //ItemAssocData iaD =(ItemAssocData)iada.parseResultSet(rs);
      ItemAssocData iaD = ItemAssocData.createValue();
      iaD.setItem1Id(rs.getInt(ItemAssocDataAccess.ITEM1_ID));
      iaD.setItem2Id(rs.getInt(ItemAssocDataAccess.ITEM2_ID));
      iaD.setItemAssocCd(rs.getString(ItemAssocDataAccess.ITEM_ASSOC_CD));
      iaD.setCatalogId(accCatalogId);
      iaD.setAddBy(loader);
      iaD.setAddDate(date);
      iaD.setModBy(loader);
      iaD.setModDate(date);
      iaD = ItemAssocDataAccess.insert(conn, iaD);
     m++;
    }
    log.info("updateAccountCatalogFromShopping()  ====> ADDED into Item Assoc m =" + m );

    pstmt.close();
    //--------------------------------------------------------------------------------//
    CatalogStructureDataAccess csda = new CatalogStructureDataAccess();

    //allColNames =csda.getSelectColumns();
    colNames = CatalogStructureDataAccess.ITEM_ID +",";
    colNames += CatalogStructureDataAccess.CATALOG_STRUCTURE_CD ;
 //   colNames += CatalogStructureDataAccess.CUSTOMER_SKU_NUM +",";
 //   colNames += CatalogStructureDataAccess.COST_CENTER_ID +",";
 //   colNames += CatalogStructureDataAccess.SORT_ORDER +",";
    sql = "select " + colNames +
                    " from CLW_CATALOG_STRUCTURE where catalog_id =" + shoppingCatalogId +
                    " minus " +
                    " select " + colNames +
                    " from CLW_CATALOG_STRUCTURE where catalog_id =" + accCatalogId ;
    log.info("updateAccountCatalogFromShopping() ====>SQL 2 :"  + sql);
    pstmt = conn.prepareStatement(sql);
    rs = pstmt.executeQuery();
    int n = 0;
    while (rs.next()){
//      CatalogStructureData csD= (CatalogStructureData)csda.parseResultSet(rs);
      CatalogStructureData csD= CatalogStructureData.createValue();
      csD.setItemId(rs.getInt(CatalogStructureDataAccess.ITEM_ID));
      csD.setCatalogStructureCd(rs.getString(CatalogStructureDataAccess.CATALOG_STRUCTURE_CD));
      csD.setCatalogId(accCatalogId);
      csD.setAddBy(loader);
      csD.setAddDate(date);
      csD.setModBy(loader);
      csD.setModDate(date);
      csD = CatalogStructureDataAccess.insert(conn, csD);
      n++;

    }
    log.info("updateAccountCatalogFromShopping()  ====> ADDED into Catalog Structure n =" + n );
    pstmt.close();

  log.info("updateAccountCatalogFromShopping() ====> END."  );

 }
 private HashMap getItemMap(Connection conn, int storeId, int distId) throws Exception {
   ItemInformation itemInfoEjb = APIAccess.getAPIAccess().getItemInformationAPI();
   DBCriteria dbc = new DBCriteria();
   dbc.addEqualTo(ItemMappingDataAccess.BUS_ENTITY_ID, distId);
   dbc.addIsNotNull(ItemMappingDataAccess.ITEM_NUM);
   dbc.addIsNotNull(ItemMappingDataAccess.ITEM_UOM);
   dbc.addJoinTable(ItemDataAccess.CLW_ITEM);
   dbc.addJoinCondition(ItemDataAccess.CLW_ITEM, ItemDataAccess.ITEM_ID, ItemMappingDataAccess.CLW_ITEM_MAPPING,  ItemMappingDataAccess.ITEM_ID);
   dbc.addJoinTableEqualTo(ItemDataAccess.CLW_ITEM, ItemDataAccess.ITEM_STATUS_CD, RefCodeNames.BUS_ENTITY_STATUS_CD.ACTIVE);
   ItemMappingDataVector imDV = itemInfoEjb.getItemMappingsCollection(dbc);
   if (imDV == null || imDV.size() == 0){
     throw new Exception("^clw^There are no active items for distributor. Distributor Id :" + distId +"^clw^");
   }
   HashMap allDistrItemsMap = new HashMap();
   for (int i = 0; imDV != null && i < imDV.size(); i++) {
     ItemMappingData imD = (ItemMappingData)imDV.get(i);
     String key = storeId+"/"+distId+"/"+imD.getItemNum()+"/"+imD.getItemUom();
     if (!allDistrItemsMap.containsKey(key)){
       allDistrItemsMap.put(key, new Integer(imD.getItemId()));
     }
   }
   return allDistrItemsMap;
 }
 private int updateTempTabSiteIdsBySiteRefNums(Connection conn, int storeNum, String siteloader, String tempTable, StringBuffer errMess) throws SQLException{
   String updateSql = "update "+tempTable+" t  set t.site_id =  ( "+
       "select distinct bus_entity_id from clw_property p " +
       " where p.short_desc ='" +RefCodeNames.PROPERTY_TYPE_CD.DIST_SITE_REFERENCE_NUMBER+ "' "+
       " and p.clw_value = t.site_ref_num "+
       " and exists (select 1 from clw_bus_entity_assoc where bus_entity2_id =t.account_id and p.bus_entity_id = bus_entity1_id))";

   log.info("[IntegrationServicesBean].updateTempTabSiteIdsBySiteRefNums() => updateSql :" +updateSql);
   PreparedStatement pstmt = conn.prepareStatement(updateSql);
   int n = pstmt.executeUpdate();
   pstmt.close();
   log.info("[IntegrationServicesBean].updateTempTabSiteIdsBySiteRefNums() => Site Ids : UPDATED = " +n);
   return n;
 }

 private int genNewSiteIdsIntoTempTab(Connection conn, String tempTable) throws SQLException{
   String updateSql1 = "update "+tempTable+" t  set ( t.update_fl )=(select  'NEW' from dual ) where t.site_id is null ";
   String updateSql2 = "update "+tempTable+" t  set  t.site_id =clw_bus_entity_seq.nextval where t.update_fl = 'NEW' ";
   log.info("[IntegrationServicesBean].genNewSiteIdsIntoTempTab() => updateSql 1:" +updateSql1);
   PreparedStatement pstmt = conn.prepareStatement(updateSql1);
   int n = pstmt.executeUpdate();
   pstmt.close();
   log.info("[IntegrationServicesBean].genNewSiteIdsIntoTempTab() => updateSql 2:" +updateSql2);
   pstmt = conn.prepareStatement(updateSql2);
   n = pstmt.executeUpdate();
   pstmt.close();
   log.info("[IntegrationServicesBean].genNewSiteIdsIntoTempTab() => Site Ids : GENERATED = " +n);
  return n;
 }

 private void verifyPriceListAssocIntegrity (Connection conn, String listType) throws Exception {
   if (!RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST.equals(listType)){
     return;
   }
  log.info("[IntegrationServicesBean].verifyPriceListAssocIntegrity() => BEGIN." );
  String subSql = "select PLA.BUS_ENTITY_ID " +
       " from clw_price_list_assoc pla , clw_price_list pl "+
       " where PLA.PRICE_LIST_ASSOC_CD='"+RefCodeNames.PRICE_LIST_ASSOC_CD.PRICE_LIST_SITE+"'  " +
       " and PL.PRICE_LIST_TYPE_CD = '"+RefCodeNames.PRICE_LIST_TYPE_CD.PRICE_LIST+"'  " +
       " and PLA.PRICE_LIST_ID = PL.PRICE_LIST_ID " +
       " group by PL.RANK, PLA.BUS_ENTITY_ID " +
       " having count( PL.RANK) >1  " ;
   String sql = "select short_desc, rank, PLA.BUS_ENTITY_ID " +
       "  from   clw_price_list pl,  clw_price_list_assoc pla " +
       " where PLA.PRICE_LIST_ASSOC_CD='"+RefCodeNames.PRICE_LIST_ASSOC_CD.PRICE_LIST_SITE+"'  " +
       " and PLA.PRICE_LIST_ID = PL.PRICE_LIST_ID " +
       " and PLA.BUS_ENTITY_ID in ( "+ subSql + " )";

   log.info("[IntegrationServicesBean].verifyPriceListAssocIntegrity() => sql :" +sql);

   PreparedStatement pstmt = conn.prepareStatement(sql);
   ResultSet rs = pstmt.executeQuery();
   HashMap incorrectAssocMap = new HashMap();
   HashMap siteToRankMap = new HashMap();
   ArrayList listNames = new ArrayList();
   while (rs.next()){
     String listName = rs.getString(1);
     String rank = rs.getString(2);
     String siteIdS = rs.getString(3);
     if (!incorrectAssocMap.containsKey(siteIdS)){
       listNames = new IdVector();
     } else {
       listNames = (ArrayList)incorrectAssocMap.get(siteIdS);
     }
     listNames.add(listName);
     incorrectAssocMap.put(siteIdS, listNames );
     siteToRankMap.put(siteIdS, rank);
   }
   log.info("[IntegrationServicesBean].verifyPriceListAssocIntegrity() => incorrectAssocMap.size() =" + incorrectAssocMap.size() );
   if (incorrectAssocMap.size() >0 && siteToRankMap.size() > 0 ){
     Set sites = incorrectAssocMap.keySet();
     String errMess= "***Price List association becomes incorrect: there are 2 price lists with the same rank for Site.";
     for (Iterator iter = sites.iterator(); iter.hasNext(); ) {
       String site = (String) iter.next();
       String rank = (String)siteToRankMap.get(site);
       listNames = (ArrayList)incorrectAssocMap.get(site);
       errMess +=" Site Id=" +site+ ", Price Lists="+listNames.toString()+", Rank="+rank+ "; " ;
  //     errors.add(errMess);
     }
     throw new Exception (errMess);
    }
    log.info("[IntegrationServicesBean].verifyPriceListAssocIntegrity() => END." );

   pstmt.close();

  }

  private HashMap getItemCategoryAssocMap(Connection conn, int catalogId, String assocTypeCd) throws Exception {
   log.info("getItemCategoryAssoc() ====> for catalogId ="+ catalogId + "; assocTypeCd=" + assocTypeCd );
   HashMap map = new HashMap();
   HashSet duplicateItemCategoryAssoc = new HashSet();
   ArrayList errors = new ArrayList() ;
   DBCriteria dbc = new DBCriteria();
   dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, catalogId);
   dbc.addEqualTo(ItemAssocDataAccess.ITEM_ASSOC_CD, assocTypeCd);
   ItemAssocDataVector iaDV = ItemAssocDataAccess.select(conn, dbc);
   for (int i = 0; i < iaDV.size(); i++) {
     ItemAssocData iaD = (ItemAssocData)iaDV.get(i);
     Integer itemId = new Integer(iaD.getItem1Id());
     Integer categoryId = new Integer(iaD.getItem2Id());
     if (!map.containsKey(itemId)) {
       map.put(itemId, categoryId);
     } else {
       duplicateItemCategoryAssoc.add(itemId);
     }
   }
   if (duplicateItemCategoryAssoc.size() > 0){
     String errMess = "Multiple categories for item in catalog. CatalogId="+ catalogId + "; AssocTypeCd=" + assocTypeCd + "; Items =" +duplicateItemCategoryAssoc.toString() ;
      throw new Exception("^clw^"+ errMess +"^clw^");
   }
   return map;

 }

 private void checkCreateCategories(Connection conn, int storeNum, int storeCatalogId, String loader, String tempTable, StringBuffer errMess) throws Exception {
   log.info("checkCreateCategory() ===> Begin.");
//------------------------------------------------------------------------------------------------
   String subSql =
         " select T.SUBCAT3 cat, t.subcat2 super_cat  from " + tempTable + " t where  T.SUBCAT2 is not null and T.SUBCAT3 is not null "+
         " union  "+
         " select T.SUBCAT2 cat, t.subcat1 super_cat from " + tempTable + " t where  T.SUBCAT2 is not null and T.SUBCAT1 is not null "+
         " union  "+
         " select T.SUBCAT1 cat, t.category_name super_cat  from " + tempTable + " t where  T.SUBCAT1 is not null  ";

   String checkCatagories =
       "select cat, super_cat from ( "+ subSql +" )"+
       " where  cat in ( "+
       " select cat from ( "+ subSql +" ) "+
       " group by cat having count(*) > 1 )";

   String selCatNew = "select distinct cat, orderNum from (" +
       " select distinct category_name cat, category_order orderNum from " + tempTable + " t where T.CATEGORY_NAME is not null" +
       " union  " +
       " select distinct T.SUBCAT1 cat, SUBCAT1_ORDER orderNum from " + tempTable + " t where T.SUBCAT1 is not null " +
       " union  " +
       " select distinct T.SUBCAT2 cat, SUBCAT2_ORDER orderNum from " + tempTable + " t where T.SUBCAT2 is not null " +
       " union  " +
       " select distinct T.SUBCAT3 cat, SUBCAT3_ORDER orderNum from " + tempTable + " t where T.SUBCAT3 is not null ) a  " +
       " where not exists  (select 1 from clw_item i , clw_catalog_structure cs where upper(i.short_desc|| long_desc) = upper(cat) " +
       "   and item_type_cd = '"+RefCodeNames.ITEM_TYPE_CD.CATEGORY+"' "+
       "   and i.item_id = cs.item_id and CS.CATALOG_ID = "+ storeCatalogId +
       "   and CS.CATALOG_STRUCTURE_CD ='"+RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY+"' ) " ;


  log.info("checkCreateCategory() => SQL : " + checkCatagories);
  PreparedStatement pstmt = conn.prepareStatement(checkCatagories);
  ResultSet rs = pstmt.executeQuery();
  int errs = 0;
  HashMap multySuperCatMap = new HashMap();
  while (rs.next()) {
    String cat = rs.getString(1);
    String superCat = rs.getString(2);
    Set superCatSet =(HashSet)multySuperCatMap.get(cat);
    if (superCatSet == null){
      superCatSet = new HashSet();
      multySuperCatMap.put(cat,superCatSet );
    }
    superCatSet.add(superCat);
  }
  pstmt.close();
  Set catNames = multySuperCatMap.keySet();
  for (Iterator iter = catNames.iterator(); iter.hasNext(); ) {
    String catName = (String) iter.next();
    Set superCats = (HashSet)multySuperCatMap.get(catName);
    errMess.append("***Category '"+catName+"' has multiple super categories: "+superCats.toString());
  }
  if (multySuperCatMap.size()>0){
    return;
  }

  log.info("checkCreateCategory() => selCatNew SQL : " + selCatNew);
 Date runDate = new Date();
  pstmt = conn.prepareStatement(selCatNew);
  rs = pstmt.executeQuery();
  HashMap catMap = new HashMap();
  while(rs.next()) {
    String catName = rs.getString(1);
    if (catMap.containsKey(catName.toUpperCase())) {
      log.info("checkCreateCategory() =>Create NEW category: skip name :'" + catName + "'");
      continue;
    }
    int catOrder = (Utility.isSet(rs.getString(2)))? rs.getInt(2) : 0;
    ItemData iD = ItemData.createValue();
    iD.setShortDesc(catName);
    iD.setEffDate(runDate);
    iD.setItemTypeCd(RefCodeNames.ITEM_TYPE_CD.CATEGORY);
    iD.setItemStatusCd(RefCodeNames.ITEM_STATUS_CD.ACTIVE);
    iD.setAddBy(loader);
    iD.setModBy(loader);
    iD = ItemDataAccess.insert(conn, iD);
    int categoryId = iD.getItemId();

    CatalogStructureData catalogStructureData = CatalogStructureData.createValue();
    catalogStructureData.setCatalogId(storeCatalogId);
    catalogStructureData.setCatalogStructureCd(RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY);
    catalogStructureData.setItemId(categoryId);
    catalogStructureData.setEffDate(runDate);
    catalogStructureData.setSortOrder(catOrder);
    catalogStructureData.setStatusCd(RefCodeNames.CATALOG_STRUCTURE_STATUS_CD.ACTIVE);
    catalogStructureData.setAddBy(loader);
    CatalogStructureDataAccess.insert(conn, catalogStructureData);

    catMap.put(catName.toUpperCase(), new Integer(categoryId));
  }
  pstmt.close();
  //-----------------------populate ids for categories----------------
  errMess.append(updateNSCCatalogTempTableCategoryIds(conn, tempTable, storeCatalogId, "category_id", "category_name"));
  errMess.append(updateNSCCatalogTempTableCategoryIds(conn, tempTable, storeCatalogId,"subCat1_id", "subCat1"));
  errMess.append(updateNSCCatalogTempTableCategoryIds(conn, tempTable, storeCatalogId,"subCat2_id", "subCat2"));
  errMess.append(updateNSCCatalogTempTableCategoryIds(conn, tempTable, storeCatalogId,"subCat3_id", "subCat3"));
  if (errMess.length() > 0){
    return;
  }
 //-------------------------------------------------------------------
 // add associations for new categories
 String inboundAssoc = "(select category_id, subcat1_id FROM " + tempTable + " t  WHERE T.CATEGORY_ID IS NOT NULL AND T.Subcat1_ID IS not  NULL "+
         " union "+
         " select subcat1_id, subcat2_id FROM " + tempTable + " t  WHERE T.subcat1 IS NOT NULL AND T.Subcat2_ID IS not  NULL " +
         " union "+
         " select subcat2_id, subcat3_id  FROM " + tempTable + " t WHERE T.subcat2 IS NOT NULL AND T.Subcat3 IS not  NULL) " ;


     log.info("checkCreateCategory() => inboundAssoc SQL : " + inboundAssoc);
     pstmt = conn.prepareStatement(inboundAssoc);
     rs = pstmt.executeQuery();
     HashMap inboundMap = new HashMap();
     while (rs.next()){
       int item2_id =(rs.getString(1)!=null)? rs.getInt(1) : 0;
       int item1_id =(rs.getString(2)!=null)? rs.getInt(2) : 0;
       inboundMap.put(new Integer(item1_id), new Integer(item2_id));
//       addItemAssoc(conn, storeCatalogId, item1_id, item2_id, RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY, loader );
     }
    pstmt.close();
    log.info("checkCreateCategory() => inboundMap : " + inboundMap.toString());

    DBCriteria dbc = new DBCriteria();
    dbc.addEqualTo(ItemAssocDataAccess.ITEM_ASSOC_CD, RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY);
    dbc.addEqualTo(ItemAssocDataAccess.CATALOG_ID, storeCatalogId);
    ItemAssocDataVector iaDV = ItemAssocDataAccess.select(conn, dbc);
    HashMap existsMap = new HashMap();
    for (int i = 0; i < iaDV.size(); i++) {
      ItemAssocData iaD = (ItemAssocData)iaDV.get(i);
      existsMap.put(new Integer(iaD.getItem1Id()), iaD);
    }
    log.info("checkCreateCategory() => Exists Item Assoc for categories :existsMap.size() : " + existsMap.size() + "; store");

  //  ItemAssocDataVector toUpdateV = new ItemAssocDataVector();
    Set keys = existsMap.keySet();
    for (Iterator iter = keys.iterator(); iter.hasNext(); ) {

      Integer bdChildId = (Integer) iter.next();
      ItemAssocData iaD = (ItemAssocData)existsMap.get(bdChildId);
      Integer inParentId = (Integer)inboundMap.get(bdChildId);

      Integer bdParentId =new Integer(iaD.getItem2Id());
      Integer inChildId = (Integer)inboundMap.get(bdParentId);

      if (inParentId != null && !inParentId.equals(bdParentId) ) {
        iaD.setItem2Id(inParentId.intValue());
        iaD.setAddBy(loader);
        iaD.setModBy(loader);
        ItemAssocDataAccess.update(conn, iaD);
      } else if (inChildId != null && inParentId != null && inChildId.equals(bdParentId) && inParentId.equals(bdChildId) ) {
        iaD.setItem1Id(inChildId.intValue());
        iaD.setItem2Id(inParentId.intValue());
        iaD.setAddBy(loader);
        iaD.setModBy(loader);
        ItemAssocDataAccess.update(conn, iaD);
      }
    }
//    log.info("checkCreateCategory() => toUpdatePairMap : " + toUpdatePairMap.toString());

    keys = inboundMap.keySet();
    int n= 0;
    for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
      Integer childId = (Integer) iter.next();
      Integer parentId = (Integer) inboundMap.get(childId);
      if (existsMap.isEmpty() || !existsMap.containsKey(childId)){
        addItemAssoc(conn, storeCatalogId, childId, parentId, RefCodeNames.ITEM_ASSOC_CD.CATEGORY_PARENT_CATEGORY, loader);
        n++;
      }
    }
    log.info("checkCreateCategory() => ItemAssocData ADDED : n= " + n);

 }
 private void addItemAssoc(Connection conn ,int storeCatalogId,  Integer item1Id, Integer item2Id , String itemAssocCd, String loader ) throws Exception{
     ItemAssocData iaD = ItemAssocData.createValue();
     iaD.setItem1Id(item1Id.intValue());
     iaD.setItem2Id(item2Id.intValue());
     iaD.setCatalogId(storeCatalogId);
     iaD.setItemAssocCd(itemAssocCd);
     iaD.setAddBy(loader);
     iaD.setModBy(loader);
     ItemAssocDataAccess.insert(conn, iaD);
 }


 private StringBuffer updateNSCCatalogTempTableCategoryIds (Connection conn, String tempTable, int storeCatalogId, String idName, String fldName ) throws Exception {
   StringBuffer errMess = new StringBuffer();
   String sql = "update "+tempTable+" t set (t."+ idName +" )= ( "+
       " select i.item_id from clw_item i, clw_catalog_structure cs  "+
       " where upper(i.SHORT_DESC||i.LONG_DESC) = upper(t." + fldName +")" +
       " and i.item_type_cd = '"+RefCodeNames.ITEM_TYPE_CD.CATEGORY+"' "+
       " and i.item_id = cs.item_id and cs.CATALOG_STRUCTURE_CD = '"+RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY+"' " +
       " and cs.CATALOG_ID = " + storeCatalogId +")" ;

   String checkSql = "select i.SHORT_DESC||i.LONG_DESC categoryName  " +
       " from clw_item i, clw_catalog_structure cs" +
       " where upper(i.SHORT_DESC||i.LONG_DESC) in (select distinct upper(t." + fldName +") from " +tempTable+ " t)" +
       " and i.item_type_cd = '"+RefCodeNames.ITEM_TYPE_CD.CATEGORY+"' "+
       " and i.item_id = cs.item_id  " +
       " and cs.CATALOG_STRUCTURE_CD =  '"+RefCodeNames.CATALOG_STRUCTURE_CD.CATALOG_CATEGORY+"' "+
       " and cs.CATALOG_ID = " + storeCatalogId +
       " group by  i.SHORT_DESC||i.LONG_DESC " +
       " having count(*)>1 ";
   log.info("updateNSCCatalogTempTableCategoryIds() ===>SQL: "+checkSql );
   PreparedStatement pstmt = conn.prepareStatement(checkSql);
   ResultSet rs = pstmt.executeQuery();
   HashSet multipleNames = new HashSet();
   while (rs.next()){
     multipleNames.add(rs.getString(1));
   }
   if ( multipleNames.size() >0){
     errMess.append("***There are multiple categories with the same name in the store catalog. Category name(s)='"+multipleNames.toString()+"'; catalog_id = "+storeCatalogId+" .");
     return errMess;
   }
   rs.close();
   pstmt.close();

   log.info("updateNSCCatalogTempTableCategoryIds() ===>SQL: "+sql );
   pstmt = conn.prepareStatement(sql);
   pstmt.executeUpdate();
   pstmt.close();
   return errMess;
 }

 private HashMap<String,Integer> getCostCenterKeyToIdMap (Connection conn, String loader, String tempTable) throws SQLException {
    HashMap<String,Integer> map =new HashMap<String,Integer>();
    String selectCostCentersSql = "select cost_center_code, cost_center_id from clw_cost_center cc where cost_center_code in ("+
        " select distinct cost_center_key from " + tempTable + " where add_by = ? and add_date >=trunc(sysdate) and cost_center_key is not null" +
        ")";
    PreparedStatement pstmt = conn.prepareStatement(selectCostCentersSql);
    pstmt.setString(1, loader);
    ResultSet rs = pstmt.executeQuery();
    while(rs!=null && rs.next()){
      String key = rs.getString(1);
      Integer id = new Integer(rs.getInt(2));
      map.put(key, id);
    }
    log.info("getCostCenterKeyToIdMap(): map = " + map.toString());

    return map;
  }

 public HashMap processInventoryUpdate(int pSiteId, HashMap pItemMap, String pUserName) throws RemoteException{

	 HashMap updatedIds = new HashMap();
	 IdVector ids = new IdVector();
     for (Object id : pItemMap.keySet()) {
       Integer x = (Integer)id;
       ids.add(x);
     }
	 Connection conn = null;
	 try {
         conn = getConnection();
       	 InventoryLevelViewVector ilvv = InventoryLevelDAO.getInvLevelViewCollections(conn, pSiteId, ids);
         log.info("InventoryLevelViewVector.size(): " + ilvv.size());
         for (Object o : ilvv) {
        	 InventoryLevelView ilView = (InventoryLevelView)o;
        	 Integer qtyOnHand = ((Integer)pItemMap.get(ilView.getInventoryLevelData().getItemId()));
        	 ilView.getInventoryLevelData().setQtyOnHand(qtyOnHand.toString());
        	 Date origModDate = (Date)ilView.getInventoryLevelData().getModDate().clone();
        	 ilView = InventoryLevelDAO.updateInventoryLevelView(conn, ilView, true, pUserName);
        	 Integer updQtyOnHand = null;
        	 try {
        		 updQtyOnHand = Integer.parseInt(ilView.getInventoryLevelData().getQtyOnHand());
        	 } catch (NumberFormatException nfe) {
        		 log.error(nfe);
        	 }
        	 if (ilView.getInventoryLevelData().getModDate().after(origModDate) &&
        			 updQtyOnHand != null && updQtyOnHand.intValue() == qtyOnHand.intValue()) {
        		 log.info("updated: " + ilView.getInventoryLevelData().getItemId());
        		 updatedIds.put(ilView.getInventoryLevelData().getItemId(), ilView.getInventoryLevelData().getQtyOnHand());
           	 }
         }
		 log.info("updatedIds.size(): " + updatedIds.size());
     } catch (Exception exc){
         log.error(exc);
         throw new RemoteException(exc.getMessage());
     } finally {
         closeConnection(conn);
     }
	 return updatedIds;
 } 

 public void processUpdateCatalog(Connection conn,String catalogloader,int storeNum, boolean isVersion1, String tmpTableName) throws RemoteException{
		log.info("Process Catalog Update");
        PreparedStatement stmt = null;
 		String sqlUpdateContractItem = 
		  "UPDATE clw_contract_item cti \n"+
		  " SET  (cti.amount,   cti.dist_cost, cti.mod_date,  cti.mod_by ) = \n"+
          "   (SELECT tmp.price, NVL (tmp.cost, tmp.price),  SYSDATE, '"+catalogloader+"' \n"+
          "      FROM "+ tmpTableName +" tmp \n"+
          "    WHERE  TMP.ACTION = 'C' \n"+
          "        AND tmp.CONTRACT_ITEM_ID > 0 \n"+
          "        AND CTI.CONTRACT_ITEM_ID = tmp.CONTRACT_ITEM_ID) \n"+
          " WHERE CTI.CONTRACT_ITEM_ID IN \n"+
          "   (SELECT CONTRACT_ITEM_ID  FROM "+ tmpTableName +" \n"+
          "     WHERE  ACTION = 'C' AND  contract_item_id > 0  )";
		String sqlUpdateItemAccoc = 
		  "UPDATE clw_item_assoc ia  \n"+
		  " SET  (ia.item2_id, ia.mod_date,  ia.mod_by ) = \n"+
          "   (SELECT tmp.category_Id,   SYSDATE, '"+catalogloader+"' \n"+
          "      FROM "+ tmpTableName +" tmp \n"+
          "    WHERE  TMP.ACTION = 'C' \n"+
          "        AND tmp.CATEGORY_ID > 0   \n"+
          "        AND ia.ITEM_ASSOC_ID = tmp.ITEM_ASSOC_ID) \n"+
		  " WHERE ia.ITEM_ASSOC_ID IN \n"+
          "   (SELECT ITEM_ASSOC_ID  FROM "+ tmpTableName +" \n"+
          "     WHERE  ACTION = 'C' AND ITEM_ASSOC_ID > 0 and CATEGORY_ID > 0   )";
		String sqlUpdateCatalogStructure= 
			"UPDATE clw_catalog_structure cs \n"+ 
			" SET  (cs.customer_sku_num, cs.tax_exempt, cs.bus_entity_id, cs.mod_date,  cs.mod_by ) = \n"+
	        "   (SELECT nvl(tmp.customer_sku, cs.customer_sku_num) , \n"+
	        "           nvl(tmp.tax_exempt, cs.tax_exempt ),\n"+
	        "           nvl(tmp.dist_id, cs.bus_entity_id ),\n"+
	        "           SYSDATE, '"+catalogloader+"'\n"+
	        "      FROM "+ tmpTableName +" tmp \n"+
	        "    WHERE  TMP.ACTION = 'C' \n"+
	        "        AND CS.CATALOG_STRUCTURE_ID = tmp.CATALOG_STRUCTURE_ID)\n"+
			" WHERE cs.CATALOG_STRUCTURE_ID IN \n"+
            "   (SELECT CATALOG_STRUCTURE_ID  FROM "+ tmpTableName +" \n"+
            "     WHERE  ACTION = 'C' AND CATALOG_STRUCTURE_ID > 0  )  ";
		
        String sqlUpdateItemMapping = 
        	"UPDATE clw_Item_Mapping im  \n"+
        	" SET  (im.item_num, im.item_uom, im.item_pack, /*im.bus_entity_id,*/im.standard_product_list, im.mod_date, im.mod_by ) = \n"+
        	" (SELECT \n" +
        	((isVersion1) ? "   nvl(tmp.dist_sku,im.item_num) " : " im.item_num ")+", \n"+
        	((isVersion1) ? "   nvl(tmp.dist_uom,im.item_uom) " : " im.item_uom ")+", \n"+
        	"   nvl(tmp.dist_pack,im.item_pack) ,  \n"+
        	//"   nvl(tmp.dist_id, im.bus_entity_id ), \n"+
        	"   nvl(tmp.spl, im.standard_product_list ),  \n"+
        	"   SYSDATE, '"+catalogloader+"'  \n"+
        	"   FROM "+ tmpTableName +" tmp  \n"+
        	"  WHERE  TMP.ACTION = 'C'  \n"+
        	"      AND Im.ITEM_MAPPING_ID = tmp.ITEM_MAPPING_ID)  \n"+
        	" WHERE Im.ITEM_MAPPING_ID IN  \n"+
        	"   (SELECT ITEM_MAPPING_ID  FROM "+ tmpTableName +"  \n"+
        	"      WHERE  ACTION = 'C' AND ITEM_MAPPING_ID > 0  )   \n";
        String sqlUpdateItem = 
        	"UPDATE clw_Item i  \n"+
        	" SET  (i.sku_num, i.mod_date, i.mod_by ) = \n"+
        	" (SELECT \n" +
        	((!isVersion1) ? "   nvl(tmp.store_sku,i.sku_num) " : " i.sku_num ")+", \n"+
        	"   SYSDATE, '"+catalogloader+"'  \n"+
        	"   FROM "+ tmpTableName +" tmp  \n"+
        	"  WHERE  TMP.ACTION = 'C'  \n"+
        	"      AND i.ITEM_ID = tmp.ITEM_ID)  \n"+
        	" WHERE I.ITEM_ID IN  \n"+
        	"   (SELECT ITEM_ID  FROM "+ tmpTableName +"  \n"+
        	"      WHERE  ACTION = 'C' AND ITEM_ID > 0  )   \n";
        	
		 String sql = "";
        // Action 'Change'
		try {
         stmt = conn.prepareStatement(sqlUpdateContractItem);
	     stmt.executeUpdate();
	     stmt.close();
	    } catch (SQLException ex) {
	        String msg = "An error occurred at updating of fields 'AMOUNT, DIST_COST'" +
	            "in the table CLW_CONTRACT_ITEM. " + ex.getMessage()+
	            "*** Execute the following request to get more information : " +  sqlUpdateContractItem;
	        //throw new SQLException("^clw^"+msg+ "^clw^");
	        throw new RemoteException("^clw^"+msg+ "^clw^");
	    }

		try {
         stmt = conn.prepareStatement(sqlUpdateCatalogStructure);
	     stmt.executeUpdate();
	     stmt.close();
	    } catch (SQLException ex) {
	        String msg = "An error occurred at updating of fields 'TAX_EXEMPT, CUSTOMER_SKU_NUM, DISTRIBUTOR'" +
	            "in the table CLW_CATALOG_STRUCTURE. " + ex.getMessage()+
	            "*** Execute the following request to get more information : " +  sqlUpdateCatalogStructure;
	        //throw new SQLException("^clw^"+msg+ "^clw^");
	        throw new RemoteException("^clw^"+msg+ "^clw^");

	    }		
		try {
	         stmt = conn.prepareStatement(sqlUpdateItemMapping);
		     stmt.executeUpdate();
		     stmt.close();
		    } catch (SQLException ex) {
		        String msg = "An error occurred at updating of fields 'ITEM2_ID (category)'" +
		            "in the table CLW_ITEM_MAPPING. " + ex.getMessage()+
		            "*** Execute the following request to get more information : " +  sqlUpdateItemMapping;
		        //throw new SQLException("^clw^"+msg+ "^clw^");
		        throw new RemoteException("^clw^"+msg+ "^clw^");

		}
		try {
         stmt = conn.prepareStatement(sqlUpdateItemAccoc);
	     stmt.executeUpdate();
	     stmt.close();
	    } catch (SQLException ex) {
	        String msg = "An error occurred at updating of fields 'CATEGORY_NAME'" +
	            "in the table CLW_ITEM_ASSOC. " + ex.getMessage()+
	            "*** Execute the following request to get more information : " +  sqlUpdateItemAccoc;
	        //throw new SQLException("^clw^"+msg+ "^clw^");
	        throw new RemoteException("^clw^"+msg+ "^clw^");

	    }	
	    // Action 'Delete'
		try {
			 sql = getDelItemUsingTmpTabSql("CLW_CONTRACT_ITEM", "contract_item_id", tmpTableName,"contract_item_id" );
	         stmt = conn.prepareStatement(sql);
		     stmt.executeUpdate();	     
		     stmt.close();
		     
		     sql = getDelItemUsingTmpTabSql("CLW_CATALOG_STRUCTURE", "catalog_structure_id", tmpTableName,"catalog_structure_id" );
	         stmt = conn.prepareStatement(sql);
		     stmt.executeUpdate();	     
		     stmt.close();
		     
		     //sql = getDelItemUsingTmpTabSql("CLW_ITEM_MAPPING", "item_mapping_id", tmpTableName,"item_mapping_id" );
	         //stmt = conn.prepareStatement(sql);
		     //stmt.executeUpdate();	     
		     //stmt.close();
		     
	         sql = getDelItemUsingTmpTabSql("CLW_ITEM_ASSOC", "item_assoc_id", tmpTableName,"item_assoc_id" );
		     stmt = conn.prepareStatement(sql);
		     stmt.executeUpdate();	     
		     stmt.close();
		     
		    } catch (SQLException ex) {
		        String msg = "An error occurred at the following request: SQL => " + sql+". \n"+ ex.getMessage();
		        //throw new SQLException("^clw^"+msg+ "^clw^");
		        throw new RemoteException("^clw^"+msg+ "^clw^");

		    }
		// Action Add
	        int insertedRowCount = 0;
	        try {
	            sql =
	                "INSERT INTO clw_contract_item  " +
	                "( " +
		                "CONTRACT_ITEM_ID,  " + 
		                "CONTRACT_ID,  " +     
		                "ITEM_ID,   " +         
		                "AMOUNT,    " +         
		                "DIST_COST,   " +       
		                "ADD_DATE,  " +
		                "ADD_BY,    " +
		                "MOD_DATE, " +
		                "MOD_BY     " + 
	                ") " +
	                "SELECT " +
	                    "clw_contract_item_seq.NEXTVAL, " +
	                    "tmp.CONTRACT_ID, " +
	                    "tmp.ITEM_ID, " +
	                    "tmp.PRICE, " +
	                    "tmp.COST, " +
	                    "SYSDATE, " +
	                    "?, " +
	                    "SYSDATE, " +
	                    "? " +
	                "FROM  " +
	                    tmpTableName + " tmp " +
	                "WHERE ACTION='A' and " +
	                    " tmp.catalog_type_cd = 'SHOPPING' and " +
	                    " tmp.CONTRACT_ITEM_ID IS NULL";
	            stmt = conn.prepareStatement(sql);
	            stmt.setString(1, catalogloader);
	            stmt.setString(2, catalogloader);
	            insertedRowCount = stmt.executeUpdate();
	            stmt.close();
	        }
	        catch (SQLException ex) {
	            String msg = "An error occurred at inserting of records into the table CLW_CONTRACT_ITEM" +
	                 ". " + ex.getMessage()+
	                 "*** Execute the following request to get more information : " +  sql;
	            throw new RemoteException("^clw^"+msg+ "^clw^");
	        }
	        //------------Add to clw_catalog_structure
	        for (int i= 0;  i<2; i++) {
		        try {
		            sql =
		                "INSERT INTO clw_catalog_structure  " +
		                "( " +
			                "CATALOG_STRUCTURE_ID,  " + 
			                "CATALOG_ID,  " +     
			                "ITEM_ID,   " +         
			                "BUS_ENTITY_ID,   " +         
			                "CATALOG_STRUCTURE_CD,    " +         
			                "CUSTOMER_SKU_NUM,   " +       
			                "TAX_EXEMPT,   " +       
			                "STATUS_CD,   " +       
			                "ADD_BY,    " +
			                "ADD_DATE,  " +
			                "MOD_BY,     " + 
			                "MOD_DATE " +
		                ") " +
		                "SELECT " +
		                    "clw_catalog_structure_seq.NEXTVAL, " +
		                    ((i==0) ? "tmp.CATALOG_ID, " : "tmp.ACC_CATALOG_ID,")+
		                    "tmp.ITEM_ID, " +
		                    ((i==0) ? "tmp.DIST_ID, " : "null,")+
		                    "'CATALOG_PRODUCT', " +
		                    "tmp.CUSTOMER_SKU, " +
		                    "tmp.TAX_EXEMPT, " +
		                    "'ACTIVE', " +
		                    "?, " +
		                    "SYSDATE, " +
		                    "?, " +
		                    "SYSDATE " +
		                "FROM  " +
		                    tmpTableName + " tmp " +
		                "WHERE ACTION='A' and " +
		                    ((i==0) ? "tmp.CATALOG_ID > 0" : "tmp.acc_catalog_id > 0" ) + " and " +
		                    "tmp.CATALOG_STRUCTURE_ID IS NULL";
		            stmt = conn.prepareStatement(sql);
		            stmt.setString(1, catalogloader);
		            stmt.setString(2, catalogloader);
		            insertedRowCount = stmt.executeUpdate();
		            stmt.close();
		        }
		        catch (SQLException ex) {
		            String msg = "An error occurred at inserting of records into the table CLW_CATALOG_STRUCTURE" +
		                 ". " + ex.getMessage()+
		                 "*** Execute the following request to get more information : " +  sql;
		            throw new RemoteException("^clw^"+msg+ "^clw^");
		        }
	        }
		    //------------Add to clw_item_assoc
	        for (int i= 0;  i<2; i++) {
		        try {
		            sql =
		                "INSERT INTO clw_item_assoc  " +
		                "( " +
			                "ITEM_ASSOC_ID,  " + 
			                "ITEM1_ID,  " +     
			                "ITEM2_ID,   " +         
			                "CATALOG_ID,   " +         
			                "ITEM_ASSOC_CD,    " +         
			                "ADD_BY,    " +
			                "ADD_DATE,  " +
			                "MOD_BY ,    " + 
			                "MOD_DATE " +
		                ") " +
		                "SELECT " +
		                    "clw_item_assoc_seq.NEXTVAL, " +
		                    "tmp.ITEM_ID, " +
		                    ((i==0) ? "tmp.CATEGORY_ID, " : "tmp.ACC_CATEGORY_ID, ") +
		                    ((i==0) ? "tmp.CATALOG_ID, "  : "tmp.ACC_CATALOG_ID, ") +
		                    "'PRODUCT_PARENT_CATEGORY', " +
		                    "?, " +
		                    "SYSDATE, " +
		                    "?, " +
		                    "SYSDATE " +
		                "FROM  " +
		                    tmpTableName + " tmp " +
		                "WHERE ACTION='A' and " +
		                	((i==0) ? "tmp.CATALOG_ID > 0" : "tmp.acc_catalog_id > 0" ) + " and " +
		                	((i==0) ? "tmp.CATEGORY_ID > 0" : "tmp.acc_category_id > 0" ) + " and " +
		                    "tmp.ITEM_ASSOC_ID IS NULL and " +
		                    "tmp.ITEM_ID > 0 " ;
		            stmt = conn.prepareStatement(sql);
		            stmt.setString(1, catalogloader);
		            stmt.setString(2, catalogloader);
		            insertedRowCount = stmt.executeUpdate();
		            stmt.close();
		        }
		        catch (SQLException ex) {
		            String msg = "An error occurred at inserting of records into the table CLW_ITEM_ASSOC" +
		                 ". " + ex.getMessage()+
		                 "*** Execute the following request to get more information : " +  sql;
		            throw new RemoteException("^clw^"+msg+ "^clw^");
		        }
	        }
	        //------------Add to clw_item_mapping
	        try {
	            sql =
	                "INSERT INTO clw_item_mapping  " +
	                "( " +
		                "ITEM_MAPPING_ID,  " + 
		                "ITEM_ID,  " +     
		                "BUS_ENTITY_ID,   " +         
		                "ITEM_NUM,   " +         
		                "ITEM_UOM,    " +         
		                "ITEM_PACK,    " +         
		                "STANDARD_PRODUCT_LIST,    " +         
		                "ITEM_MAPPING_CD,    " +         
		                "STATUS_CD,    " +         
		                "ADD_BY,    " +
		                "ADD_DATE,  " +
		                "MOD_BY,     " + 
		                "MOD_DATE " +
	                ") " +
	                "SELECT " +
	                    "clw_item_assoc_seq.NEXTVAL, " +
	                    "tmp.ITEM_ID, " +
	                    "tmp.DIST_ID, " +
	                    "tmp.DIST_SKU, " +
	                    "tmp.DIST_UOM, " +
	                    "tmp.DIST_PACK, " +
	                    "tmp.SPL, " +
	                    "'ITEM_DISTRIBUTOR', " +
	                    "'ACTIVE', " +
	                    "?, " +
	                    "SYSDATE, " +
	                    "?, " +
	                    "SYSDATE " +
	                "FROM  " +
	                    tmpTableName + " tmp " +
//	                "WHERE ACTION='A' and " +
	                "WHERE ACTION<>'D' and " +
	                    "tmp.ITEM_MAPPING_ID IS NULL and " +
	                    "tmp.ITEM_ID IS NOT NULL and " +
	                    "tmp.DIST_ID IS NOT NULL " ;
	            stmt = conn.prepareStatement(sql);
	            stmt.setString(1, catalogloader);
	            stmt.setString(2, catalogloader);
	            insertedRowCount = stmt.executeUpdate();
	            stmt.close();
	        }
	        catch (SQLException ex) {
	            String msg = "An error occurred at inserting of records into the table CLW_ITEM_MAPPING" +
	                 ". " + ex.getMessage()+
	                 "*** Execute the following request to get more information : " +  sql;
	            throw new RemoteException("^clw^"+msg+ "^clw^");
	        }

		  //------ adding/changing/delete items in/from Order Guide
	       processUpdateCatalogOrderGuides (conn, catalogloader,  tmpTableName); 
	        
	}
    
     private String getDelItemUsingTmpTabSql (String tabName, String primaryKeyCol, String tmpTabName, String tmpKeyCol) {
    	 String sql = 
    		 "DELETE  "+ tabName + " where " + primaryKeyCol + " in \n" +
    		 " (select " + tmpKeyCol + " from " + tmpTabName + " tmp \n" +
    		 "  where ACTION = 'D' and " + tmpKeyCol+ "> 0) ";
    	return sql;	
     }
     
    private void processUpdateCatalogOrderGuides (Connection conn,String catalogloader, String tmpTableName) throws RemoteException {
    	PreparedStatement stmt = null;
    	 String delSql = " delete clw_order_guide_structure  where ORDER_GUIDE_STRUCTURE_ID  in (\n" +
    		 " select OGS.ORDER_GUIDE_STRUCTURE_ID \n" +
    		 "   from clw_order_guide_structure ogs \n" +
    		 "	INNER JOIN "+ tmpTableName +" tmp  on ogs.item_id = tmp.item_id and tmp.action ='D'\n" +
    		 "	where ogs.order_guide_id in (  \n" +    
    		 "			select order_guide_id  \n" +
    		 "			from clw_order_guide og  \n" +
    		 "			INNER JOIN "+ tmpTableName +" tmp  on og.catalog_id = tmp.catalog_id " +
    		 "            and  tmp.action='D'\n" +
    		 "			where OG.ORDER_GUIDE_TYPE_CD <> 'DELETED' )  \n"+
    		 "  )";        
         try {
	    	 stmt = conn.prepareStatement(delSql);
		     stmt.executeUpdate();	     
		     stmt.close();
	     } catch (SQLException ex) {
		        String msg = "An error occurred at the following request: SQL => " + delSql+". \n"+ ex.getMessage();
	            throw new RemoteException("^clw^"+msg+ "^clw^");
	     }
    	 String sql = "select CATALOG_ID, ITEM_ID, CATEGORY_ID, ORDER_GUIDE_NAMES FROM "+ tmpTableName +
    	              " WHERE action ='A' and order_guide_names is not null" ;
    	 List<String> insertSqls =  new ArrayList<String>();
    	 try {
	    	 stmt = conn.prepareStatement(sql);
	         ResultSet rs = stmt.executeQuery();
	         String s="'";
	         List ogNames = new ArrayList();
	         
	         while(rs.next()) {   
	        	int catalogId = rs.getInt("CATALOG_ID"); 
	        	int itemId = rs.getInt("ITEM_ID"); 
	        	int categoryId = rs.getInt("CATEGORY_ID"); 
	        	String ogNamesS = rs.getString("ORDER_GUIDE_NAMES");
	        	if (Utility.isSet(ogNamesS)) {
	        		String[] arr = ogNamesS.split(",");
	        		for (int i=0; i<arr.length; i++){
	        			ogNames.add(arr[i]);
	        		}
	        	}
	        	
	        	insertSqls.add(getAddOrderGuideItemSql(catalogId, itemId, categoryId, Utility.toCommaSting(ogNames, new Character(s.charAt(0))),catalogloader ));
	         } 	
	         stmt.close();
	     } catch (SQLException ex) {
		        String msg = "An error occurred at the following request: SQL => " + sql+". \n"+ ex.getMessage();
	            throw new RemoteException("^clw^"+msg+ "^clw^");
	     }
	     try {
	         for (String req : insertSqls) {
	        	 sql = req;
		    	 stmt = conn.prepareStatement(sql);
			     stmt.executeUpdate();	     
			     stmt.close();
	         }
	     } catch (SQLException ex) {
	            String msg = "An error occurred at inserting of records into the table CLW_ORDER_GUIDE_STRUCTURE" +
                ". " + ex.getMessage()+
                "*** Execute the following request to get more information : " +  sql;
	            throw new RemoteException("^clw^"+msg+ "^clw^");
	     }
  	 
     }
 
     private String getAddOrderGuideItemSql (int pCatalogId, int pItemId, int pCategoryId, String ogNames, String catalogloader) {
    	 String sql = " insert into clw_order_guide_structure ( \n"+
    		 "   ORDER_GUIDE_STRUCTURE_ID, ORDER_GUIDE_ID, ITEM_ID, CATEGORY_ITEM_ID ,  \n"+
    		 "   QUANTITY, ADD_DATE, ADD_BY, MOD_DATE, MOD_BY ) \n"+
		 	 " select \n" +
		 	 	 " clw_order_guide_structure_seq.NEXTVAL, " +
				 " og.ORDER_GUIDE_ID, " + pItemId + ", " + pCategoryId +", 0, \n" +     
				 " sysdate, '" + catalogloader + "', \n" +
				 " sysdate, '" + catalogloader + "' \n" +
				"FROM clw_order_guide og \n" +
				"where catalog_id = "+ pCatalogId + "\n" +
				"  and short_desc in ( "+ ogNames + ")" + "\n" +
				"  and order_guide_type_cd  in ( \n"+
						"'"+RefCodeNames.ORDER_GUIDE_TYPE_CD.BUYER_ORDER_GUIDE+"', \n"+
						"'"+RefCodeNames.ORDER_GUIDE_TYPE_CD.ORDER_GUIDE_TEMPLATE+"', \n"+
						"'"+RefCodeNames.ORDER_GUIDE_TYPE_CD.SITE_ORDER_GUIDE_TEMPLATE+"')";
     	log.info("getAddOrderGuideItemSql() =======> sql ="+ sql); 
    	  return  sql;
     }
}

